{"gold_output": "theorem discrete_of_t1_of_finite {X : Type _} [TopologicalSpace X] [T1Space X] [Finite X] :\nDiscreteTopology X :=", "model_response": "lemma to_nat_injective:\n\"Function.Injective to_nat\""}
{"gold_output": "theorem Odd.sub_odd (hm : Odd m) (hn : Odd n) : Even (m - n) :=", "model_response": "lemma of_nat_sub [simp]: \"of_nat (m - n) = of_nat m - of_nat n\""}
{"gold_output": "theorem mul_mem_sup {S T : Subsemigroup M} {x y : M} (hx : x \u2208 S) (hy : y \u2208 T) : x * y \u2208 S \u2294 T :=", "model_response": "lemma bot_mul_eq_bot [simp]: \"(\u22a5 : Subsemigroup M) * M = \u22a5\""}
{"gold_output": "theorem P_f_idem (q n : \u2115) : ((P q).f n : X _[n] \u27f6 _) \u226b (P q).f n = (P q).f n :=", "model_response": "theorem P_f_idem (q n : \u2115) : ((P q).f n : X _[n] \u27f6 _) \u226b (P q).f n = (P q).f n :="}
{"gold_output": "theorem inf_toSubmodule (S T : Subalgebra R A) :\ntoSubmodule (S \u2293 T) = toSubmodule S \u2293 toSubmodule T :=", "model_response": "lemma coe_inf_eq (S T : Subalgebra R A) : (\u2191(S \u2293 T) : Set A) = (S : Set A) \u2229 T :="}
{"gold_output": "theorem units_inv_right_iff : Commute a \u2191u\u207b\u00b9 \u2194 Commute a u :=", "model_response": "lemma inv_mul_eq_inv_mul_inv : (a * b)\u207b\u00b9 = a\u207b\u00b9 * b\u207b\u00b9 :="}
{"gold_output": "theorem isLeftRegular_of_leftCancelSemigroup [LeftCancelSemigroup R]\n(g : R) : IsLeftRegular g :=", "model_response": "lemma isLeftRegular_of_leftRegular:\nassumes eq: \"g + g = g + g\"\nshows \"isLeftRegular g\""}
{"gold_output": "theorem bot_ne_hyperfilter : (\u22a5 : Filter \u03b1) \u2260 hyperfilter \u03b1 :=", "model_response": "lemma not_isCountablyGenerated_bot : \u00acIsCountablyGenerated (\u22a5 : Filter \u03b1) :="}
{"gold_output": "theorem lift_card (a) : Cardinal.lift.{u,v} (card a)= card (lift.{u,v} a) :=", "model_response": "lemma card_funcset (a b) : \"CARD('a \\<Rightarrow> 'b) = CARD('b::finite) ^ CARD('a::finite)\""}
{"gold_output": "theorem mulRight\u2080_symm_apply (c : \u03b1) (hc : c \u2260 0) :\n((Homeomorph.mulRight\u2080 c hc).symm : \u03b1 \u2192 \u03b1) = (\u00b7 * c\u207b\u00b9) :=", "model_response": "lemma Homeomorph_mulRight\u2080_symm_apply [simp]:\n\"(Homeomorph.mulRight\u2080 c hc).symm = (\u00b7 * c\u207b\u00b9)\""}
{"gold_output": "theorem insert_inter_of_not_mem (h : a \u2209 t) : insert a s \u2229 t = s \u2229 t :=", "model_response": "lemma set_compre_inter_eq: \"{x. x \\<in> s \\<and> x \\<in> t} = s \\<inter> t\""}
{"gold_output": "theorem closure_sUnion (s : Set (Set K)) : closure (\u22c3\u2080 s) = \u2a06 t \u2208 s, closure t :=", "model_response": "lemma closure_sUnion: \"closure (\u22c3\u2080 s) = \u2a06 t \u2208 s, closure t\""}
{"gold_output": "theorem Monovary.sum_mul_sum_le_card_mul_sum (hfg : Monovary f g) :\n((\u2211 i, f i) * \u2211 i, g i) \u2264 Fintype.card \u03b9 * \u2211 i, f i * g i :=", "model_response": "lemma sum_mul_sum_le_card_mul_sum :\n\"(\\<Sum>i\\<in>s. f i * g i) \\<le> Fintype.card s * (\\<Sum>i\\<in>s. f i * g i)\""}
{"gold_output": "theorem mapDomain_support_of_injOn [DecidableEq \u03b2] {f : \u03b1 \u2192 \u03b2} (s : \u03b1 \u2192\u2080 M)\n(hf : Set.InjOn f s.support) : (mapDomain f s).support = Finset.image f s.support :=", "model_response": "lemma support_mapDomain [simp]: \"support (mapDomain f s) = f '' support s\""}
{"gold_output": "theorem piChartedSpace_chartAt {\u03b9 : Type _} [Fintype \u03b9] (H : \u03b9 \u2192 Type _)\n[\u2200 i, TopologicalSpace (H i)] (M : \u03b9 \u2192 Type _) [\u2200 i, TopologicalSpace (M i)]\n[\u2200 i, ChartedSpace (H i) (M i)] (f : \u2200 i, M i) :\nchartAt (H := ModelPi H) f = LocalHomeomorph.pi fun i \u21a6 chartAt (H i) (f i) :=", "model_response": "lemma pi_charted_space_at_coord_change:\n\"(pi_charted_space H).toLocalHomeomorph.symm \u2218 pi_charted_space H).toLocalHomeomorph =\n(\\<Prod>i. (chartAt (H i) (f i)).toLocalHomeomorph.symm \u2218 chartAt (H i) (f i))\""}
{"gold_output": "theorem vsub_singleton (s : Set \u03b2) (b : \u03b2) : s -\u1d65 {b} = (\u00b7 -\u1d65 b) '' s :=", "model_response": "lemma toIcoMod_eq_self_iff: \"toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)\""}
{"gold_output": "theorem inf'_id_eq_csInf [ConditionallyCompleteLattice \u03b1] (s : Finset \u03b1) (H) :\ns.inf' H id = sInf s :=", "model_response": "lemma inf'_eq_cInf_image: \"s.inf' H id = sInf (id '' s)\""}
{"gold_output": "theorem forall_mem_union : (\u2200 x \u2208 l\u2081 \u222a l\u2082, p x) \u2194 (\u2200 x \u2208 l\u2081, p x) \u2227 \u2200 x \u2208 l\u2082, p x :=", "model_response": "lemma sep_set_of_union :\n\"{ x \\<in> l\\<^sub>1 \\<union> l\\<^sub>2 . p x } = { x \\<in> l\\<^sub>1 . p x } \\<union> { x \\<in> l\\<^sub>2 . p x }\""}
{"gold_output": "theorem \u0393_def : (\u0393 : _ \u2964 C) = forgetToPresheafedSpace.op \u22d9 PresheafedSpace.\u0393 :=", "model_response": "lemma forgetToPresheafedSpace_\u0393 :\n\"forgetToPresheafedSpace.op \u22d9 PresheafedSpace.\u0393 = forgetToPresheafedSpace.op\""}
{"gold_output": "theorem ofFn_mul' {m n} (f : Fin (m * n) \u2192 \u03b1) :\nList.ofFn f = List.join (List.ofFn fun i : Fin n => List.ofFn fun j : Fin m => f \u27e8m * i + j,\ncalc\nm * i + j < m * (i + 1) := (add_lt_add_left j.prop _).trans_eq (mul_add_one (_ : \u2115) _).symm\n_ \u2264 _ := Nat.mul_le_mul_left _ i.prop\u27e9) :=", "model_response": "lemma ofFn_eq_ofFn_iff {f g : Fin m * Fin n \u2192 \u03b1} :\nList.ofFn f = List.ofFn g \u2194 \u2200 i j, f \u27e8i, j\u27e9 = g \u27e8i, j\u27e9 :="}
{"gold_output": "theorem image_inter_subset (f : \u03b1 \u2192 \u03b2) (s t : Set \u03b1) : f '' (s \u2229 t) \u2286 f '' s \u2229 f '' t :=", "model_response": "lemma image_union: \"f '' (s \\<union> t) = f '' s \\<union> f '' t\""}
{"gold_output": "theorem fst_map_snd : (Submodule.fst R M M\u2082).map (LinearMap.snd R M M\u2082) = \u22a5 :=", "model_response": "lemma fst_range_subtype_comp_fst :\n\"(Submodule.subtype (range (LinearMap.fst R M M\u2082))).comp (LinearMap.fst R M M\u2082) = LinearMap.id\""}
{"gold_output": "theorem neg_one (p : \u2115) [Nontrivial R] [h : CharP R p] (hp : p \u2260 2) :\nIsPrimitiveRoot (-1 : R) 2 :=", "model_response": "lemma one_isPrimitiveRoot_char [simp]:\nfixes p :: nat\nassumes \"CHAR('a) = p\" \"p \\<noteq> 2\" and \"nontriv R\"\nshows \"isPrimitiveRoot (1 :: 'a :: ring_char_0) p\""}
{"gold_output": "theorem isClosed_iff_nhds {s : Set \u03b1} : IsClosed s \u2194 \u2200 x, (\u2200 U \u2208 \ud835\udcdd x, (U \u2229 s).Nonempty) \u2192 x \u2208 s :=", "model_response": "lemma closed_le' : \"closed {x. x \\<le> a}\" :="}
{"gold_output": "theorem gcd_ndinsert (a : \u03b1) (s : Multiset \u03b1) : (ndinsert a s).gcd = GCDMonoid.gcd a s.gcd :=", "model_response": "lemma gcd_eq_fold [code]:\n\"s.gcd = fold gcd s 0\""}
{"gold_output": "theorem mul_quot {a b} : (\u27e8Quot.mk _ a\u27e9 * \u27e8Quot.mk _ b\u27e9 : RingQuot r) = \u27e8Quot.mk _ (a * b)\u27e9 :=", "model_response": "lemma mul_quot_mk [simp]: \"(\u27e8Quot.mk _ a\u27e9 * \u27e8Quot.mk _ b\u27e9 : RingQuot r) = \u27e8Quot.mk _ (a * b)\u27e9\""}
{"gold_output": "theorem coe_finset_inf (f : \u03b9 \u2192 Closeds \u03b1) (s : Finset \u03b9) :\n(\u2191(s.inf f) : Set \u03b1) = s.inf ((\u2191) \u2218 f) :=", "model_response": "lemma coe_finset_inf (f : \u03b9 \u2192 Closeds \u03b1) (s : Finset \u03b9) :\n{ x | x \u2208 s.inf f } = s.inf ((\u2191) \u2218 f) :="}
{"gold_output": "theorem coe_floor_self (k : K) : (floor (Basis.singleton \u03b9 K) k : K) = \u230ak\u230b :=", "model_response": "lemma floor_self: \"floor (Basis.singleton \u03b9 K) k = \u230ak\u230b\""}
{"gold_output": "theorem IsMaxOn.sub (hf : IsMaxOn f s a) (hg : IsMinOn g s a) : IsMaxOn (fun x => f x - g x) s a :=", "model_response": "lemma continuousWithinAt_f: \"continuousWithinAt f s a\""}
{"gold_output": "theorem C_mul_X_eq_monomial : C a * X = monomial 1 a :=", "model_response": "theorem toFinsupp_injective : Function.Injective (toFinsupp : MvPolynomial \u03c3 R \u2192 \u03c3 \u2192\u2080 R) :="}
{"gold_output": "theorem kernel_map_comp_preserves_kernel_iso_inv {X' Y' : C} (g : X' \u27f6 Y') [HasKernel g]\n[HasKernel (G.map g)] [PreservesLimit (parallelPair g 0) G] (p : X \u27f6 X') (q : Y \u27f6 Y')\n(hpq : f \u226b q = p \u226b g) :\nkernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [\u2190 G.map_comp, hpq, G.map_comp]) \u226b\n(PreservesKernel.iso G _).inv =\n(PreservesKernel.iso G _).inv \u226b G.map (kernel.map f g p q hpq) :=", "model_response": "lemma kernel.map_comp_preservesKernelIso_inv {X' Y' : C} (g : X' \u27f6 Y') [HasKernel g]\n[HasKernel (G.map g)] [PreservesLimit (parallelPair g 0) G] (p : X \u27f6 X') (q : Y \u27f6 Y')\n(hpq : f \u226b q = p \u226b g) :\nkernel.map (G.map f) (G.map g) (G.map p) (G.map q) (by rw [\u2190 G.map_comp, hpq, G.map_comp]) \u226b\n(PreservesKernel.iso G _).inv =\n(PreservesKernel.iso G _).inv \u226b G.map (kernel.map f g p q hpq) :="}
{"gold_output": "theorem comp_id_left (B : BilinForm R M) (r : M \u2192\u2097[R] M) :\nB.comp LinearMap.id r = B.compRight r :=", "model_response": "lemma neg_comp (B : BilinForm R M) (r : M \u2192\u2097[R] M) : (-B).comp r = -B.comp r :="}
{"gold_output": "theorem inf_cons {b : \u03b2} (h : b \u2209 s) : (cons b s h).inf f = f b \u2293 s.inf f :=", "model_response": "lemma inf_insert [simp]:\n\"(insert a s).inf f = f a \u2293 s.inf f\""}
{"gold_output": "theorem point_finite (x : X) : { i | f i x \u2260 0 }.Finite :=", "model_response": "lemma summable_on_iff_summable_restrict [simp]:\n\"(f summable_on s) \\<longleftrightarrow> ((\\<lambda>x. f (restrict f s x)) summable s)\""}
{"gold_output": "theorem bihimp_bihimp_cancel_right : b \u21d4 a \u21d4 a = b :=", "model_response": "lemma inf_commutative : a \\<sqinter> b = b \\<sqinter> a :="}
{"gold_output": "theorem fg_bot : (\u22a5 : Subalgebra R A).FG :=", "model_response": "lemma coe_bot_eq_zero : ((\u22a5 : Subalgebra R A) : Set A) = {0} :="}
{"gold_output": "theorem coe_pos (x : Ioc (0 : \u03b1) 1) : 0 < (x : \u03b1) :=", "model_response": "lemma add_to_Zp:\nfixes x y :: R\nshows \"to_Zp (x \\<oplus> y) = to_Zp x \\<oplus>\\<^bsub>Zp\\<^esub> to_Zp y\""}
{"gold_output": "theorem linearMapAt_symm\u2097 (e : Trivialization F (\u03c0 E)) [e.IsLinear R] {b : B} (hb : b \u2208 e.baseSet)\n(y : F) : e.linearMapAt R b (e.symm\u2097 R b y) = y :=", "model_response": "lemma symm\u2097_def_of_mem (e : Trivialization F (\u03c0 E)) [e.IsLinear R] {b : B} (hb : b \u2208 e.baseSet)\n(y : F) : e.linearMapAt R b (e.symm\u2097 R b y) = e.symm b y :="}
{"gold_output": "theorem locallyConnectedSpace_iff_open_connected_subsets :\nLocallyConnectedSpace \u03b1 \u2194\n\u2200 x, \u2200 U \u2208 \ud835\udcdd x, \u2203 V : Set \u03b1, V \u2286 U \u2227 IsOpen V \u2227 x \u2208 V \u2227 IsConnected V :=", "model_response": "lemma connected_Iic [simp]: \"connected {a | a \\<le> x}\"\nfor x :: \"'a::linorder_topology\""}
{"gold_output": "theorem balanced_iff_smul_mem : Balanced \ud835\udd5c s \u2194 \u2200 \u2983a : \ud835\udd5c\u2984, \u2016a\u2016 \u2264 1 \u2192 \u2200 \u2983x : E\u2984, x \u2208 s \u2192 a \u2022 x \u2208 s :=", "model_response": "lemma balanced_iff_smul_mem :\n\"balanced \ud835\udd5c s \\<longleftrightarrow> (\\<forall>a : \ud835\udd5c. \u2016a\u2016 \u2264 1 \\<longrightarrow> (\\<forall>x : E. x \\<in> s \\<longrightarrow> a \u2022 x \\<in> s))\""}
{"gold_output": "theorem map\u2082_map_left (m : \u03b3 \u2192 \u03b2 \u2192 \u03b4) (n : \u03b1 \u2192 \u03b3) :\nmap\u2082 m (f.map n) g = map\u2082 (fun a b => m (n a) b) f g :=", "model_response": "lemma map_injective_iff: \"inj (map f) = inj f\""}
{"gold_output": "theorem isNoetherian_of_fg_of_noetherian' {R M} [Ring R] [AddCommGroup M] [Module R M]\n[IsNoetherianRing R] (h : (\u22a4 : Submodule R M).FG) : IsNoetherian R M :=", "model_response": "lemma toSubsemiring_strictMono :\n\"StrictMono (toSubsemiring : Subring R \u2192 Subsemiring R)\""}
{"gold_output": "theorem decode\u2082_is_partial_inv [Encodable \u03b1] : IsPartialInv encode (decode\u2082 \u03b1) :=", "model_response": "lemma encode_decode\u2082 [simp]:\nassumes \"isPartialInv decode\u2082 \u03b1 encode\"\nshows \"decode\u2082 \u03b1 (encode x) = some x\""}
{"gold_output": "theorem ne_of_vne {i j : Fin n} (h : i.val \u2260 j.val) : i \u2260 j :=", "model_response": "lemma card_fintype_fin_diff_singleton [simp]:\nshows \"Fintype.card (Fin n - {a}) = n - 1\""}
{"gold_output": "theorem isEmpty_sum {\u03b1 \u03b2} : IsEmpty (Sum \u03b1 \u03b2) \u2194 IsEmpty \u03b1 \u2227 IsEmpty \u03b2 :=", "model_response": "lemma inl_injective [simp]: \"inj (inl : \u03b1 \u2192 Sum \u03b1 \u03b2)\""}
{"gold_output": "theorem monotone_and {p q : \u03b1 \u2192 Prop} (m_p : Monotone p) (m_q : Monotone q) :\nMonotone fun x => p x \u2227 q x :=", "model_response": "lemma monotone: \"monotone f\""}
{"gold_output": "theorem sInf_nonpos (S : Set \u211d) (hS : \u2200 x \u2208 S, x \u2264 (0 : \u211d)) : sInf S \u2264 0 :=", "model_response": "lemma sInf_nonpos_eq : \"sInf {x \\<in> S. x \\<le> (0::real)} = sInf S\""}
{"gold_output": "theorem continuousWithinAt_Ioc_iff_Iic [TopologicalSpace \u03b2] {a b : \u03b1} {f : \u03b1 \u2192 \u03b2} (h : a < b) :\nContinuousWithinAt f (Ioc a b) b \u2194 ContinuousWithinAt f (Iic b) b :=", "model_response": "lemma continuousWithinAt_Ioc_iff_Iic':\n\"ContinuousWithinAt f (Ioc a b) b \\<longleftrightarrow> ContinuousWithinAt f (Iic b) b\""}
{"gold_output": "theorem map_alternatingFaceMapComplex {D : Type _} [Category D] [Preadditive D] (F : C \u2964 D)\n[F.Additive] :\nalternatingFaceMapComplex C \u22d9 F.mapHomologicalComplex _ =\n(SimplicialObject.whiskering C D).obj F \u22d9 alternatingFaceMapComplex D :=", "model_response": "lemma alternatingFaceMapComplex_comp_map:\n\"alternatingFaceMapComplex C \u22d9 mapHomologicalComplex F =\n(SimplicialObject.whiskering C D).obj F \u22d9 alternatingFaceMapComplex D\""}
{"gold_output": "theorem trans [Algebra A B] [IsScalarTower R A B] (hRA : FiniteType R A) (hAB : FiniteType A B) :\nFiniteType R B :=", "model_response": "theorem finiteType_iff [simp]:\n\"finite (UNIV :: B set) \\<longleftrightarrow> finite (UNIV :: A set)\""}
{"gold_output": "theorem pwFilter_nil : pwFilter R [] = [] :=", "model_response": "lemma pwFilter_nil:\nassumes \"\\<And> x y. (x, y) \\<in> R \\<Longrightarrow> x = y\"\nshows \"pwFilter R [] = []\""}
{"gold_output": "theorem induction_on {C : AdjoinRoot f \u2192 Prop} (x : AdjoinRoot f) (ih : \u2200 p : R[X], C (mk f p)) :\nC x :=", "model_response": "lemma mk_surjective : \"Function.Surjective mk\""}
{"gold_output": "theorem map_of_not_aemeasurable {f : \u03b1 \u2192 \u03b2} {\u03bc : Measure \u03b1} (hf : \u00acAEMeasurable f \u03bc) :\n\u03bc.map f = 0 :=", "model_response": "lemma measure_map_eq_zero_iff {f : \u03b1 \u2192 \u03b2} {\u03bc : Measure \u03b1} (hf : \u00acAEMeasurable f \u03bc) {s : Set \u03b1} :\n\u03bc.map f s = 0 \u2194 \u03bc s = 0 :="}
{"gold_output": "theorem coe_symm_of_not_mem (e : Pretrivialization F (\u03c0 E)) {b : B} (hb : b \u2209 e.baseSet) :\n(e.symm b : F \u2192 E b) = 0 :=", "model_response": "lemma symm_coe_of_not_mem: \"(e.toLocalHomeomorph.symm b : F \u2192 E b) = 0\""}
{"gold_output": "theorem C_inj : C a = C b \u2194 a = b :=", "model_response": "lemma toFinsupp_inj : (toFinsupp a = toFinsupp b) = (a = b) :="}
{"gold_output": "theorem Perm.subtypeCongr.right_apply_subtype (a : { a // \u00acp a }) : ep.subtypeCongr en a = en a :=", "model_response": "lemma continuous_at_iff_continuous_at_0:\n\"continuous (at x) f \\<longleftrightarrow> continuous (at 0) (f \\<circ> (\u00b7 + x))\""}
{"gold_output": "theorem le_ediv_of_mul_le {a b c : \u2124} (H1 : 0 < c) (H2 : a * c \u2264 b) : a \u2264 b / c :=", "model_response": "lemma le_div_of_mul_le:\nfixes a b c :: \u2124\nassumes \"c > 0\" \"a \\<le> b * c\"\nshows \"a \\<le> b div c\""}
{"gold_output": "theorem inf_coe_to_submodule :\n(\u2191(K \u2293 K') : Submodule R L) = (K : Submodule R L) \u2293 (K' : Submodule R L) :=", "model_response": "lemma sup_coe_to_submodule :\n\"(\u2191(K \u2294 K') : Submodule R L) = (K : Submodule R L) \u2294 (K' : Submodule R L)\""}
{"gold_output": "theorem lt_rpow_of_log_lt (hx : 0 \u2264 x) (hy : 0 < y) (h : Real.log x < z * Real.log y) :\nx < y ^ z :=", "model_response": "lemma continuousAt_of_real: \"continuousAt of_real x\""}
{"gold_output": "theorem pairwise_of_reflexive_of_forall_ne {l : List \u03b1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (hr : Reflexive r)\n(h : \u2200 a \u2208 l, \u2200 b \u2208 l, a \u2260 b \u2192 r a b) : l.Pairwise r :=", "model_response": "lemma pairwise_of_forall_ne_imp:\nassumes \"\\<And>a b. a \\<in> l \\<Longrightarrow> b \\<in> l \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow> r a b\"\nshows \"pairwise r l\""}
{"gold_output": "theorem union_ae_eq_left_of_ae_eq_empty (h : t =\u1d50[\u03bc] (\u2205 : Set \u03b1)) : (s \u222a t : Set \u03b1) =\u1d50[\u03bc] s :=", "model_response": "lemma union_ae_eq_left_empty : \"(s \u222a {}) =\u1d50[\u03bc] s\""}
{"gold_output": "theorem mem_inv_pointwise_smul_iff {a : \u03b1} {S : Submonoid M} {x : M} : x \u2208 a\u207b\u00b9 \u2022 S \u2194 a \u2022 x \u2208 S :=", "model_response": "lemma inv_mem_pointwise_smul_iff [simp]: \"a\u207b\u00b9 \u2208 a \u2022 S \u2194 a \u2208 S\""}
{"gold_output": "theorem nadd_le_iff : b \u266f c \u2264 a \u2194 (\u2200 b' < b, b' \u266f c < a) \u2227 \u2200 c' < c, b \u266f c' < a :=", "model_response": "lemma of_nat_add: \"of_nat (m + n) = of_nat m + of_nat n\""}
{"gold_output": "theorem card_sym_eq_multichoose (\u03b1 : Type _) (k : \u2115) [Fintype \u03b1] [Fintype (Sym \u03b1 k)] :\ncard (Sym \u03b1 k) = multichoose (card \u03b1) k :=", "model_response": "lemma card_lists_length_eq' [simp]: \"card {l. length l = n} * card {m} = multichoose m n\""}
{"gold_output": "theorem fderiv_mul_const (hc : DifferentiableAt \ud835\udd5c c x) (d : \ud835\udd38') :\nfderiv \ud835\udd5c (fun y => c y * d) x = d \u2022 fderiv \ud835\udd5c c x :=", "model_response": "lemma fderiv_const_mul [simp]: \"fderiv \ud835\udd5c (fun y => d * c y) x = d \u2022 fderiv \ud835\udd5c c x\""}
{"gold_output": "theorem sub_comp : (f - f') \u226b g = f \u226b g - f' \u226b g :=", "model_response": "lemma sub_comp : (f - f') \\<cdot> g = f \\<cdot> g - f' \\<cdot> g :="}
{"gold_output": "theorem lineCount_eq [Finite P] [Finite L] (p : P) : lineCount L p = order P L + 1 :=", "model_response": "lemma lineCount_pos [simp]: \"lineCount p > 0\""}
{"gold_output": "theorem factorMultiset_one : factorMultiset 1 = 0 :=", "model_response": "lemma factorMultiset_0 [simp]: \"factorMultiset 0 = {#0#}\""}
{"gold_output": "theorem infiniteNeg_def {x : \u211d*} : InfiniteNeg x \u2194 \u2200 r : \u211d, x < r :=", "model_response": "lemma abs_re_lt_abs_iff_imaginary: \"abs (re z) < abs z  \\<longleftrightarrow> (im z \\<noteq> 0)\""}
{"gold_output": "theorem unit_eq_unit : FreeMonoidalCategory.Unit = \ud835\udfd9_ (F C) :=", "model_response": "theorem naturality_unit: \"F o of = id\""}
{"gold_output": "theorem map\u2082_map_right (f : \u03b1 \u2192 \u03b3 \u2192 \u03b4) (g : \u03b2 \u2192 \u03b3) :\nmap\u2082 f a (b.map g) = map\u2082 (fun a b => f a (g b)) a b :=", "model_response": "lemma continuousAt_map2_iff:\n\"continuousAt f a \\<longleftrightarrow> continuousAt (fun x : \u03b1 \u00d7 \u03b2 => f x.1 x.2) (a, b)\""}
{"gold_output": "theorem map_subtype_embedding_Ioi : (Ioi a).map (Embedding.subtype p) = (Ioi a : Finset \u03b1) :=", "model_response": "lemma card_Ici_eq_card_finset_Ici: \"card (Ici a) = card (Finset.Ici a)\""}
{"gold_output": "theorem eraseTop_top_le (s : CompositionSeries X) : s.eraseTop.top \u2264 s.top :=", "model_response": "lemma length_eraseTop (s : CompositionSeries X) : s.eraseTop.length = s.length - 1 :="}
{"gold_output": "theorem continuousAt_extChartAt_symm : ContinuousAt (extChartAt I x).symm ((extChartAt I x) x) :=", "model_response": "lemma continuousAt_extChartAt_symm: \"continuousAt (extChartAt I x).symm ((extChartAt I x) x)\""}
{"gold_output": "theorem not_bddBelow_iff' : \u00acBddBelow s \u2194 \u2200 x, \u2203 y \u2208 s, \u00acx \u2264 y :=", "model_response": "lemma bddAbove_setOf : \"BddAbove {x. P x}\""}
{"gold_output": "theorem Monotone.intervalIntegrable {u : \u211d \u2192 E} {a b : \u211d} (hu : Monotone u) :\nIntervalIntegrable u \u03bc a b :=", "model_response": "lemma interval_integrable [intro, simp]: \"IntervalIntegrable u \u03bc a b\""}
{"gold_output": "theorem aestronglyMeasurable_zero_measure [MeasurableSpace \u03b1] [TopologicalSpace \u03b2] (f : \u03b1 \u2192 \u03b2) :\nAEStronglyMeasurable f (0 : Measure \u03b1) :=", "model_response": "lemma aestronglyMeasurable_zero_measure [simp]:\n\"aestronglyMeasurable f (0 : Measure \\<Omega>)\""}
{"gold_output": "theorem multiset_prod_subset_multiset_prod (t : Multiset \u03b9) (f\u2081 f\u2082 : \u03b9 \u2192 Set \u03b1)\n(hf : \u2200 i \u2208 t, f\u2081 i \u2286 f\u2082 i) : (t.map f\u2081).prod \u2286 (t.map f\u2082).prod :=", "model_response": "lemma Pi_mono: \"Pi (t.map (f\\<^sub>1 :: \u03b9 \u2192 Set \u03b1)) \\<subseteq> Pi (t.map f\\<^sub>2)\""}
{"gold_output": "theorem measurableSet_generateFrom {s : Set (Set \u03b1)} {t : Set \u03b1} (ht : t \u2208 s) :\nMeasurableSet[generateFrom s] t :=", "model_response": "lemma generateFrom_mono : Monotone (generateFrom) :="}
{"gold_output": "theorem mk_toPartENat_of_infinite [h : Infinite \u03b1] : toPartENat (#\u03b1) = \u22a4 :=", "model_response": "theorem mk_toPartENat_aleph0 : toPartENat \u2135\u2080 = \u22a4 :="}
{"gold_output": "theorem roots_map {f : K[X]} (hf : f.Splits <| RingHom.id K) : (f.map i).roots = f.roots.map i :=", "model_response": "lemma degree_map_eq [simp]:\n\"degree (f.map i) = degree f\""}
{"gold_output": "theorem toAddMonoidHom_id : (CentroidHom.id \u03b1 : \u03b1 \u2192+ \u03b1) = AddMonoidHom.id \u03b1 :=", "model_response": "lemma coe_id : (CentroidHom.id \u03b1 : \u03b1 \u2192+ \u03b1) = AddMonoidHom.id \u03b1 :="}
{"gold_output": "theorem inducing_embedProduct : Inducing (embedProduct M) :=", "model_response": "lemma continuous_embedProduct: \"continuous (embedProduct M)\""}
{"gold_output": "theorem Monotone.map_limsup_of_continuousAt {f : R \u2192 S} (f_incr : Monotone f) (a : \u03b9 \u2192 R)\n(f_cont : ContinuousAt f (F.limsup a)) : f (F.limsup a) = F.limsup (f \u2218 a) :=", "model_response": "lemma continuousAt_limsup_iff:\n\"continuousAt f (F.limsup a) \\<longleftrightarrow> continuousAt f (Sup (range a))\""}
{"gold_output": "theorem Monotone.cauchySeq_series_mul_of_tendsto_zero_of_bounded (hfa : Monotone f)\n(hf0 : Tendsto f atTop (\ud835\udcdd 0)) (hgb : \u2200 n, \u2016\u2211 i in range n, z i\u2016 \u2264 b) :\nCauchySeq fun n \u21a6 \u2211 i in range (n + 1), f i \u2022 z i :=", "model_response": "lemma summable_smul_iff: \"summable (\\<lambda>n. f n * c) \\<longleftrightarrow> summable f\""}
{"gold_output": "theorem tsum_smul_const [T2Space M] (hf : Summable f) (a : M) : (\u2211' z, f z \u2022 a) = (\u2211' z, f z) \u2022 a :=", "model_response": "lemma summable_norm_smul_iff [simp]: \"(\\<lambda>x. norm (f x) * a) summable \\<longleftrightarrow> f summable\""}
{"gold_output": "theorem inter_cylinder_longestPrefix_nonempty {s : Set (\u2200 n, E n)} (hs : IsClosed s)\n(hne : s.Nonempty) (x : \u2200 n, E n) : (s \u2229 cylinder x (longestPrefix x s)).Nonempty :=", "model_response": "lemma sets_in_space_piE [simp]: \"{x\\<in>Pi\\<^sub>E I M. \\<forall>i\\<in>I. x i \\<in> space (M i)} = UNIV\""}
{"gold_output": "theorem le_of_lt_succ {a b : \u03b1} : a < succ b \u2192 a \u2264 b :=", "model_response": "lemma le_of_lt_succ_of_minimal:\nassumes \"a < succ b\"\nshows \"a \\<le> b\""}
{"gold_output": "theorem IsHausdorff.haus (_ : IsHausdorff I M) :\n\u2200 x : M, (\u2200 n : \u2115, x \u2261 0 [SMOD (I ^ n \u2022 \u22a4 : Submodule R M)]) \u2192 x = 0 :=", "model_response": "lemma toSubmodule_injective : Function.Injective toSubmodule :="}
{"gold_output": "theorem mono_ac {\u03bd : Measure \u03b1} {\u03c6 : \u03b9 \u2192 Set \u03b1} (h\u03c6 : AECover \u03bc l \u03c6) (hle : \u03bd \u226a \u03bc) :\nAECover \u03bd l \u03c6 :=", "model_response": "lemma measure_iUnion_null_iff {\u03bd : Measure \u03b1} {\u03c6 : \u03b9 \u2192 Set \u03b1} (h\u03c6 : AECover \u03bc l \u03c6)\n(hle : \u03bd \u226a \u03bc) : \u03bd (\u22c3 i, \u03c6 i) = 0 \u2194 \u2200 i, \u03bd (\u03c6 i) = 0 :="}
{"gold_output": "theorem preconnectedSpace [PreconnectedSpace \u03b1] (di : DenseInducing i) :\nPreconnectedSpace \u03b2 :=", "model_response": "lemma denseEmbedding_to_conjugate_space' :\n\"denseEmbedding (to_conjugate_space' : C(\u03b1, \ud835\udd5c) \u2192 C(\u03b1, \ud835\udd5c\u1d50\u1d52\u1d56))\""}
{"gold_output": "theorem ofRat_rat {abv : \u211a \u2192 \u211a} [IsAbsoluteValue abv] (q : \u211a) :\nofRat (q : \u211a) = (q : Cauchy abv) :=", "model_response": "lemma fract_sub_bound: \"abv (fract a - fract b) \u2264 fract (a - b)\""}
{"gold_output": "theorem mapRange.addEquiv_refl : mapRange.addEquiv (AddEquiv.refl M) = AddEquiv.refl (\u03b1 \u2192\u2080 M) :=", "model_response": "lemma mapRange_addEquiv_injective_iff :\n\"Function.Injective f \\<longleftrightarrow> Function.Injective (mapRange.addEquiv f)\""}
{"gold_output": "theorem succ_one_eq_two' : Fin.succ (1 : Fin (n + 2)) = 2 :=", "model_response": "lemma one_succ' : \"Fin.succ (1 : Fin (n + 2)) = 2\""}
{"gold_output": "theorem max_of_nonempty {s : Finset \u03b1} (h : s.Nonempty) : \u2203 a : \u03b1, s.max = a :=", "model_response": "lemma sep_eq_sep_true : \"{ x \u2208 s | P x } = { x \u2208 s | True }\""}
{"gold_output": "theorem _root_.Submodule.map_comap_eq [RingHomSurjective \u03c4\u2081\u2082] (f : F) (q : Submodule R\u2082 M\u2082) :\nmap f (comap f q) = range f \u2293 q :=", "model_response": "lemma comap_id [simp]: \"comap (id : M\u2081 \u2192\u2097[R\u2081] M\u2081) = id\""}
{"gold_output": "theorem coe_basisOneIJK_repr (q : \u210d[R,c\u2081,c\u2082]) :\n\u21d1((basisOneIJK c\u2081 c\u2082).repr q) = ![q.re, q.imI, q.imJ, q.imK] :=", "model_response": "lemma norm_add_le: \"norm (x + y) \\<le> norm x + norm y\""}
{"gold_output": "theorem measurable_to_countable [MeasurableSpace \u03b1] [Countable \u03b1] [MeasurableSpace \u03b2] {f : \u03b2 \u2192 \u03b1}\n(h : \u2200 y, MeasurableSet (f \u207b\u00b9' {f y})) : Measurable f :=", "model_response": "lemma measurable_toIcoMod: \"measurable (toIcoMod hp a)\""}
{"gold_output": "theorem coeff_neg (p : R[X]) (n : \u2115) : coeff (-p) n = -coeff p n :=", "model_response": "lemma coeff_neg [simp]: \"coeff (-p) n = -coeff p n\""}
{"gold_output": "theorem Icc_ssubset_Icc_left (hI : a\u2082 \u2264 b\u2082) (ha : a\u2082 < a\u2081) (hb : b\u2081 \u2264 b\u2082) : Icc a\u2081 b\u2081 \u2282 Icc a\u2082 b\u2082 :=", "model_response": "lemma Ico_ssubset_Ico_iff [simp]:\n\"Ico a\u2081 b\u2081 \\<subset> Ico a\u2082 b\u2082 \u2194 a\u2082 < a\u2081 \u2227 b\u2081 \u2264 b\u2082\""}
{"gold_output": "theorem compl [Zero \u03b1] [One \u03b1] (h : IsAdjMatrix A) : IsAdjMatrix A.compl :=", "model_response": "lemma compl_eq [simp]:\n\"A.compl = of (compl_mat (of A))\""}
{"gold_output": "theorem _root_.SimpleGraph.simpleGraphOfStructure (G : SimpleGraph V) :\n@simpleGraphOfStructure V G.structure _ = G :=", "model_response": "lemma verts_union_edge_sets :\n\"G.verts = G.tail ` G.edge_set \\<union> G.head ` G.edge_set\""}
{"gold_output": "theorem pow_two_sub_pow (hyx : y < x) (hxy : 2 \u2223 x - y) (hx : \u00ac2 \u2223 x) {n : \u2115} (hn : 0 < n)\n(hneven : Even n) :\npadicValNat 2 (x ^ n - y ^ n) + 1 =\npadicValNat 2 (x + y) + padicValNat 2 (x - y) + padicValNat 2 n :=", "model_response": "lemma padicValNat_add:\n\"padicValNat 2 (x + y) = min (padicValNat 2 x) (padicValNat 2 y)\""}
{"gold_output": "theorem smul_def (a : M) (x : \u03b1 \u00d7 \u03b2) : a \u2022 x = (a \u2022 x.1, a \u2022 x.2) :=", "model_response": "lemma smul_def' [simp]: \"a \u2022 x = (a \u2022 x.1, a \u2022 x.2)\""}
{"gold_output": "theorem eq_top_iff' : S = \u22a4 \u2194 \u2200 x : M, x \u2208 S :=", "model_response": "lemma setOf_mem_eq : \"{x \\<in> M. x \\<in> S} = S\""}
{"gold_output": "theorem continuous_nndist : Continuous fun p : \u03b1 \u00d7 \u03b1 => nndist p.1 p.2 :=", "model_response": "lemma continuous_to_real_nonneg: \"continuous to_real_nonneg\""}
{"gold_output": "theorem coe_GLPos_coe_GL_coe_matrix (g : SpecialLinearGroup n R) :\n(\u2191(\u2191(\u2191g : GLPos n R) : GL n R) : Matrix n n R) = \u2191g :=", "model_response": "lemma det_coe_GLPos_coe_GL_coe (g : SpecialLinearGroup n R) :\ndet \u2191(\u2191(\u2191g : GLPos n R) : GL n R) = 1 :="}
{"gold_output": "theorem union_subset_union_right (h : t\u2081 \u2286 t\u2082) : s \u222a t\u2081 \u2286 s \u222a t\u2082 :=", "model_response": "lemma union_sdiff_subset_union_right : \"s \\<union> (t\\<^sub>2 \\ t\\<^sub>1) \\<subseteq> s \\<union> t\\<^sub>2\""}
{"gold_output": "theorem map_id : map (MulHom.id \u03b1) = MonoidHom.id (WithOne \u03b1) :=", "model_response": "lemma map_id_eq_monoidHom_id: \"map (MulHom.id \u03b1) = MonoidHom.id (WithOne \u03b1)\""}
{"gold_output": "theorem ContinuousLinearMap.toExposed.isExposed : IsExposed \ud835\udd5c A (l.toExposed A) :=", "model_response": "lemma toExposed_continuous:\n\"continuous (toExposed l)\""}
{"gold_output": "theorem prod_image_image_eq {m\u2081 : \u03b1 \u2192 \u03b3} {m\u2082 : \u03b2 \u2192 \u03b4} :\n(m\u2081 '' s) \u00d7\u02e2 (m\u2082 '' t) = (fun p : \u03b1 \u00d7 \u03b2 => (m\u2081 p.1, m\u2082 p.2)) '' s \u00d7\u02e2 t :=", "model_response": "lemma continuous_on_prod_same :\n\"continuous_on (s \\<times> t) f \\<longleftrightarrow> continuous_on s (\\<lambda>x. f (x,x)) \\<and> continuous_on t (\\<lambda>y. f (y,y))\""}
{"gold_output": "theorem eventualRange_mapsTo (f : j \u27f6 i) :\n(F.eventualRange j).MapsTo (F.map f) (F.eventualRange i) :=", "model_response": "theorem \u03b9_naturality (i j) : F.\u03b9 i \u226b F.f i j = F.f j i \u226b F.\u03b9 j :="}
{"gold_output": "theorem hasFDerivAtFilter_const (c : F) (x : E) (L : Filter E) :\nHasFDerivAtFilter (fun _ => c) (0 : E \u2192L[\ud835\udd5c] F) x L :=", "model_response": "lemma hasFDerivAtFilter_const [simp, derivative_intros]:\n\"((\\<lambda>_. c) hasFDerivAtFilter 0) x L\""}
{"gold_output": "theorem locallyConnectedSpace_iff_connected_subsets :\nLocallyConnectedSpace \u03b1 \u2194 \u2200 (x : \u03b1), \u2200 U \u2208 \ud835\udcdd x, \u2203 V \u2208 \ud835\udcdd x, IsPreconnected V \u2227 V \u2286 U :=", "model_response": "lemma Iic_subset_Iic_iff:\n\"{ a | a \\<le> x \\<and> P a } \\<subseteq> { a | a \\<le> y \\<and> P a } \\<longleftrightarrow>\n(\\<forall>a b. a \\<le> x \\<and> a \\<le> b \\<and> b \\<le> y \\<and> P a \\<longrightarrow> P b)\""}
{"gold_output": "theorem sSup_closed_unit_ball_eq_nnnorm {\ud835\udd5c \ud835\udd5c\u2082 E F : Type _} [NormedAddCommGroup E]\n[SeminormedAddCommGroup F] [DenselyNormedField \ud835\udd5c] [NontriviallyNormedField \ud835\udd5c\u2082] {\u03c3\u2081\u2082 : \ud835\udd5c \u2192+* \ud835\udd5c\u2082}\n[NormedSpace \ud835\udd5c E] [NormedSpace \ud835\udd5c\u2082 F] [RingHomIsometric \u03c3\u2081\u2082] (f : E \u2192SL[\u03c3\u2081\u2082] F) :\nsSup ((fun x => \u2016f x\u2016\u208a) '' closedBall 0 1) = \u2016f\u2016\u208a :=", "model_response": "lemma norm_blincomp_le:\nfixes f :: \"'a::normed_vector \\<Rightarrow>\\<^sub>L 'b::normed_vector\"\nand g :: \"'c::normed_vector \\<Rightarrow>\\<^sub>L 'a\"\nshows \"norm (f.comp g) \\<le> norm f * norm g\""}
{"gold_output": "theorem isLUB_csSup (ne : s.Nonempty) (H : BddAbove s) : IsLUB s (sSup s) :=", "model_response": "lemma isLUB_sSup: \"isLUB s (sSup s)\""}
{"gold_output": "theorem IsMaximal.mem_iff_models (h : T.IsMaximal) (\u03c6 : L.Sentence) : \u03c6 \u2208 T \u2194 T \u22a8\u1d47 \u03c6 :=", "model_response": "theorem infinite_models (T : L.Theory) : Infinite (T.Models) :="}
{"gold_output": "theorem measure_iUnion_eq_iSup [Countable \u03b9] {s : \u03b9 \u2192 Set \u03b1} (hd : Directed (\u00b7 \u2286 \u00b7) s) :\n\u03bc (\u22c3 i, s i) = \u2a06 i, \u03bc (s i) :=", "model_response": "lemma measure_iUnion_eq_iSup [simp]: \"measure M (\\<Union>i, s i) = (\u2a06 i, measure M (s i))\""}
{"gold_output": "theorem comp\u2082_eq_pair (g : \u03b2 \u2192 \u03b3 \u2192 \u03b4) (hg : Continuous (uncurry g)) (f\u2081 : \u03b1 \u2192\u2098[\u03bc] \u03b2)\n(f\u2082 : \u03b1 \u2192\u2098[\u03bc] \u03b3) : comp\u2082 g hg f\u2081 f\u2082 = comp _ hg (f\u2081.pair f\u2082) :=", "model_response": "lemma comp\u2082_eq_comp_pair: \"comp\u2082 g hg f\u2081 f\u2082 = comp g hg (pair f\u2081 f\u2082)\""}
{"gold_output": "theorem apply_piecewise\u2082 {\u03b4' \u03b4'' : \u03b1 \u2192 Sort _} (f' g' : \u2200 i, \u03b4' i) (h : \u2200 i, \u03b4 i \u2192 \u03b4' i \u2192 \u03b4'' i)\n{x : \u03b1} :\nh x (s.piecewise f g x) (s.piecewise f' g' x) =\ns.piecewise (fun x => h x (f x) (f' x)) (fun x => h x (g x) (g' x)) x :=", "model_response": "lemma continuousWithinAt_piecewise_iff:\n\"continuousWithinAt f s x \\<longleftrightarrow> continuousWithinAt (\\<lambda>x'. h x (f x') (f' x')) s x\""}
{"gold_output": "theorem to_nat_to_int (n : Num) : ((n : \u2115) : \u2124) = n :=", "model_response": "lemma of_int_to_int (k : \u2124) : of_int (to_int k) = k :="}
{"gold_output": "theorem mem_span_singleton_mul {x y : A} : x \u2208 span R {y} * P \u2194 \u2203 z \u2208 P, y * z = x :=", "model_response": "lemma Units_ring_end_iff_bijective :\n\"f \\<in> Units (Module.End R M) \\<longleftrightarrow> Function.bijective f\""}
{"gold_output": "theorem continuousOn_const_smul_iff\u2080 (hc : c \u2260 0) :\nContinuousOn (fun x => c \u2022 f x) s \u2194 ContinuousOn f s :=", "model_response": "lemma continuousOn_const_smul_iff\u2080 [simp]:\n\"continuousOn (\\<lambda>x. c \u2022 f x) s \\<longleftrightarrow> continuousOn f s\""}
{"gold_output": "theorem smul_comp [SMul R M] [ContinuousConstSMul R M] (r : R) (f : C(\u03b2, M)) (g : C(\u03b1, \u03b2)) :\n(r \u2022 f).comp g = r \u2022 f.comp g :=", "model_response": "lemma ofRealAm_comp_toRealAm: \"ofRealAm.comp toRealAm f = f\""}
{"gold_output": "theorem powerBasisAux'_repr_symm_apply (hg : g.Monic) (c : Fin g.natDegree \u2192\u2080 R) :\n(powerBasisAux' hg).repr.symm c = mk g (\u2211 i : Fin _, monomial i (c i)) :=", "model_response": "lemma powerBasisAux'_repr_symm_apply :\n\"(powerBasisAux' hg).repr.symm c = mk g (\u2211 i : Fin _, monomial i (c i))\""}
{"gold_output": "theorem nonZeroDivisors_le_comap_nonZeroDivisors_of_injective [NoZeroDivisors M']\n[MonoidWithZeroHomClass F M M'] (f : F) (hf : Function.Injective f) : M\u2070 \u2264 M'\u2070.comap f :=", "model_response": "theorem nonZeroDivisors_eq_comap_nonZeroDivisors:\n\"M\u2070 = S\u2070.comap f\""}
{"gold_output": "theorem toFin_le_toFin_of_le {n} {v\u2080 v\u2081 : Bitvec n} (h : v\u2080 \u2264 v\u2081) : v\u2080.toFin \u2264 v\u2081.toFin :=", "model_response": "lemma toFin_of_zero [simp]:\nshows \"toFin (0 : Bitvec n) = 0\""}
{"gold_output": "theorem finite_sUnion_mem_iff {s : Set (Set \u03b1)} (hs : s.Finite) : \u22c3\u2080 s \u2208 f \u2194 \u2203 t \u2208 s, t \u2208 f :=", "model_response": "lemma mk_finite_char_Union_mem_iff {s : Set (Set \u03b1)} (hs : s.Finite) :\n(\u22c3\u2080 (mk_finite_char '' s) \u2208 f \u2194 \u2203 t \u2208 s, mk_finite_char t \u2208 f) :="}
{"gold_output": "theorem _root_.IsCompact.exists_cthickening_subset_open (hs : IsCompact s) (ht : IsOpen t)\n(hst : s \u2286 t) :\n\u2203 \u03b4, 0 < \u03b4 \u2227 cthickening \u03b4 s \u2286 t :=", "model_response": "lemma sep_mem_eq_inter: \"{ x \\<in> s | x : t } = s \\<inter> t\""}
{"gold_output": "theorem toDualProd_apply (s : NonemptyInterval \u03b1) : s.toDualProd = (toDual s.fst, s.snd) :=", "model_response": "lemma toDual_bot: \"toDual bot = top\""}
{"gold_output": "theorem singleton_mul_singleton (a b : \u03b1) : ({a} : Finset \u03b1) * {b} = {a * b} :=", "model_response": "lemma singleton_mul_singleton : \"{a} * {b} = {a * b}\" :="}
{"gold_output": "theorem erase_le_iff_le_cons {s t : Multiset \u03b1} {a : \u03b1} : s.erase a \u2264 t \u2194 s \u2264 a ::\u2098 t :=", "model_response": "lemma multiset_le_cons_iff:\nassumes \"a \\<notin> s\"\nshows \"s \\<le> a ::\u2098 t \\<longleftrightarrow> s \\<le> t\""}
{"gold_output": "theorem stalkMap_germ {X Y : PresheafedSpace.{_, _, v} C} (\u03b1 : X \u27f6 Y) (U : Opens Y)\n(x : (Opens.map \u03b1.base).obj U) :\nY.presheaf.germ \u27e8\u03b1.base x.1, x.2\u27e9 \u226b stalkMap \u03b1 \u2191x = \u03b1.c.app (op U) \u226b X.presheaf.germ x :=", "model_response": "lemma pushout_inl_inr_eq_\u03b9 [simp]:\n\"pushout.inl.map (pushoutCoconeOfLeftInclusionMap \u03b1).\u03b9 \u226b (pushoutCoconeOfRightInclusionMap \u03b1).\u03c0 = \u03b1.\u03b9\""}
{"gold_output": "theorem closedEmbedding_subtype_val (h : IsClosed { a | p a }) :\nClosedEmbedding ((\u2191) : Subtype p \u2192 \u03b1) :=", "model_response": "lemma closed_map: \"closed_map f\""}
{"gold_output": "theorem left_lt_sup : a < a \u2294 b \u2194 \u00acb \u2264 a :=", "model_response": "lemma Iic_sup_eq: Iic (a \u2294 b) = Iic a \u2294 Iic b :="}
{"gold_output": "theorem mul_ne_mul_left {a b c : \u2115} (ha : 0 < a) : b * a \u2260 c * a \u2194 b \u2260 c :=", "model_response": "lemma of_nat_mul: \"of_nat (m * n) = of_nat m * of_nat n\""}
{"gold_output": "theorem coe_mulHom_mk (f : \u03b1 \u2192 \u03b2) (h\u2081 h\u2082 h\u2083) :\n((\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9 : \u03b1 \u2192\u2099+* \u03b2) : \u03b1 \u2192\u2099* \u03b2) = \u27e8f, h\u2081\u27e9 :=", "model_response": "lemma coe_mulHom_mk [simp]:\n\"(\u27e8\u27e8f, h\u2081\u27e9, h\u2082, h\u2083\u27e9 : \u03b1 \u2192\u2099+* \u03b2) = (\u27e8f, h\u2081\u27e9 : \u03b1 \u2192\u2099* \u03b2)\""}
{"gold_output": "theorem clog_of_left_le_one {b : \u2115} (hb : b \u2264 1) (r : R) : clog b r = 0 :=", "model_response": "lemma clog_zero_left (hb : b \u2264 1) : clog b 0 = 0 :="}
{"gold_output": "theorem erase_eq_of_not_mem {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : erase s a = s :=", "model_response": "lemma setOf_and {P Q : \u03b1 \u2192 Prop} : { x | P x \u2227 Q x } = { x | P x } \u2229 { x | Q x } :="}
{"gold_output": "theorem pos_eq_one : pos = 1 :=", "model_response": "lemma pos_eq_one_iff:\nassumes \"a \\<in> \\<real>\\<^sub>\\<ge>\\<^sub>0\"\nshows \"a = 1 \\<longleftrightarrow> 0 < a \\<and> a \\<le> 1\""}
{"gold_output": "theorem add_mul_right_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (y + z * x) :=", "model_response": "lemma toIcoMod_eq_iff : \"toIcoMod hp a b = toIcoMod hp a c \\<longleftrightarrow> b mod hp = c mod hp\""}
{"gold_output": "theorem \u03c9_pow_eq_one (p' : \u2115) (h : lucasLehmerResidue (p' + 2) = 0) :\n(\u03c9 : X (q (p' + 2))) ^ 2 ^ (p' + 2) = 1 :=", "model_response": "lemma of_mul [simp]: \"of (a * b) = of a * of b\""}
{"gold_output": "theorem sublist_replicate_iff {l : List \u03b1} {a : \u03b1} {n : \u2115} :\nl <+ replicate n a \u2194 \u2203 k \u2264 n, l = replicate k a :=", "model_response": "lemma sublist_replicate_right :\nshows \"sublist l (replicate n a) \\<longleftrightarrow> l \\<le> replicate n a\""}
{"gold_output": "theorem bounded_gt_Ioc [Preorder \u03b1] (a b : \u03b1) : Bounded (\u00b7 > \u00b7) (Ioc a b) :=", "model_response": "lemma bounded_le_univ [simp] : \"bounded (\u00b7 < \u00b7) (UNIV :: \u03b1 set)\""}
{"gold_output": "theorem coe_eq_one : (\u2191r : \u211d\u22650\u221e) = 1 \u2194 r = 1 :=", "model_response": "lemma toReal_coe_eq_self_iff : \"ENNReal.toReal (r : \u211d\u22650\u221e) = r \\<longleftrightarrow> 0 \\<le> r \\<and> r \\<le> 1\""}
{"gold_output": "theorem sum_centroidWeightsIndicator_eq_one_of_nonempty [CharZero k] [Fintype \u03b9] (h : s.Nonempty) :\n(\u2211 i, s.centroidWeightsIndicator k i) = 1 :=", "model_response": "lemma sum_centroidWeightsIndicator_eq_one [simp]:\n\"(\u2211 i, s.centroidWeightsIndicator k i) = 1\""}
{"gold_output": "theorem Commute.minimalPeriod_of_comp_dvd_lcm {g : \u03b1 \u2192 \u03b1} (h : Function.Commute f g) :\nminimalPeriod (f \u2218 g) x \u2223 Nat.lcm (minimalPeriod f x) (minimalPeriod g x) :=", "model_response": "lemma minimalPeriod_comp:\n\"minimalPeriod (f \\<circ> g) x = Nat.lcm (minimalPeriod f x) (minimalPeriod g x)\""}
{"gold_output": "theorem range_mono : Monotone range :=", "model_response": "theorem range_coe_connectedComponents :\nrange (mk :: \u03b1 \\<Rightarrow> ConnectedComponents \u03b1) = connectedComponents \u03b1 :="}
{"gold_output": "theorem degree_monomial_le (n : \u2115) (a : R) : degree (monomial n a) \u2264 n :=", "model_response": "lemma degree_monomial_mul_le: \"degree (monomial n a * p) \\<le> n + degree p\""}
{"gold_output": "theorem mapEquiv_refl : mapEquiv \u03c3 (RingEquiv.refl R) = RingEquiv.refl _ :=", "model_response": "lemma toFinsupp_injective : Function.Injective (toFinsupp : MvPolynomial \u03c3 R \u2192 \u03c3 \u2192\u2080 R) :="}
{"gold_output": "theorem Integrable.mul_const {f : \u03b1 \u2192 \ud835\udd5c} (h : Integrable f \u03bc) (c : \ud835\udd5c) :\nIntegrable (fun x => f x * c) \u03bc :=", "model_response": "lemma integral_zero [simp]: \"integral\\<^sup>L \u03bc (\\<lambda>x. 0) = 0\""}
{"gold_output": "theorem range_liftQ [RingHomSurjective \u03c4\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) (h) :\nrange (p.liftQ f h) = range f :=", "model_response": "lemma range_mkQ [simp]: \"range (mkQ f h) = range f\""}
{"gold_output": "theorem finSuccEquiv_X_zero : finSuccEquiv R n (X 0) = Polynomial.X :=", "model_response": "lemma card_finsum_lt_natfun : \"card {f::(nat \\<Rightarrow> nat). f < n} = n !\""}
{"gold_output": "theorem neg_imI : (-a).imI = -a.imI :=", "model_response": "lemma mul_imI : (-a).imI = a$1 * b$4 - a$4 * b$1 - a$2 * b$3 + a$3 * b$2 :="}
{"gold_output": "theorem nodup_powerset {s : Multiset \u03b1} : Nodup (powerset s) \u2194 Nodup s :=", "model_response": "lemma card_powerset [simp]: \"card (powerset s) = 2 ^ card s\""}
{"gold_output": "theorem pointwise_smul_le_pointwise_smul_iff {a : M} {S T : Subring R} : a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T :=", "model_response": "lemma pointwise_smul_le_pointwise_smul_iff [simp]: \"a \u2022 S \u2264 a \u2022 T \u2194 S \u2264 T\""}
{"gold_output": "theorem of_isLimit' (w : CommSq fst snd f g) (h : Limits.IsLimit w.cone) :\nIsPullback fst snd f g :=", "model_response": "lemma pullback_cone_is_limit_comp [simp]:\n\"cone.fst (pullback_cone fst snd f g) \u226b cone.snd (pullback_cone fst snd f g) = \ud835\udfd9 _\""}
{"gold_output": "theorem not_dvd_geom_sum\u2082 {p : R} (hp : Prime p) (hxy : p \u2223 x - y) (hx : \u00acp \u2223 x) (hn : \u00acp \u2223 n) :\n\u00acp \u2223 \u2211 i in range n, x ^ i * y ^ (n - 1 - i) :=", "model_response": "lemma toIcoMod_eq_self_iff: \"toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)\""}
{"gold_output": "theorem sub_one_ne_zero : p - 1 \u2260 0 :=", "model_response": "lemma toNat_one: \"toNat 1 = (1::nat)\""}
{"gold_output": "theorem comp {g : B \u2192\u2090[R] C} {f : A \u2192\u2090[R] B} (hg : g.Finite) (hf : f.Finite) : (g.comp f).Finite :=", "model_response": "lemma of_comp_toAlgHom: \"of R \u2218 toAlgHom R f = f\""}
{"gold_output": "theorem adjointAux_norm (A : E \u2192L[\ud835\udd5c] F) : \u2016adjointAux A\u2016 = \u2016A\u2016 :=", "model_response": "lemma norm_adjointAux[simp]: \\<open>norm (adjointAux A) = norm A\\<close>"}
{"gold_output": "theorem heq_of_eq_rec_left {\u03c6 : \u03b1 \u2192 Sort v} {a a' : \u03b1} {p\u2081 : \u03c6 a} {p\u2082 : \u03c6 a'} :\n(e : a = a') \u2192 (h\u2082 : Eq.rec (motive := fun a _ \u21a6 \u03c6 a) p\u2081 e = p\u2082) \u2192 HEq p\u2081 p\u2082", "model_response": "lemma heq_of_eq_rec_left:\nassumes \"a = a'\" and h\u2082: \"Eq.rec (motive := fun a _ \u21a6 \u03c6 a) p\u2081 e = p\u2082\"\nshows \"p\u2081 =\\<^sub>d p\u2082\""}
{"gold_output": "theorem exists_Icc_mem_subset_of_mem_nhdsWithin_Iic {a : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd[\u2264] a) :\n\u2203 b \u2264 a, Icc b a \u2208 \ud835\udcdd[\u2264] a \u2227 Icc b a \u2286 s :=", "model_response": "lemma toIcoMod_eq_self_iff: \"toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)\""}
{"gold_output": "theorem adjugate_transpose (A : Matrix n n \u03b1) : (adjugate A)\u1d40 = adjugate A\u1d40 :=", "model_response": "lemma adjugate_def': \"adjugate A = det A \u2022 LinearMap.inv (funL R R v) (funL R R fun v => adjugate A *v v)\""}
{"gold_output": "theorem factorThru_add {X Y : C} {P : Subobject Y} (f g : X \u27f6 Y) (w : P.Factors (f + g))\n(wf : P.Factors f) (wg : P.Factors g) :\nP.factorThru (f + g) w = P.factorThru f wf + P.factorThru g wg :=", "model_response": "lemma factorThru_add_comp_left {X Y : C} {P : Subobject Y} (f g : X \u27f6 Y) (w : P.Factors (f + g))\n(wf : P.Factors f) (wg : P.Factors g) :\nP.factorThru (f + g) w \u226b P.factorThru f wf = P.factorThru g wg :="}
{"gold_output": "theorem det_toBlock (M : Matrix m m R) (p : m \u2192 Prop) [DecidablePred p] :\nM.det =\n(fromBlocks (toBlock M p p) (toBlock M p fun j => \u00acp j) (toBlock M (fun j => \u00acp j) p) <|\ntoBlock M (fun j => \u00acp j) fun j => \u00acp j).det :=", "model_response": "lemma det_altdef: \"det A = \u2211 \u03c3 : Perm n. signOf \u03c3 * \u220f i, A (\u03c3 i) (\u03c3 i)\""}
{"gold_output": "theorem natDegree_bit0 (a : R[X]) : (bit0 a).natDegree \u2264 a.natDegree :=", "model_response": "lemma natDegree_bit0_le : (bit0 a).natDegree \u2264 a.natDegree :="}
{"gold_output": "theorem BinaryBicone.fstKernelFork_\u03b9 : (BinaryBicone.fstKernelFork c).\u03b9 = c.inr :=", "model_response": "lemma BinaryBicone.fstKernelFork_\u03b9_kernelFork_\u03b9_eq :\nBinaryBicone.fstKernelFork c \u226b kernelForkMorphism c = kernelForkMorphism c :="}
{"gold_output": "theorem isOpenMap_of_finiteDimensional (f : F \u2192\u2097[\ud835\udd5c] E) (hf : Function.Surjective f) :\nIsOpenMap f :=", "model_response": "lemma open_map: \"IsOpenMap f\""}
{"gold_output": "theorem CompositionAsSet.toComposition_boundaries (c : CompositionAsSet n) :\nc.toComposition.boundaries = c.boundaries :=", "model_response": "lemma inv_comp_self: \"c.inv \u2218' c = Composition.id c.size\""}
{"gold_output": "theorem countp_eq_length_filter (l) : countp p l = length (filter p l) :=", "model_response": "lemma set_filter_eq : \"{x \\<in> l. p x} = Set.filter p l\""}
{"gold_output": "theorem continuousSMul_of_algebraMap (h : Continuous (algebraMap R A)) : ContinuousSMul R A :=", "model_response": "theorem uniformEmbedding_coe [simp, uniform_embedding]: \"UniformEmbedding ((\u2191) : \u03b1 \u2192 Completion \u03b1)\""}
{"gold_output": "theorem rename_monomial (f : \u03c3 \u2192 \u03c4) (d : \u03c3 \u2192\u2080 \u2115) (r : R) :\nrename f (monomial d r) = monomial (d.mapDomain f) r :=", "model_response": "lemma continuousAt_iff_tendsto_zero:\n\"continuousAt f x \\<longleftrightarrow> ((\\<lambda>y. f (x + y)) \\<longlongrightarrow> f x) (\ud835\udcdd 0)\""}
{"gold_output": "theorem UpperSemicontinuousWithinAt.mono (h : UpperSemicontinuousWithinAt f s x) (hst : t \u2286 s) :\nUpperSemicontinuousWithinAt f t x :=", "model_response": "lemma continuousWithinAt_iff_upperSemicontinuousWithinAt:\n\"ContinuousWithinAt f s x \\<longleftrightarrow> UpperSemicontinuousWithinAt f s x\""}
{"gold_output": "theorem Nodup.pairwise : (\u2200 a \u2208 s, \u2200 b \u2208 s, a \u2260 b \u2192 r a b) \u2192 Nodup s \u2192 Pairwise r s :=", "model_response": "lemma pairwise_imp_perm:\nassumes \"finite s\"\nassumes \"equiv s r\"\nshows \"(\\<And>a b. a \\<in> s \\<Longrightarrow> b \\<in> s \\<Longrightarrow> a \\<noteq> b \\<Longrightarrow> r a b) \\<Longrightarrow> pairwise r s\""}
{"gold_output": "theorem inv_le_inv_iff : f\u207b\u00b9 \u2264 g\u207b\u00b9 \u2194 f \u2264 g :=", "model_response": "lemma inv_le_inv_iff [simp]: \"f\u207b\u00b9 \u2264 g\u207b\u00b9 \u2194 f \u2264 g\""}
{"gold_output": "theorem centralizer_top : centralizer \u22a4 = center G :=", "model_response": "theorem centralizer_univ : centralizer Set.univ = center G :="}
{"gold_output": "theorem one_def [One \u03b2] : (1 : \u03b1 \u2192\u2098[\u03bc] \u03b2) = mk (fun _ : \u03b1 => 1) aestronglyMeasurable_const :=", "model_response": "lemma one_ae_eq_one' [simp]: \"(\\<lambda>_::'a. (1::'b)) =\u1d50[\u03bc] (mk (\\<lambda>_. 1) aestronglyMeasurable_const)\""}
{"gold_output": "theorem eq' {a b : \u03b1} : (mk a : \u03b1 \u29f8 s) = mk b \u2194 a\u207b\u00b9 * b \u2208 s :=", "model_response": "lemma mk_surj:\n\"Function.Surjective mk\""}
{"gold_output": "theorem apply_inv_self (e : r \u2243r r) (x) : e (e\u207b\u00b9 x) = x :=", "model_response": "lemma inv_inv [simp]:\n\"inv (inv x) = x\""}
{"gold_output": "theorem sin_pi_sub (x : \u2102) : sin (\u03c0 - x) = sin x :=", "model_response": "lemma sin_pi_sub [simp]: \"sin (\u03c0 - x) = sin x\""}
{"gold_output": "theorem fold_max_lt : s.fold max b f < c \u2194 b < c \u2227 \u2200 x \u2208 s, f x < c :=", "model_response": "lemma fold_max_le : (s.fold max b f \\<le> c) = (b \\<le> c \\<and> (\\<forall>x\\<in>s. f x \\<le> c)) :="}
{"gold_output": "theorem cliqueFinset_mono (h : G \u2264 H) : G.cliqueFinset n \u2286 H.cliqueFinset n :=", "model_response": "lemma cliqueFinset_mono : \"G.cliqueFinset n \\<subseteq> H.cliqueFinset n\""}
{"gold_output": "theorem IsAddSubgroup.of_sub (s : Set A) (zero_mem : (0 : A) \u2208 s)\n(sub_mem : \u2200 {a b : A}, a \u2208 s \u2192 b \u2208 s \u2192 a - b \u2208 s) : IsAddSubgroup s :=", "model_response": "lemma AddSubgroup.subtype {P : A \u2192 Prop} : IsAddSubgroup { x : A | P x } :="}
{"gold_output": "theorem sup_sdiff_distrib (a b c : \u03b1) : (a \u2294 b) \\ c = a \\ c \u2294 b \\ c :=", "model_response": "lemma sSup_pair {a b : \u03b1} : sSup {a, b} = a \u2294 b :="}
{"gold_output": "theorem ceil_mono : Monotone (ceil : \u03b1 \u2192 \u2124) :=", "model_response": "lemma mono_ceil : Monotone (ceil : \u03b1 \u2192 \u2124) :="}
{"gold_output": "theorem countable_insert {s : Set \u03b1} {a : \u03b1} : (insert a s).Countable \u2194 s.Countable :=", "model_response": "lemma countable_insert [simp]: \"countable (insert (a :: \u03b1) s) = countable s\""}
{"gold_output": "theorem zero_apply (a : A) : (0 : Derivation R A M) a = 0 :=", "model_response": "lemma neg_apply (a : A) : (-f) a = -f a :="}
{"gold_output": "theorem ne_zero_of_mul_eq_one (I J : FractionalIdeal R\u2081\u2070 K) (h : I * J = 1) : I \u2260 0 :=", "model_response": "lemma coe_mul_eq_one_iff:\n\"I * J = 1 \u2194 (I : Submodule R\u2081 K) * (J : Submodule R\u2081 K) = 1\""}
{"gold_output": "theorem mono_of_cancel_zero {X Y : C} (f : X \u27f6 Y)\n(hf : \u2200 (Z : C) (g : Z \u27f6 X) (_ : g \u226b f = 0), g = 0) : Mono f :=", "model_response": "lemma mono_iff_kernel_\u03b9_eq_zero:\nshows \"mono f \\<longleftrightarrow> kernel.\u03b9 f = 0\""}
{"gold_output": "theorem inner_single_right (i : \u03b9) (a : G i) (f : lp G 2) : \u27eaf, lp.single 2 i a\u27eb = \u27eaf i, a\u27eb :=", "model_response": "lemma inner_single_right (i : \u03b9) (a : G i) (f : lp G 2) : \u27eaf, lp.single 2 i a\u27eb = \u27eaf i, a\u27eb :="}
{"gold_output": "theorem ker_le_range_iff {f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082} {g : M\u2082 \u2192\u209b\u2097[\u03c4\u2082\u2083] M\u2083} :\nker g \u2264 range f \u2194 f.range.mkQ.comp g.ker.subtype = 0 :=", "model_response": "lemma range_ker_comp_eq_zero [simp]:\n\"(range f).mkQ.comp g.ker.subtype = 0\""}
{"gold_output": "theorem nadd_le_nadd_left (h : b \u2264 c) (a) : a \u266f b \u2264 a \u266f c :=", "model_response": "lemma nadd_assoc:\nshows \"a \u266f b \u266f c = a \u266f (b \u266f c)\""}
{"gold_output": "theorem gcd_mul_left' [GCDMonoid \u03b1] (a b c : \u03b1) :\nAssociated (gcd (a * b) (a * c)) (a * gcd b c) :=", "model_response": "lemma gcd_mul_left [simp]: \"gcd (a * b) (a * c) = normalize a * gcd b c\""}
{"gold_output": "theorem coe_addMonoidHom_injective : Injective fun f : \u03b1 \u2192\u2099+* \u03b2 => (f : \u03b1 \u2192+ \u03b2) :=", "model_response": "lemma toAddMonoidHom_injective : Injective (toAddMonoidHom : (\u03b1 \u2192\u2099+* \u03b2) \u2192 \u03b1 \u2192+ \u03b2) :="}
{"gold_output": "theorem infs_sups_subset_right : (t \u22bb u) \u22bc s \u2286 t \u22bc s \u22bb u \u22bc s :=", "model_response": "lemma infs_sups_subset_right : (t \u22bb u) \u22bc s \u2286 t \u22bc s \u22bb u \u22bc s :="}
{"gold_output": "theorem DifferentiableAt.neg (h : DifferentiableAt \ud835\udd5c f x) : DifferentiableAt \ud835\udd5c (fun y => -f y) x :=", "model_response": "lemma differentiableAt_neg_iff [simp]:\n\"DifferentiableAt \ud835\udd5c (\\<lambda>x. -f x) x \\<longleftrightarrow> DifferentiableAt \ud835\udd5c f x\""}
{"gold_output": "theorem lowerClosure_mono : Monotone (lowerClosure : Set \u03b1 \u2192 LowerSet \u03b1) :=", "model_response": "lemma lowerClosure_union [simp]: \"lowerClosure (s \\<union> t) = lowerClosure s \\<union> lowerClosure t\""}
{"gold_output": "theorem lift_\u03b9_apply (x : L) : lift R f (\u03b9 R x) = f x :=", "model_response": "lemma lift_injective: \"Function.Injective (lift R f)\""}
{"gold_output": "theorem Chain.sublist [IsTrans \u03b1 R] (hl : l\u2082.Chain R a) (h : l\u2081 <+ l\u2082) :\nl\u2081.Chain R a :=", "model_response": "lemma chain_append_same :\nassumes \"chain R l\\<^sub>1 a\"\nand     \"chain R l\\<^sub>2 a\"\nshows \"chain R (l\\<^sub>1 @ l\\<^sub>2) a\""}
{"gold_output": "theorem single_eq_of_ne (h : a \u2260 a') : (single a b : \u03b1 \u2192\u2080 M) a' = 0 :=", "model_response": "lemma support_single :\n\"support (single a b) = (if b = 0 then {} else {a})\""}
{"gold_output": "theorem Subpresheaf.to_sheafifyLift (f : G.toPresheaf \u27f6 F') (h : Presieve.IsSheaf J F') :\nSubpresheaf.homOfLe (G.le_sheafify J) \u226b G.sheafifyLift f h = f :=", "model_response": "lemma sheafifyLift_spec (f : G.toPresheaf \u27f6 F') (h : Presieve.IsSheaf J F') :\nSubpresheaf.homOfLe (G.le_sheafify J) \u226b G.sheafifyLift f h = f :="}
{"gold_output": "theorem exists_inv_nat_lt {a : \u211d\u22650\u221e} (h : a \u2260 0) : \u2203 n : \u2115, (n : \u211d\u22650\u221e)\u207b\u00b9 < a :=", "model_response": "lemma inv_of_nat :\n\"(of_nat n : \u211d\u22650\u221e)\u207b\u00b9 = of_nat n\u207b\u00b9\""}
{"gold_output": "theorem degree_multiset_prod_le : t.prod.degree \u2264 (t.map Polynomial.degree).sum :=", "model_response": "lemma degree_multiset_prod_eq_sum_degrees :\n\"degree (t.prod :: _ :: comm_monoid_add_poly) = (t.map Polynomial.degree).sum\""}
{"gold_output": "theorem IntegrableAtFilter.eventually (h : IntegrableAtFilter f l \u03bc) :\n\u2200\u1da0 s in l.smallSets, IntegrableOn f s \u03bc :=", "model_response": "lemma integrableOn_univ_iff_integrableAtFilter:\n\"IntegrableOn f univ \u03bc \u2194 IntegrableAtFilter f l \u03bc\""}
{"gold_output": "theorem modEq_zero : a \u2261 b [PMOD 0] \u2194 a = b :=", "model_response": "lemma toIcoMod_commute: \"toIcoMod hp a b = toIcoMod hp b a\""}
{"gold_output": "theorem Antitone.map_ciInf_of_continuousAt {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b1} (Cf : ContinuousAt f (\u2a05 i, g i))\n(Af : Antitone f) (H : BddBelow (range g)) : f (\u2a05 i, g i) = \u2a06 i, f (g i) :=", "model_response": "lemma continuous_at_iInf_range_iff_compose:\n\"continuous (at (\u2a05 i, g i)) f \\<longleftrightarrow> continuous (at (SUP i, g i)) (f \\<circ> g)\""}
{"gold_output": "theorem IsPicardLindelof.exists_forall_hasDerivWithinAt_Icc_eq [CompleteSpace E] {v : \u211d \u2192 E \u2192 E}\n{tMin t\u2080 tMax : \u211d} (x\u2080 : E) {C R : \u211d} {L : \u211d\u22650}\n(hpl : IsPicardLindelof v tMin t\u2080 tMax x\u2080 L R C) :\n\u2203 f : \u211d \u2192 E, f t\u2080 = x\u2080 \u2227\n\u2200 t \u2208 Icc tMin tMax, HasDerivWithinAt f (v t (f t)) (Icc tMin tMax) t :=", "model_response": "lemma continuous_on_Icc [simp]: \"continuous_on (Icc tMin tMax) f\""}
{"gold_output": "theorem nat_casesOn {f : \u03b1 \u2192 \u2115} {g : \u03b1 \u2192 \u03c3} {h : \u03b1 \u2192 \u2115 \u2192 \u03c3} (hf : Computable f) (hg : Computable g)\n(hh : Computable\u2082 h) :\nComputable fun a => Nat.casesOn (motive := fun _ => \u03c3) (f a) (g a) (h a) :=", "model_response": "theorem part_iff_total: \"Partrec f \\<longleftrightarrow> (\\<exists>g. (\\<forall>n. g n = f n) \\<and> Total g)\""}
{"gold_output": "theorem iterate_toEndomorphism_mem_lowerCentralSeries (x : L) (m : M) (k : \u2115) :\n(toEndomorphism R L M x^[k]) m \u2208 lowerCentralSeries R L M k :=", "model_response": "lemma toEndomorphism_lie_mem_lowerCentralSeries (x : L) (m : M) (k : \u2115) :\n\u2045x, m\u2046 \u2208 lowerCentralSeries R L M k :="}
{"gold_output": "theorem sInf_le {A : C} (s : Set (Subobject A)) (f) (hf : f \u2208 s) : sInf s \u2264 f :=", "model_response": "lemma sInf_arrow_comp_inf_arrow: \"(sInf s).arrow \u226b (inf_arrow s f hf).arrow = f.arrow\""}
{"gold_output": "theorem unbot'_eq_unbot'_iff {d : \u03b1} {x y : WithBot \u03b1} :\nunbot' d x = unbot' d y \u2194 x = y \u2228 x = d \u2227 y = \u22a5 \u2228 x = \u22a5 \u2227 y = d :=", "model_response": "lemma unbot'_eq_self_iff: \"unbot' d x = d \u2194 x = d \u2228 x = \u22a5\""}
{"gold_output": "theorem isClopen_biInter_finset {\u03b2 : Type _} {s : Finset \u03b2} {f : \u03b2 \u2192 Set \u03b1}\n(h : \u2200 i \u2208 s, IsClopen (f i)) : IsClopen (\u22c2 i \u2208 s, f i) :=", "model_response": "lemma isClopen_bicond {s t : Set \u03b1} (h : s \u2286 t) : IsClopen { x | x \u2208 s \u2194 x \u2208 t } :="}
{"gold_output": "theorem Mem\u2112p.integrable {q : \u211d\u22650\u221e} (hq1 : 1 \u2264 q) {f : \u03b1 \u2192 \u03b2} [IsFiniteMeasure \u03bc]\n(hfq : Mem\u2112p f q \u03bc) : Integrable f \u03bc :=", "model_response": "lemma Mem\u2112p.integrable_norm_rpow {q : \u211d\u22650\u221e} (hq1 : 1 \u2264 q) {f : \u03b1 \u2192 E} (hfq : Mem\u2112p f q \u03bc) :\nIntegrable (fun x => \u2016f x\u2016 ^ p.toReal) \u03bc :="}
{"gold_output": "theorem surjective (e : \u03b1 \u2243o \u03b2) : Function.Surjective e :=", "model_response": "lemma surjective:\n\"surj e\""}
{"gold_output": "theorem card_bind : card (s.bind f) = (s.map (card \u2218 f)).sum :=", "model_response": "lemma card_funcset_fin : \"card (Set.Fin n \\<rightarrow> \u03b1) = card \u03b1 ^ n\""}
{"gold_output": "theorem adjMatrix_mulVec_const_apply [Semiring \u03b1] {a : \u03b1} {v : V} :\n(G.adjMatrix \u03b1).mulVec (Function.const _ a) v = G.degree v * a :=", "model_response": "lemma adjMatrix_eq_adjMatrix_const: \"G.adjMatrix = G.adjMatrix fun e a => a\""}
{"gold_output": "theorem mapRange.linearMap_apply (f : M \u2192\u2097[R] N) (g : \u03b1 \u2192\u2080 M) :\nmapRange.linearMap f g = mapRange f f.map_zero g :=", "model_response": "lemma injOn_mapRange_linearMap_iff [simp]:\n\"injOn f (keys g) \\<longleftrightarrow> injOn (mapRange.linearMap f) g\""}
{"gold_output": "theorem range_eq {\u03b1 \u03b2} (f : Option \u03b1 \u2192 \u03b2) : range f = insert (f none) (range (f \u2218 some)) :=", "model_response": "lemma range_some_comp [simp]: \"range (f \\<circ> some) = range f\""}
{"gold_output": "theorem natDegree_basisDivisor_of_ne (hxy : x \u2260 y) : (basisDivisor x y).natDegree = 1 :=", "model_response": "lemma natDegree_basisDivisor [simp]: \"natDegree (basisDivisor x y) = 1\""}
{"gold_output": "theorem bit1_div_bit0 : bit1 n / bit0 m = n / m :=", "model_response": "lemma div_bit0_bit1 : bit1 n / bit0 m = n / m :="}
{"gold_output": "theorem IsLocalMinOn.congr {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : IsLocalMinOn f s a)\n(heq : f =\u1da0[\ud835\udcdd[s] a] g) (hmem : a \u2208 s) : IsLocalMinOn g s a :=", "model_response": "lemma isLocalMinOn_congr:\n\"IsLocalMinOn f s a \\<longleftrightarrow> IsLocalMinOn g s a\" if \"eventually (\\<lambda>x. f x = g x) (\ud835\udcdd[s] a)\" \"a \\<in> s\""}
{"gold_output": "theorem sin_two_pi : sin (2 * \u03c0) = 0 :=", "model_response": "lemma sin_pi_div_two [simp]: \"sin (\u03c0 / 2) = 1\""}
{"gold_output": "theorem preimage_nhds_within_coinduced {\u03c0 : \u03b1 \u2192 \u03b2} {s : Set \u03b2} {t : Set \u03b1} {a : \u03b1} (h : a \u2208 t)\n(ht : IsOpen t)\n(hs : s \u2208 @nhds \u03b2 (.coinduced (fun x : t => \u03c0 x) inferInstance) (\u03c0 a)) :\n\u03c0 \u207b\u00b9' s \u2208 \ud835\udcdd a :=", "model_response": "lemma preimage_Iic_coinduced {b : \u03b2} :\n\u03c0 \u207b\u00b9' {.. b} = @Iic (TopologicalSpace.induced (fun x : t => \u03c0 x) inferInstance) b :="}
{"gold_output": "theorem lift_comp_coe : ZMod.lift n f \u2218 ((\u2191) : \u2124 \u2192 _) = f :=", "model_response": "lemma lift_comp_coe : \"ZMod.lift n f \u2218 ((\u2191) : \u2124 \u2192 _) = f\""}
{"gold_output": "theorem image_coe_nnreal_ennreal (h : t.OrdConnected) : ((\u2191) '' t : Set \u211d\u22650\u221e).OrdConnected :=", "model_response": "lemma ord_connected_Ici [simp]: \"OrdConnected (Ici a)\""}
{"gold_output": "theorem snorm'_neg {f : \u03b1 \u2192 F} : snorm' (-f) q \u03bc = snorm' f q \u03bc :=", "model_response": "lemma snorm'_neg [simp]: \"snorm' (-f) q \\<mu> = snorm' f q \\<mu>\""}
{"gold_output": "theorem mk_Ioo_real {a b : \u211d} (h : a < b) : (#Ioo a b) = \ud835\udd20 :=", "model_response": "lemma mk_Ioo_real: \"mk (Ioo a b) = \ud835\udd20\" {a b : \u211d} (h : a < b)"}
{"gold_output": "theorem inv_pow_sub\u2080 (ha : a \u2260 0) (h : n \u2264 m) : a\u207b\u00b9 ^ (m - n) = (a ^ m)\u207b\u00b9 * a ^ n :=", "model_response": "lemma inv_pow_eq_iff_eq_or_eq (ha : a \u2260 0) : a\u207b\u00b9 ^ m = a\u207b\u00b9 ^ n \u2194 a = 1 \u2228 m = n :="}
{"gold_output": "theorem whiskerRight_id' {G : C \u2964 D} (F : D \u2964 E) : whiskerRight (\ud835\udfd9 G) F = \ud835\udfd9 (G.comp F) :=", "model_response": "lemma whiskerRight_id_comp_map:\n\"(\ud835\udfd9 G \u25eb subcategory.map F).comp = \ud835\udfd9 (G \u22d9 subcategory.map F)\""}
{"gold_output": "theorem Even.zpow_nonneg (hn : Even n) (a : \u03b1) : 0 \u2264 a ^ n :=", "model_response": "lemma zpow_eq_pow (hn : Even n) (a : \u03b1) : a ^ n = a ^ n :="}
{"gold_output": "theorem image_subgroup {f : G \u2192 H} (hf : IsGroupHom f) {s : Set G} (hs : IsSubgroup s) :\nIsSubgroup (f '' s) :=", "model_response": "lemma image_closure [simp]:\n\"f ` (closure s) = closure (f ` s)\""}
{"gold_output": "theorem map_U (f : R \u2192+* S) : \u2200 n : \u2115, map f (U R n) = U S n", "model_response": "lemma antiperiodic_iff_periodic:\nfixes f :: \"'a::real_normed_vector \\<Rightarrow> 'b::real_normed_vector\"\nshows \"antiperiodic c f \\<longleftrightarrow> periodic (-c) f\""}
{"gold_output": "theorem num_algebraMap (p : K[X]) : num (algebraMap _ _ p) = p :=", "model_response": "lemma num_algebraMap (p : K[X]) : num (algebraMap _ _ p) = p :="}
{"gold_output": "theorem rotateL_nil (l : Ordnode \u03b1) (x : \u03b1) : rotateL l x nil = node' l x nil :=", "model_response": "lemma rotateL_of_list [simp]:\nassumes \"xs \\<noteq> []\"\nshows \"rotateL (of_list xs) = node (xs ! 0) (of_list (tl xs))\""}
{"gold_output": "theorem MonoidWithZeroHom.comp_id [MulZeroOneClass M] [MulZeroOneClass N] (f : M \u2192*\u2080 N) :\nf.comp (MonoidWithZeroHom.id M) = f :=", "model_response": "lemma MonoidWithZeroHom_id_comp [simp]:\n\"(MonoidWithZeroHom.id N).comp f = f\""}
{"gold_output": "theorem algHom_ext {A} [CommSemiring R] [Semiring A] [Algebra R A] \u2983f g : R[\u03b5] \u2192\u2090[R] A\u2984\n(h : f \u03b5 = g \u03b5) : f = g :=", "model_response": "lemma ofRealClm_apply[simp]: \"ofRealClm = ofReal\""}
{"gold_output": "theorem odd_pow {n : \u2115} : Odd (m ^ n) \u2194 Odd m \u2228 n = 0 :=", "model_response": "theorem of_nat_find : of_nat (Nat.find P) = Nat.find P :="}
{"gold_output": "theorem coe_ennreal_pow (x : \u211d\u22650\u221e) (n : \u2115) : (\u2191(x ^ n) : EReal) = (x : EReal) ^ n :=", "model_response": "lemma continuousAt_toReal: \"continuousAt toReal x\""}
{"gold_output": "theorem blimsup_or_eq_sup : (blimsup u f fun x => p x \u2228 q x) = blimsup u f p \u2294 blimsup u f q :=", "model_response": "lemma blimsup_or_eq_union: \"{ x | x. p x \\<or> q x } = { x | x. p x } \\<union> { x | x. q x }\""}
{"gold_output": "theorem continuous_skewAdjointPart [ContinuousSub A] [ContinuousStar A] [ContinuousConstSMul R A] :\nContinuous (@skewAdjointPart R A _ _ _ _ _ _ _ _) :=", "model_response": "lemma skewAdjointPart_clinear [simp]:\n\"Continuous (skewAdjointPart : (M \\<rightarrow>\\<^sub>C L) \\<Rightarrow> M \\<rightarrow>\\<^sub>C L)\""}
{"gold_output": "theorem weightedVSubOfPoint_erase [DecidableEq \u03b9] (w : \u03b9 \u2192 k) (p : \u03b9 \u2192 P) (i : \u03b9) :\n(s.erase i).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w :=", "model_response": "lemma weightedVSubOfPoint_erase [simp]:\n\"(s.erase i).weightedVSubOfPoint p (p i) w = s.weightedVSubOfPoint p (p i) w - w i \\<bullet>\u1d65 p i\""}
{"gold_output": "theorem sq_add_sq_ne_zero {R : Type _} [LinearOrderedCommRing R] {a b : R} (h : IsCoprime a b) :\na ^ 2 + b ^ 2 \u2260 0 :=", "model_response": "lemma normSq_eq_re_self_mul_cnj [simp]: \"normSq a = re (a * cnj a)\""}
{"gold_output": "theorem lhom_ext \u2983\u03c6 \u03c8 : (\u03a0\u2080 i, M i) \u2192\u2097[R] N\u2984 (h : \u2200 i x, \u03c6 (single i x) = \u03c8 (single i x)) : \u03c6 = \u03c8 :=", "model_response": "lemma toModule_inj_iff: \"inj f \u2194 inj (toModule R \u03c6 f)\""}
{"gold_output": "theorem \u03c0_map (p q : ActionCategory M X) (f : p \u27f6 q) : (\u03c0 M X).map f = f.val :=", "model_response": "theorem id_comp: \"F o (id C) = F\""}
{"gold_output": "theorem cauchySeq_iff_tendsto_dist_atTop_0 [Nonempty \u03b2] [SemilatticeSup \u03b2] {u : \u03b2 \u2192 \u03b1} :\nCauchySeq u \u2194 Tendsto (fun n : \u03b2 \u00d7 \u03b2 => dist (u n.1) (u n.2)) atTop (\ud835\udcdd 0) :=", "model_response": "lemma uniformContinuous_of_real: \"uniformContinuous of_real\""}
{"gold_output": "theorem adjoin_adjoin_comm (T : Set E) :\n(adjoin (adjoin F S) T).restrictScalars F = (adjoin (adjoin F T) S).restrictScalars F :=", "model_response": "lemma adjoin_eq_integral_set_eq_integral_set:\n\"{ x \\<in> E. Algebra.integral F x } = { x \\<in> E. integral F x }\""}
{"gold_output": "theorem sInf_mem_closure {\u03b1 : Type u} [TopologicalSpace \u03b1] [CompleteLinearOrder \u03b1] [OrderTopology \u03b1]\n{s : Set \u03b1} (hs : s.Nonempty) : sInf s \u2208 closure s :=", "model_response": "lemma closed_Iic [continuous_intros, simp]: \"closed (Iic a)\""}
{"gold_output": "theorem map_le_of_le_comap {T : L.Substructure N} {f : M \u2192[L] N} : S \u2264 T.comap f \u2192 S.map f \u2264 T :=", "model_response": "lemma map_inf_range_eq_inf_comap: \"S \u2293 range f \\<le> T \\<Longrightarrow> S.map f \u2293 range f = S.map f \u2293 T.comap f\""}
{"gold_output": "theorem inv_inv_of_invertible [Invertible A] : A\u207b\u00b9\u207b\u00b9 = A :=", "model_response": "lemma inv_inv [simp]: \"A\u207b\u00b9\u207b\u00b9 = A\""}
{"gold_output": "theorem IsCoseparator.def {G : C} :\nIsCoseparator G \u2192 \u2200 \u2983X Y : C\u2984 (f g : X \u27f6 Y), (\u2200 h : Y \u27f6 G, f \u226b h = g \u226b h) \u2192 f = g :=", "model_response": "lemma coev_ev_hom (A : C) : coev A \u226b ev A = \ud835\udfd9 (A \u27f6 A) :="}
{"gold_output": "theorem exists_fixed_point_of_prime' {p n : \u2115} [hp : Fact p.Prime] (h\u03b1 : p \u2223 Fintype.card \u03b1)\n{\u03c3 : Perm \u03b1} (h\u03c3 : \u03c3 ^ p ^ n = 1) {a : \u03b1} (ha : \u03c3 a = a) : \u2203 b : \u03b1, \u03c3 b = b \u2227 b \u2260 a :=", "model_response": "theorem card_perms_of_fintype [Fintype \u03b1] :\nFintype.card (Perm \u03b1) = Nat.factorial (Fintype.card \u03b1) :="}
{"gold_output": "theorem C_mul_X_eq_monomial {s : \u03c3} {a : R} : C a * X s = monomial (Finsupp.single s 1) a :=", "model_response": "lemma toFinsupp_inj:\n\"toFinsupp x = toFinsupp y \\<longleftrightarrow> x = y\""}
{"gold_output": "theorem map_add : \u2200 x y, e (x + y) = e x + e y :=", "model_response": "lemma injective: \"inj e\""}
{"gold_output": "theorem subperm_append_diff_self_of_count_le {l\u2081 l\u2082 : List \u03b1}\n(h : \u2200 x \u2208 l\u2081, count x l\u2081 \u2264 count x l\u2082) : l\u2081 ++ l\u2082.diff l\u2081 ~ l\u2082 :=", "model_response": "lemma perm_sublist_count_le:\nassumes \"sublist l\u2081 l\u2082\" \"\\<And>x. x \\<in> l\u2081 \\<Longrightarrow> count_list l\u2081 x \\<le> count_list l\u2082 x\"\nshows \"l\u2081 ~ l\u2082\""}
{"gold_output": "theorem epi_inr_of_is_pushout_of_epi {t : PushoutCocone f g} (ht : IsColimit t) [Epi f] :\nEpi t.inr :=", "model_response": "lemma inr_t: \"t.inr \u226b f = pushout.inr\""}
{"gold_output": "theorem nnnorm_zpow_le_mul_norm (n : \u2124) (a : \u03b1) : \u2016a ^ n\u2016\u208a \u2264 \u2016n\u2016\u208a * \u2016a\u2016\u208a :=", "model_response": "lemma nnnorm_inv_le: \"\u2016a\u207b\u00b9\u2016\u208a \u2264 \u2016a\u2016\u208a\""}
{"gold_output": "theorem imageSubobjectCompIso_hom_arrow (f : X \u27f6 Y) [HasImage f] {Y' : C} (h : Y \u27f6 Y') [IsIso h] :\n(imageSubobjectCompIso f h).hom \u226b (imageSubobject f).arrow =\n(imageSubobject (f \u226b h)).arrow \u226b inv h :=", "model_response": "lemma imageSubobjectCompIso_hom_arrow:\n\"(imageSubobjectCompIso f h).hom \u226b (imageSubobject f).arrow =\n(imageSubobject (f \u226b h)).arrow \u226b inv h\""}
{"gold_output": "theorem hasFDerivAt_inv (x_ne_zero : x \u2260 0) :\nHasFDerivAt (fun x => x\u207b\u00b9) (smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (-(x ^ 2)\u207b\u00b9) : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) x :=", "model_response": "lemma hasFDerivAt_inv' :\n\"((\\<lambda>x. x\u207b\u00b9) hasFDerivAt x) (-(x ^ 2)\u207b\u00b9 \u2022 1)\""}
{"gold_output": "theorem grade_eq_grade_iff : grade \ud835\udd46 a = grade \ud835\udd46 b \u2194 a = b :=", "model_response": "lemma grade_lt_grade_iff : \"grade \ud835\udd46 a < grade \ud835\udd46 b \u2194 a < b\""}
{"gold_output": "theorem of_injective (i : \u03b9) : Function.Injective (of \u03b2 i) :=", "model_response": "lemma of_injective [simp]:\n\"Function.Injective (of \u03b2 i)\""}
{"gold_output": "theorem Lp_add_le_tsum {f g : \u03b9 \u2192 \u211d\u22650} {p : \u211d} (hp : 1 \u2264 p) (hf : Summable fun i => f i ^ p)\n(hg : Summable fun i => g i ^ p) :\n(Summable fun i => (f i + g i) ^ p) \u2227\n(\u2211' i, (f i + g i) ^ p) ^ (1 / p) \u2264\n(\u2211' i, f i ^ p) ^ (1 / p) + (\u2211' i, g i ^ p) ^ (1 / p) :=", "model_response": "lemma summable_congr {f g : \u03b9 \u2192 \u211d\u22650} (h : \u2200 x, f x = g x) : Summable f \u2194 Summable g :="}
{"gold_output": "theorem pairwise_subtype_iff_pairwise_finset' (r : \u03b2 \u2192 \u03b2 \u2192 Prop) (f : \u03b1 \u2192 \u03b2) :\nPairwise (r on fun x : s => f x) \u2194 (s : Set \u03b1).Pairwise (r on f) :=", "model_response": "lemma inj_on_coe [simp]:\n\"inj_on f s \\<longleftrightarrow> inj_on f (s : Set \u03b1)\""}
{"gold_output": "theorem gfp_const_inf_le (x : \u03b1) : gfp (const \u03b1 x \u2293 f) \u2264 x :=", "model_response": "lemma gfp_const_comp_le: \"gfp (const \u03b1 o f) \\<le> gfp f\""}
{"gold_output": "theorem Equiv.tsum_eq (j : \u03b3 \u2243 \u03b2) (f : \u03b2 \u2192 \u03b1) : (\u2211' c, f (j c)) = \u2211' b, f b :=", "model_response": "lemma Equiv.summable_iff_summable_compose: \"Summable f \\<longleftrightarrow> Summable (f \\<circ> j)\""}
{"gold_output": "theorem compl_le_compl : s.compl \u2264 t.compl \u2194 s \u2264 t :=", "model_response": "lemma compl_inter_distrib : s.compl \\<inter> t.compl = s.compl \\<union> t.compl :="}
{"gold_output": "theorem _root_.Wbtw.wSameSide\u2082\u2081 {s : AffineSubspace R P} {x y z : P} (h : Wbtw R x y z)\n(hz : z \u2208 s) : s.WSameSide y x :=", "model_response": "lemma incident_set_eq_direction:\n\"{p. proj2_incident p l} = {p \\<in> direction l}\""}
{"gold_output": "theorem sub_im (z w : \u2102) : (z - w).im = z.im - w.im :=", "model_response": "lemma add_im : (a + b).im = a.im + b.im :="}
{"gold_output": "theorem TendstoUniformlyOnFilter.mul (hf : TendstoUniformlyOnFilter f g l l')\n(hf' : TendstoUniformlyOnFilter f' g' l l') : TendstoUniformlyOnFilter (f * f') (g * g') l l' :=", "model_response": "lemma uniformly_continuous_on_mul_iff:\n\"uniformly_continuous_on (l \\<times>\\<^sub>F l') (\\<lambda>x. f x * g x) \\<longleftrightarrow>\n(\u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in l \\<times>\\<^sub>F l', f x.1 * g x.2 = f x.2 * g x.1) \\<and>\n(\u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in l \\<times>\\<^sub>F l', \u2016f x.1 * g x.2\u2016 \u2264 \u2016f x.1\u2016 * \u2016g x.2\u2016)\""}
{"gold_output": "theorem det_submatrix_equiv_self (e : n \u2243 m) (A : Matrix m m R) :\ndet (A.submatrix e e) = det A :=", "model_response": "lemma det_submatrix_self: \"det (A.submatrix e e) = det A\""}
{"gold_output": "theorem swap_apply_ne_self_iff {a b x : \u03b1} : swap a b x \u2260 x \u2194 a \u2260 b \u2227 (x = a \u2228 x = b) :=", "model_response": "lemma injective_swap_iff [simp]: \"injective (swap a b) \u2194 a \u2260 b\""}
{"gold_output": "theorem Embedding.t0Space [TopologicalSpace \u03b2] [T0Space \u03b2] {f : \u03b1 \u2192 \u03b2}\n(hf : Embedding f) : T0Space \u03b1 :=", "model_response": "lemma continuousOn_iff_nhds_eq:\n\"continuousOn s f \\<longleftrightarrow> (\\<forall>x\\<in>s. \ud835\udcdd x = comap f (\ud835\udcdd (f x)) \\<inter> \ud835\udcdf s)\""}
{"gold_output": "theorem congr_refl_right {f g : \u03b1 \u2192 \u03b2} (h : f = g) (a : \u03b1) :\ncongr h (Eq.refl a) = congr_fun h a :=", "model_response": "lemma congr_fun_refl:\nassumes \"f = g\"\nshows \"congr h (Eq.refl a) = congr_fun h a\""}
{"gold_output": "theorem mulEtransformRight_inv : mulEtransformRight e\u207b\u00b9 x = (mulEtransformLeft e x.swap).swap :=", "model_response": "lemma mulEtransformRight_inv :\n\"mulEtransformRight e\u207b\u00b9 x = (mulEtransformLeft e x.swap).swap\""}
{"gold_output": "theorem norm_im_le_norm (z : K) : \u2016im z\u2016 \u2264 \u2016z\u2016 :=", "model_response": "lemma norm_imK_eq_norm (z : \u210d) : \u2016imK z\u2016 = \u2016z\u2016 :="}
{"gold_output": "theorem exists_rat_near (x : \u03b1) (\u03b50 : 0 < \u03b5) : \u2203 q : \u211a, |x - q| < \u03b5 :=", "model_response": "lemma toIocMod_eq_self_iff : toIocMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p) :="}
{"gold_output": "theorem gc_set :\n@GaloisConnection (Set R) (Set (PrimeSpectrum R))\u1d52\u1d48 _ _ (fun s => zeroLocus s) fun t =>\nvanishingIdeal t :=", "model_response": "lemma zeroLocus_surj: \"Surjective zeroLocus\""}
{"gold_output": "theorem reduce.Step.eq (H : Red.Step L\u2081 L\u2082) : reduce L\u2081 = reduce L\u2082 :=", "model_response": "lemma reduce.Step_iff:\nassumes \"chain' R L\\<^sub>1\" \"chain' R' L\\<^sub>2\"\nshows \"reduce.Step L\\<^sub>1 L\\<^sub>2 \\<longleftrightarrow> (\\<exists>L\\<^sub>3. Red.Step L\\<^sub>1 L\\<^sub>3 \\<and> Red.Step L\\<^sub>3 L\\<^sub>2)\""}
{"gold_output": "theorem Surjective.subsingleton [Subsingleton \u03b1] (hf : Surjective f) : Subsingleton \u03b2 :=", "model_response": "lemma inj: \"inj f\" if \"surj f\" \"subsingleton \u03b1\""}
{"gold_output": "theorem range_piecewise (f g : \u03b1 \u2192 \u03b2) : range (s.piecewise f g) = f '' s \u222a g '' s\u1d9c :=", "model_response": "lemma range_infdist_eq:\n\"range (\\<lambda>x. infdist x s) = (\\<lambda>x. infdist x s) ` s \\<union> (\\<lambda>x. infdist x s) ` (UNIV \\ s)\""}
{"gold_output": "theorem IsLocalMin.min (hf : IsLocalMin f a) (hg : IsLocalMin g a) :\nIsLocalMin (fun x => min (f x) (g x)) a :=", "model_response": "lemma isLocalMin_min: \"isLocalMin (\\<lambda>x. min (f x) (g x)) a\""}
{"gold_output": "theorem isLocalRingHom_iff_comap_closedPoint {S : Type v} [CommRing S] [LocalRing S] (f : R \u2192+* S) :\nIsLocalRingHom f \u2194 PrimeSpectrum.comap f (closedPoint S) = closedPoint R :=", "model_response": "lemma isLocalRingHom_comap:\n\"IsLocalRingHom (PrimeSpectrum.comap f)\""}
{"gold_output": "theorem toMulBot_lt : toMulBot a < toMulBot b \u2194 a < b :=", "model_response": "lemma toMulBot_strictMono[simp, intro]: \"StrictMono toMulBot\""}
{"gold_output": "theorem TopologicalGroup.of_nhds_one' {G : Type u} [Group G] [TopologicalSpace G]\n(hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : G \u2192 G \u2192 G)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1))\n(hinv : Tendsto (fun x : G => x\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1))\n(hleft : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1))\n(hright : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x * x\u2080) (\ud835\udcdd 1)) : TopologicalGroup G :=", "model_response": "lemma TopologicalGroup.tendsto_mul_one_one [tendsto_intros]:\n\"((\\<lambda>(x, y). x * y) \\<longlongrightarrow> 1) (\ud835\udcdd (1, 1))\""}
{"gold_output": "theorem ae_mono (h : \u03bc \u2264 \u03bd) : \u03bc.ae \u2264 \u03bd.ae :=", "model_response": "theorem measure_mono (h : \u03bc \u2264 \u03bd) : \u03bc univ \u2264 \u03bd univ :="}
{"gold_output": "theorem not_exists_eq : (\u00ac \u2203 x, s x) = (\u2200 x, \u00ac s x) :=", "model_response": "lemma not_exists_eq_forall_not:\nfixes s :: \"'a \\<Rightarrow> bool\"\nshows \"(\\<not> (\\<exists>x. s x)) = (\\<forall>x. \\<not> s x)\""}
{"gold_output": "theorem map_eq_zero_of_not_injective (v : \u03b9 \u2192 M) (hv : \u00acFunction.Injective v) : f v = 0 :=", "model_response": "lemma map_eq_zero : \"f v = 0\" if \"\\<not> Function.Injective v\""}
{"gold_output": "theorem ssubset_of_subset_of_ne [IsAntisymm \u03b1 (\u00b7 \u2286 \u00b7)] (h\u2081 : a \u2286 b) (h\u2082 : a \u2260 b) : a \u2282 b :=", "model_response": "lemma setOf_ssubset_setOf_iff [simp]:\n\"{a \\<in> \u03b1. P a} \\<subset> {a \\<in> \u03b1. Q a} \\<longleftrightarrow> (\\<exists>x\\<in>\u03b1. P x \\<and> \\<not> Q x)\""}
{"gold_output": "theorem diffContOnCl_univ : DiffContOnCl \ud835\udd5c f univ \u2194 Differentiable \ud835\udd5c f :=", "model_response": "lemma diffContOnCl_univ_iff : DiffContOnCl \ud835\udd5c f univ \u2194 Differentiable \ud835\udd5c f :="}
{"gold_output": "theorem support_esymm' (n : \u2115) [DecidableEq \u03c3] [Nontrivial R] :\n(esymm \u03c3 R n).support =\n(powersetLen n (univ : Finset \u03c3)).biUnion fun t => {\u2211 i : \u03c3 in t, Finsupp.single i 1} :=", "model_response": "lemma support_esymm_powerset:\n\"support (esymm \u03c3 R n) = (\\<lambda>t. \u2211 i in t, Finsupp.single i 1) ` (powersetLen n (univ : Finset \u03c3))\""}
{"gold_output": "theorem infiniteNeg_iff_infinite_and_neg {x : \u211d*} : InfiniteNeg x \u2194 Infinite x \u2227 x < 0 :=", "model_response": "lemma abs_def' [simp]: \"|r| = rAbs r\""}
{"gold_output": "theorem promises_congr {c\u2081 c\u2082 : Computation \u03b1} (h : c\u2081 ~ c\u2082) (a) : c\u2081 ~> a \u2194 c\u2082 ~> a :=", "model_response": "lemma equivalence_of_promises:\nassumes \"c\\<^sub>1 \\<sim> c\\<^sub>2\"\nshows \"c\\<^sub>1 \\<rightarrow> a \\<sim> c\\<^sub>2 \\<rightarrow> a\""}
{"gold_output": "theorem sdiff_self : a \\ a = \u22a5 :=", "model_response": "lemma set_comprehension_diff : { x | x \u2208 a \u2227 x \u2209 b } = { x | x \u2208 a \\ b } :="}
{"gold_output": "theorem coe_int_cast [IntCast \u03b2] (n : \u2124) : ((n : C(\u03b1, \u03b2)) : \u03b1 \u2192 \u03b2) = n :=", "model_response": "lemma coe_int_cast [simp]: ((n : C(\u03b1, \u03b2)) : \u03b1 \u2192 \u03b2) = n :="}
{"gold_output": "theorem cast_add [AddMonoidWithOne R] (m n : \u2115) : ((m + n : \u2115) : R) = m + n :=", "model_response": "lemma ofNat_add [simp]:\n\"ofNat (m + n) = ofNat m + ofNat n\""}
{"gold_output": "theorem val_one (n : \u2115) : (1 : Fin (n + 2)).val = 1 :=", "model_response": "lemma val_one [simp]:\n\"(1 : Fin (n + 2)).val = 1\""}
{"gold_output": "theorem Split.map {\ud835\udc9c \u212c : Type _} [Category \ud835\udc9c] [Preadditive \ud835\udc9c] [Category \u212c] [Preadditive \u212c]\n(F : \ud835\udc9c \u2964 \u212c) [Functor.Additive F] {A B C : \ud835\udc9c} {f : A \u27f6 B} {g : B \u27f6 C} (h : Split f g) :\nSplit (F.map f) (F.map g) :=", "model_response": "lemma comp_eq: \"F.obj A \u226b F.obj B = F.obj C\""}
{"gold_output": "theorem coe_le_coe : (\u2191r : \u211d\u22650\u221e) \u2264 \u2191q \u2194 r \u2264 q :=", "model_response": "lemma toReal_strictMono:\n\"StrictMono toReal\""}
{"gold_output": "theorem sum_ramification_inertia (K L : Type _) [Field K] [Field L] [IsDomain R]\n[IsDedekindDomain R] [Algebra R K] [IsFractionRing R K] [Algebra S L] [IsFractionRing S L]\n[Algebra K L] [Algebra R L] [IsScalarTower R S L] [IsScalarTower R K L] [IsNoetherian R S]\n[IsIntegralClosure S R L] [p.IsMaximal] (hp0 : p \u2260 \u22a5) :\n(\u2211 P in (factors (map (algebraMap R S) p)).toFinset,\nramificationIdx (algebraMap R S) p P * inertiaDeg (algebraMap R S) p P) =\nfinrank K L :=", "model_response": "lemma (in field_extension) sum_prime_ideal_ramification_inertia_eq_field_extension_degree:\nshows \"(\\<Sum>P\\<in>(factors (map (algebraMap R S) p)). ramification_index (algebraMap R S) p P *\ninertia_degree (algebraMap R S) p P) = field_extension_degree K L\""}
{"gold_output": "theorem half_add_self (a : R) : (a + a) / 2 = a :=", "model_response": "lemma add_half_self : \"a + (a / 2) = a\""}
{"gold_output": "theorem trans_symm_self : e.symm.trans e \u2248 LocalHomeomorph.ofSet e.target e.open_target :=", "model_response": "lemma symm_symm_eq: \"e.symm.symm = e\""}
{"gold_output": "theorem le_rank_iff_exists_linearIndependent {c : Cardinal} :\nc \u2264 Module.rank K V \u2194 \u2203 s : Set V, (#s) = c \u2227 LinearIndependent K ((\u2191) : s \u2192 V) :=", "model_response": "lemma mk_functions_eq_power (n) (\u03b1 : Type u) : (#(Set.univ : Fin n \u2192 \u03b1)) = (#\u03b1) ^\u2115 n :="}
{"gold_output": "theorem closure_mul_image_eq_top (hR : R \u2208 rightTransversals (H : Set G)) (hR1 : (1 : G) \u2208 R)\n(hS : closure S = \u22a4) : closure ((R * S).image fun g =>\n\u27e8g * (toFun hR g : G)\u207b\u00b9, mul_inv_toFun_mem hR g\u27e9 : Set H) = \u22a4 :=", "model_response": "lemma closure_mul_image_eq_top [simp]:\n\"closure ((R * S).image fun g => \u27e8g * (toFun hR g : G)\u207b\u00b9, mul_inv_toFun_mem hR g\u27e9 : Set H) = \u22a4\""}
{"gold_output": "theorem exists_eq_X_add_C_of_natDegree_le_one (h : natDegree p \u2264 1) : \u2203 a b, p = C a * X + C b :=", "model_response": "lemma degree_to_subring_le_one (h : natDegree p \u2264 1) : degree (to_subring p T hp) \u2264 1 :="}
{"gold_output": "theorem lex_def {r : \u03b9 \u2192 \u03b9 \u2192 Prop} {s : \u2200 i, \u03b1 i \u2192 \u03b1 i \u2192 Prop} {a b : \u03a0\u2080 i, \u03b1 i} :\nDfinsupp.Lex r s a b \u2194 \u2203 j, (\u2200 d, r d j \u2192 a d = b d) \u2227 s j (a j) (b j) :=", "model_response": "lemma toFinsupp_inj: \"toFinsupp x = toFinsupp y \\<longleftrightarrow> x = y\""}
{"gold_output": "theorem isBigOWith_congr (e : LocalHomeomorph \u03b1 \u03b2) {b : \u03b2} (hb : b \u2208 e.target) {f : \u03b2 \u2192 E}\n{g : \u03b2 \u2192 F} {C : \u211d} : IsBigOWith C (\ud835\udcdd b) f g \u2194 IsBigOWith C (\ud835\udcdd (e.symm b)) (f \u2218 e) (g \u2218 e) :=", "model_response": "lemma isBigOWith_congr:\n\"isBigOWith C (\ud835\udcdd b) f g \\<longleftrightarrow> isBigOWith C (\ud835\udcdd (e.symm b)) (f \\<circ> e.symm) (g \\<circ> e.symm) \""}
{"gold_output": "theorem injective_quotient_le_comap_map (P : Ideal R[X]) :\nFunction.Injective <|\nIdeal.quotientMap\n(Ideal.map (Polynomial.mapRingHom (Quotient.mk (P.comap (C : R \u2192+* R[X])))) P)\n(Polynomial.mapRingHom (Ideal.Quotient.mk (P.comap (C : R \u2192+* R[X]))))\nle_comap_map :=", "model_response": "lemma coe_injective :\n\"Function.Injective ((\u2191) : \u03b1 \u2192 Completion \u03b1)\""}
{"gold_output": "theorem mk_compl_eq_mk_compl_finite_lift {\u03b1 : Type u} {\u03b2 : Type v} [Finite \u03b1] {s : Set \u03b1}\n{t : Set \u03b2} (h1 : (lift.{max v w, u} (#\u03b1)) = (lift.{max u w, v} (#\u03b2)))\n(h2 : lift.{max v w, u} (#s) = lift.{max u w, v} (#t)) :\nlift.{max v w} (#(s\u1d9c : Set \u03b1)) = lift.{max u w} (#(t\u1d9c : Set \u03b2)) :=", "model_response": "theorem mk_compl_eq_mk_compl_iff {\u03b1 : Type u} {\u03b2 : Type v} [Finite \u03b1] {s : Set \u03b1} {t : Set \u03b2} :\nlift.{max v w, u} (#(s\u1d9c : Set \u03b1)) = lift.{max u w, v} (#(t\u1d9c : Set \u03b2)) \u2194\nlift.{max v w, u} (#s) = lift.{max u w, v} (#t) :="}
{"gold_output": "theorem toMeasure_eq_iff_eq_toPmf (\u03bc : Measure \u03b1) [IsProbabilityMeasure \u03bc] :\np.toMeasure = \u03bc \u2194 p = \u03bc.toPmf :=", "model_response": "lemma toMeasure_apply_eq_sum_indicator (\u03bc : Measure \u03b1) [IsProbabilityMeasure \u03bc] :\np.toMeasure s = \u2211' x, (indicator s (p x)) :="}
{"gold_output": "theorem tensor_associativity_aux (W X Y Z : C) :\n((\u03b2_ W X).hom \u2297 \ud835\udfd9 (Y \u2297 Z)) \u226b\n(\u03b1_ X W (Y \u2297 Z)).hom \u226b\n(\ud835\udfd9 X \u2297 (\u03b1_ W Y Z).inv) \u226b (\ud835\udfd9 X \u2297 (\u03b2_ (W \u2297 Y) Z).hom) \u226b (\ud835\udfd9 X \u2297 (\u03b1_ Z W Y).inv) =\n(\ud835\udfd9 (W \u2297 X) \u2297 (\u03b2_ Y Z).hom) \u226b\n(\u03b1_ (W \u2297 X) Z Y).inv \u226b\n((\u03b1_ W X Z).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ W (X \u2297 Z)).hom \u2297 \ud835\udfd9 Y) \u226b ((\u03b1_ X Z W).hom \u2297 \ud835\udfd9 Y) \u226b (\u03b1_ X (Z \u2297 W) Y).hom :=", "model_response": "lemma pentagon_inv_aux:\n\"((\u03b2_ W X).hom \u2297 \ud835\udfd9 (Y \u2297 Z)) \u226b\n(\u03b1_ X W (Y \u2297 Z)).hom \u226b\n(\ud835\udfd9 X \u2297 (\u03b1_ W Y Z).inv) \u226b (\ud835\udfd9 X \u2297 (\u03b2_ (W \u2297 Y) Z).hom) \u226b (\ud835\udfd9 X \u2297 (\u03b1_ Z W Y).inv) =\n(\ud835\udfd9 (W \u2297 X) \u2297 (\u03b2_ Y Z).hom) \u226b\n(\u03b1_ (W \u2297 X) Z Y).inv \u226b\n((\u03b1_ W X Z).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ W (X \u2297 Z)).hom \u2297 \ud835\udfd9 Y) \u226b ((\u03b1_ X Z W).hom \u2297 \ud835\udfd9 Y) \u226b (\u03b1_ X (Z \u2297 W) Y).hom \u226b\n(\ud835\udfd9 (Z \u2297 W) \u2297 (\u03b2_ X Y).hom) \u226b\n((\u03b1_ Z W (X \u2297 Y)).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b1_ Z (X \u2297 Y) W).inv \u2297 \ud835\udfd9 Y) \u226b\n(\ud835\udfd9 (Z \u2297 (X \u2297 Y)) \u2297 (\u03b2_ W (X \u2297 Y)).hom) \u226b\n((\u03b1_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y) \u226b\n((\u03b2_ Z (X \u2297 Y) W).hom \u2297 \ud835\udfd9 Y)"}
{"gold_output": "theorem find_le (n : \u2115) (h : P n) : find P \u2264 n :=", "model_response": "lemma find_mono : Monotone find :="}
{"gold_output": "theorem zipWith_swap_prod_support' (l l' : List \u03b1) :\n{ x | (zipWith swap l l').prod x \u2260 x } \u2264 l.toFinset \u2294 l'.toFinset :=", "model_response": "lemma support_swap_eq : \"{ x | (zipWith swap l l').prod x \\<noteq> x } = l.toFinset \\<union> l'.toFinset\""}
{"gold_output": "theorem coeff_zero_one : coeff 0 (1 : MvPolynomial \u03c3 R) = 1 :=", "model_response": "lemma coeff_one : \"MPoly_Type.coeff 0 (1 : MvPolynomial \u03c3 R) = 1\""}
{"gold_output": "theorem primorial_pos (n : \u2115) : 0 < n# :=", "model_response": "lemma primorial_pos [simp]: \"0 < n#\" for n : \u2115 :="}
{"gold_output": "theorem lcs_zero : I.lcs M 0 = \u22a4 :=", "model_response": "lemma (in LieModule) lcs_zero : \"I.lcs M 0 = \u22a4\""}
{"gold_output": "theorem abs_add_eq_iff : abs (x + y) = abs x + abs y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg :=", "model_response": "lemma abs_add_eq_iff: \"cmod (x + y) = cmod x + cmod y \u2194 x = 0 \u2228 y = 0 \u2228 x.arg = y.arg\""}
{"gold_output": "theorem rpow_add_rpow_le_add {p : \u211d} (a b : \u211d\u22650) (hp1 : 1 \u2264 p) :\n(a ^ p + b ^ p) ^ (1 / p) \u2264 a + b :=", "model_response": "lemma continuousAt_toReal: \"continuousAt toReal x\""}
{"gold_output": "theorem smulAddMonoidHom_apply_of_of [DecidableEq \u03b9] [GMonoid A] [Gmodule A M] {i j} (x : A i)\n(y : M j) :\nsmulAddMonoidHom A M (DirectSum.of A i x) (of M j y) = of M (i + j) (GSmul.smul x y) :=", "model_response": "lemma smulAddMonoidHom_apply_of_of [simp]:\n\"smulAddMonoidHom A M (DirectSum.of A i x) (of A j y) = of A (i + j) (GSmul.smul x y)\""}
{"gold_output": "theorem coe_homothetyAffine (c : P1) : \u21d1(homothetyAffine c : k \u2192\u1d43[k] _) = homothety c :=", "model_response": "lemma coe_homothetyAffine: \"homothetyAffine c t = homothety c t\""}
{"gold_output": "theorem Filter.Tendsto.apply {l : Filter \u03b2} {f : \u03b2 \u2192 \u2200 i, \u03c0 i} {x : \u2200 i, \u03c0 i}\n(h : Tendsto f l (\ud835\udcdd x)) (i : \u03b9) : Tendsto (fun a => f a i) l (\ud835\udcdd <| x i) :=", "model_response": "lemma continuousAt_pi_iff [simp]:\n\"continuousAt f x \\<longleftrightarrow> (\\<forall>i. ContinuousAt (\\<lambda>x. f x i) x)\""}
{"gold_output": "theorem zero_iff_subsingleton : IsSMulRegular M (0 : R) \u2194 Subsingleton M :=", "model_response": "lemma toIcoMod_commute: \"toIcoMod hp a b = toIcoMod hp b a\""}
{"gold_output": "theorem orthogonalProjection_minimal {U : Submodule \ud835\udd5c E} [CompleteSpace U] (y : E) :\n\u2016y - orthogonalProjection U y\u2016 = \u2a05 x : U, \u2016y - x\u2016 :=", "model_response": "lemma orthogonalProjection_norm_le_norm:\n\"norm (orthogonalProjection K v) \\<le> norm v\""}
{"gold_output": "theorem Valid'.valid {t o\u2081 o\u2082} (h : @Valid' \u03b1 _ o\u2081 t o\u2082) : Valid t :=", "model_response": "lemma valid_cons_valid :\nassumes \"valid' o\\<^sub>1 t o\\<^sub>2\"\nand     \"t \\<noteq> Tip\"\nshows \"valid' x (cons x t) (size t)\""}
{"gold_output": "theorem abs_dist {a b : \u03b1} : |dist a b| = dist a b :=", "model_response": "lemma abs_dist_commute (a b : \u03b1) : |dist a b - dist b a| = dist a b :="}
{"gold_output": "theorem limit_topology (F : J \u2964 TopCatMax.{v, u}) :\n(limit F).str = \u2a05 j, (F.obj j).str.induced (limit.\u03c0 F j) :=", "model_response": "lemma limit_precomp_\u03c0 (j) :\n\"limit.\u03c0 F j \u226b limit_precomp F P = limit_precomp F P \u226b limit.\u03c0 (op F \u22d9 P) j\""}
{"gold_output": "theorem Fin.circulant_mul [Semiring \u03b1] :\n\u2200 {n} (v w : Fin n \u2192 \u03b1), circulant v \u2b1d circulant w = circulant (mulVec (circulant v) w)", "model_response": "lemma circulant_mul [simp]:\n\"circulant v \u2b1d circulant w = circulant (mulVec (circulant v) w)\""}
{"gold_output": "theorem basisSets_singleton_mem (i : \u03b9) {r : \u211d} (hr : 0 < r) : (p i).ball 0 r \u2208 p.basisSets :=", "model_response": "lemma continuousOn_pi_iff [simp]:\n\"continuousOn s f \\<longleftrightarrow> (\\<forall>i. ContinuousOn (\\<lambda>x. f x i) s)\""}
{"gold_output": "theorem gcd_dvd_gcd_mul_right_right (i j k : \u2124) : gcd i j \u2223 gcd i (j * k) :=", "model_response": "lemma gcd_one_right [simp]: \"gcd a 1 = normalize a\"\nfor a :: \u2124"}
{"gold_output": "theorem type_def (r) [wo : IsWellOrder \u03b1 r] : (\u27e6\u27e8\u03b1, r, wo\u27e9\u27e7 : Ordinal) = type r :=", "model_response": "lemma type_eq_ordLess [simp]: \"type univ.{<} = type r\""}
{"gold_output": "theorem le_iff : f \u2264 g \u2194 \u2200 i \u2208 f.support, f i \u2264 g i :=", "model_response": "lemma support_add_subset :\n\"support (f + g) \\<subseteq> support f \\<union> support g\""}
{"gold_output": "theorem inv_eq_of_mul_eq_one_left {a : \u03b1} (h : a * u = 1) : \u2191u\u207b\u00b9 = a :=", "model_response": "theorem inv_eq' : (\u2191u\u207b\u00b9 : \u03b1) = a :="}
{"gold_output": "theorem unzip_zip_right {l\u2081 : List \u03b1} {l\u2082 : List \u03b2} (h : length l\u2082 \u2264 length l\u2081) :\n(unzip (zip l\u2081 l\u2082)).2 = l\u2082 :=", "model_response": "lemma unzip_zip_right :\n\"(unzip (zip l\u2081 l\u2082)).2 = l\u2082\""}
{"gold_output": "theorem sqrt_pos {n : \u2115} : 0 < sqrt n \u2194 0 < n :=", "model_response": "lemma sqrt_eq_max' {n : \u2115} : sqrt n = Max (Set.range fun m => m ^ 2 \u2264 n) :="}
{"gold_output": "theorem Summable.sub (hf : Summable f) (hg : Summable g) : Summable fun b => f b - g b :=", "model_response": "lemma summable_sub_iff [simp]: \"Summable (\\<lambda>b. f b - g b) \\<longleftrightarrow> Summable f \\<and> Summable g\""}
{"gold_output": "theorem subtype_map_of_mem {p : \u03b1 \u2192 Prop} [DecidablePred p] {s : Finset \u03b1} (h : \u2200 x \u2208 s, p x) :\n(s.subtype p).map (Embedding.subtype _) = s :=", "model_response": "lemma card_subtype [simp]:\n\"card {a. p a} = card {a \\<in> s. p a}\""}
{"gold_output": "theorem average_add_measure [IsFiniteMeasure \u03bc] {\u03bd : Measure \u03b1} [IsFiniteMeasure \u03bd] {f : \u03b1 \u2192 E}\n(h\u03bc : Integrable f \u03bc) (h\u03bd : Integrable f \u03bd) :\n(\u2a0d x, f x \u2202\u03bc + \u03bd) =\n(((\u03bc univ).toReal / ((\u03bc univ).toReal + (\u03bd univ).toReal)) \u2022 \u2a0d x, f x \u2202\u03bc) +\n((\u03bd univ).toReal / ((\u03bc univ).toReal + (\u03bd univ).toReal)) \u2022 \u2a0d x, f x \u2202\u03bd :=", "model_response": "lemma average_add_measure [simp]:\n\"(\u2a0d x, f x \u2202\u03bc + \u03bd) = ((\u03bc univ).toReal / ((\u03bc univ).toReal + (\u03bd univ).toReal)) \u2022 (\u2a0d x, f x \u2202\u03bc) +\n((\u03bd univ).toReal / ((\u03bc univ).toReal + (\u03bd univ).toReal)) \u2022 (\u2a0d x, f x \u2202\u03bd)\""}
{"gold_output": "theorem exi_rat_seq_conv_cauchy : IsCauSeq (padicNorm p) (limSeq f) :=", "model_response": "lemma norm_le_padicNorm:\n\"norm (f n) \\<le> padicNorm p f\""}
{"gold_output": "theorem mk_mem_interedges_iff : (a, b) \u2208 interedges r s t \u2194 a \u2208 s \u2227 b \u2208 t \u2227 r a b :=", "model_response": "lemma interedges_alt: \"{(a,b) |a b. a \\<in> s \\<and> b \\<in> t \\<and> r a b} = edges r \\<inter> s \\<times> t\""}
{"gold_output": "theorem lift_compr\u2082 (g : P \u2192\u2097[R] Q) : lift (f.compr\u2082 g) = g.comp (lift f) :=", "model_response": "lemma lift_compr\u2082 (g : P \u2192\u2097[R] Q) : lift (f.compr\u2082 g) = g.comp (lift f) :="}
{"gold_output": "theorem eq_zero_of_mulVec_eq_zero [DecidableEq m] {M : Matrix m m A} (hM : M.det \u2260 0) {v : m \u2192 A}\n(hv : M.mulVec v = 0) : v = 0 :=", "model_response": "lemma det_row_sum (M : Matrix m m A) (i : m) (a : m \u2192 A) (S : Finset m) :\ndet (updateRow M i (\u2211 s in S, a s)) = \u2211 s in S, det (updateRow M i (a s)) :="}
{"gold_output": "theorem rank_fin_fun (n : \u2115) : Module.rank K (Fin n \u2192 K) = n :=", "model_response": "lemma (in ring) rank_zmod_eq : \"Module.rank K (ZMod n) = n\""}
{"gold_output": "theorem Composition.toCompositionAsSet_length (c : Composition n) :\nc.toCompositionAsSet.length = c.length :=", "model_response": "lemma length_of_composition (n i : Composition) :\nn.length = n.toCompositionAsSet.length :="}
{"gold_output": "theorem diff_mem_nhdsWithin_compl {x : \u03b1} {s : Set \u03b1} (hs : s \u2208 \ud835\udcdd x) (t : Set \u03b1) :\ns \\ t \u2208 \ud835\udcdd[t\u1d9c] x :=", "model_response": "lemma nhdsWithin_diff_self: \"{x \\<in> s. x \\<in> t} \\<in> \ud835\udcdd[s - t] x\""}
{"gold_output": "theorem StrictAntiOn.comp [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1}\n{t : Set \u03b2} (hg : StrictAntiOn g t) (hf : StrictAntiOn f s) (hs : Set.MapsTo f s t) :\nStrictMonoOn (g \u2218 f) s :=", "model_response": "lemma strictAntiOn_of_nat [simp]:\n\"strictAntiOn of_nat s\""}
{"gold_output": "theorem Nat.sq_add_sq_modEq (p : \u2115) [Fact p.Prime] (x : \u2115) :\n\u2203 a b : \u2115, a \u2264 p / 2 \u2227 b \u2264 p / 2 \u2227 a ^ 2 + b ^ 2 \u2261 x [MOD p] :=", "model_response": "lemma sqrt_add_sq_le_add (a b : \u2115) : sqrt (a ^ 2 + b ^ 2) \u2264 a + b :="}
{"gold_output": "theorem mul_neg_iff : a * b < 0 \u2194 0 < a \u2227 b < 0 \u2228 a < 0 \u2227 0 < b :=", "model_response": "lemma toIcoMod_eq_self_iff:\n'toIcoMod hp a b = b  \\<longleftrightarrow> b \\<in> Set.Ico a (a + p)'"}
{"gold_output": "theorem integral_interval_sub_interval_comm (hab : IntervalIntegrable f \u03bc a b)\n(hcd : IntervalIntegrable f \u03bc c d) (hac : IntervalIntegrable f \u03bc a c) :\n((\u222b x in a..b, f x \u2202\u03bc) - \u222b x in c..d, f x \u2202\u03bc) =\n(\u222b x in a..c, f x \u2202\u03bc) - \u222b x in b..d, f x \u2202\u03bc :=", "model_response": "lemma integral_sub_interval_comm (hab : IntervalIntegrable f \u03bc a b)\n(hcd : IntervalIntegrable f \u03bc c d) (hac : IntervalIntegrable f \u03bc a c) :\n(\u222b x in a..b, f x \u2202\u03bc) - \u222b x in c..d, f x \u2202\u03bc =\n\u222b x in a..c, f x \u2202\u03bc - \u222b x in b..d, f x \u2202\u03bc :="}
{"gold_output": "theorem subset_iUnion (h : J \u2208 \u03c0) : \u2191J \u2286 \u03c0.iUnion :=", "model_response": "lemma parts_iUnion (h : J \u2208 \u03c0) : \u2191(parts \u03c0) = \u03c0 iUnion :="}
{"gold_output": "theorem integral_sub {f g : \u2102 \u2192 E} {c : \u2102} {R : \u211d} (hf : CircleIntegrable f c R)\n(hg : CircleIntegrable g c R) :\n(\u222e z in C(c, R), f z - g z) = (\u222e z in C(c, R), f z) - \u222e z in C(c, R), g z :=", "model_response": "lemma integral_circle_neg:\n\"integral_circle f c R = -integral_circle (\\<lambda>z. f (-z)) c R\""}
{"gold_output": "theorem CoverDense.locallyCoverDense [Full G] (H : CoverDense K G) : LocallyCoverDense K G :=", "model_response": "theorem whiskering_forget_forget :\nwhiskeringRight K G _ \u22d9 whiskeringRight K (forget G) _ \u22d9 forget (CommRingCat) = forget _ :="}
{"gold_output": "theorem const_append1 {\u03b2 \u03b3} (x : \u03b3) {n} (\u03b1 : TypeVec n) :\nTypeVec.const x (\u03b1 ::: \u03b2) = appendFun (TypeVec.const x \u03b1) fun _ => x :=", "model_response": "lemma (in is_tm_functor) is_tm_functor_Set_morphism:\n\"Set_Theory.morphism (f :: _ \\<Rightarrow> _)\""}
{"gold_output": "theorem forall_mem_empty_iff (p : \u03b1 \u2192 Prop) : (\u2200 x, x \u2208 (\u2205 : Finset \u03b1) \u2192 p x) \u2194 True :=", "model_response": "lemma set_compr_empty_iff [simp]:\n\"{ x | x. p x } = \u2205 \u2194 \u2200 x, \u00acp x\""}
{"gold_output": "theorem centralizer_le (s t : Set R) (h : s \u2286 t) : centralizer t \u2264 centralizer s :=", "model_response": "theorem centralizer_eq_top_iff_subset {s : Set R} : centralizer s = \u22a4 \u2194 s \u2286 center R :="}
{"gold_output": "theorem prod_nat_ofNat : ofNat (\u2115 \u00d7 \u2115) = unpair :=", "model_response": "lemma prod_nat_ofNat_eq [simp]: \"ofNat (prod_nat) = unpair\""}
{"gold_output": "theorem aeval_one : aeval x (1 : R[X]) = 1 :=", "model_response": "lemma aeval_X_one [simp]: \"aeval x 1 = 1\""}
{"gold_output": "theorem Ioc_diff_right : Ioc a b \\ {b} = Ioo a b :=", "model_response": "lemma Ioc_diff_right : {x \\<in> Ioc a b. x \\<noteq> b} = Ioo a b :="}
{"gold_output": "theorem cardPowDegree_nonzero (p : Fq[X]) (hp : p \u2260 0) :\ncardPowDegree p = (Fintype.card Fq : \u2124) ^ p.natDegree :=", "model_response": "lemma cardPowDegree_nonzero [simp]:\n\"cardPowDegree (p :: 'a :: finite_field Fq poly) = (Fintype.card Fq : \u2124) ^ p.natDegree\"\nif \"p \\<noteq> 0\""}
{"gold_output": "theorem leftInverse_section_inclusion : Function.LeftInverse section\u0393'Bool inclusionBool\u0393' :=", "model_response": "lemma rightInverse_section_inclusion :\n\"Function.RightInverse inclusionBool\u0393' section\u0393'Bool\""}
{"gold_output": "theorem degree_C_lt_degree_C_mul_X (ha : a \u2260 0) : degree (C b) < degree (C a * X) :=", "model_response": "lemma degree_C_lt_degree_C_mul_X (a0 : a \u2260 0) : degree (C b) < degree (C a * X) :="}
{"gold_output": "theorem toIocMod_add_zsmul' (a b : \u03b1) (m : \u2124) :\ntoIocMod hp (a + m \u2022 p) b = toIocMod hp a b + m \u2022 p :=", "model_response": "lemma toIocMod_commute: \"toIocMod hp (a + m \u2022 p) b = toIocMod hp b a + p\""}
{"gold_output": "theorem ker_coeSubmodule : (f.ker : Submodule R M) = LinearMap.ker (f : M \u2192\u2097[R] N) :=", "model_response": "lemma ker_eq_bot_iff : f.ker = bot \\<longleftrightarrow> Injective f :="}
{"gold_output": "theorem StarConvex.linear_preimage {s : Set F} (f : E \u2192\u2097[\ud835\udd5c] F) (hs : StarConvex \ud835\udd5c (f x) s) :\nStarConvex \ud835\udd5c x (s.preimage f) :=", "model_response": "lemma star_convex_preimage_eq: \"f \u207b\u00b9' s = {x. f x \u2208 s}\""}
{"gold_output": "theorem max_div_div_left' (a b c : \u03b1) : max (a / b) (a / c) = a / min b c :=", "model_response": "lemma max_commute: \"max a b = max b a\""}
{"gold_output": "theorem comp_eq : r \u2218r (\u00b7 = \u00b7) = r :=", "model_response": "lemma toDual_comp_ofDual : toDual \\<circ> ofDual = id :="}
{"gold_output": "theorem eq_mk_of_is_sol_of_eq_init {u : \u2115 \u2192 \u03b1} {init : Fin E.order \u2192 \u03b1} (h : E.IsSolution u)\n(heq : \u2200 n : Fin E.order, u n = init n) : \u2200 n, u n = E.mkSol init n :=", "model_response": "lemma eq_mk_of_is_sol_of_eq_init_aux:\nassumes \"E.IsSolution u\"\nassumes \"\\<And>n. n \\<in> Fin E.order \\<Longrightarrow> u n = init n\"\nshows \"\\<And>n. u n = E.mkSol init n\""}
{"gold_output": "theorem option_some_iff {f : \u03b1 \u2192 \u03b2 \u2192 \u03c3} : (Primrec\u2082 fun a b => some (f a b)) \u2194 Primrec\u2082 f :=", "model_response": "lemma encode_prim [simp]: \"prim_recfn 1 encode\""}
{"gold_output": "theorem Ioi_subset_Ioc_union_Ici : Ioi a \u2286 Ioc a b \u222a Ici b :=", "model_response": "lemma Ioi_subset_Ici_union_Ici : \"Ioi a \\<subseteq> Ici a \\<union> Ici b\""}
{"gold_output": "theorem exists_coeff_mem_comap_sdiff_comap_of_root_mem_sdiff [IsPrime I] (hIJ : I \u2264 J) {r : S}\n(hr : r \u2208 (J : Set S) \\ I) {p : R[X]} (p_ne_zero : p.map (Quotient.mk (I.comap f)) \u2260 0)\n(hpI : p.eval\u2082 f r \u2208 I) : \u2203 i, p.coeff i \u2208 (J.comap f : Set R) \\ I.comap f :=", "model_response": "lemma preimage_eq_aux: \"{x \\<in> f \u207b\u00b9' J. f x \\<in> I} = f \u207b\u00b9' {x \\<in> J. x \\<in> I}\""}
{"gold_output": "theorem Convex.combo_closure_interior_mem_interior {s : Set E} (hs : Convex \ud835\udd5c s) {x y : E}\n(hx : x \u2208 closure s) (hy : y \u2208 interior s) {a b : \ud835\udd5c} (ha : 0 \u2264 a) (hb : 0 < b)\n(hab : a + b = 1) : a \u2022 x + b \u2022 y \u2208 interior s :=", "model_response": "lemma convex_hull_insert_eq_image2 {x : E} {s : Set E} (hx : x \u2208 closure s)\n(hy : y \u2208 interior s) :\nconvex_hull \ud835\udd5c (insert x s) =\n{a \u2022 x + b \u2022 y | a b y. a \u2208 {a. 0 \u2264 a} \u2229 {a. a + b = 1} \u2227 b \u2208 {b. 0 < b} \u2227 y \u2208 convex hull \ud835\udd5c s} :="}
{"gold_output": "theorem is_simple_module_of_finrank_eq_one {A} [Semiring A] [Module A V] [SMul K A]\n[IsScalarTower K A V] (h : finrank K V = 1) : IsSimpleOrder (Submodule A V) :=", "model_response": "theorem order_submodule [simp]: \"order (Submodule A V) = order V K\""}
{"gold_output": "theorem AffineIndependent.finrank_vectorSpan [Fintype \u03b9] {p : \u03b9 \u2192 P} (hi : AffineIndependent k p)\n{n : \u2115} (hc : Fintype.card \u03b9 = n + 1) : finrank k (vectorSpan k (Set.range p)) = n :=", "model_response": "lemma card_incident_points_eq_card_incident_points_finite_sadd_one:\n\"card {p. {q \\<in> S. p \u2208 S.incident q} = {}} = card {p. {q \\<in> S. p \u2208 S.incident q} = {}} + 1\""}
{"gold_output": "theorem app_eq (X : C) : (app \u03c4) (W.Q.obj X) = \u03c4.app X :=", "model_response": "theorem W.map_comp_mk: \"W.map f \u2218 W.mk = W.mk \u2218 f\""}
{"gold_output": "theorem Filter.Tendsto.zpow\u2080 {f : \u03b1 \u2192 G\u2080} {l : Filter \u03b1} {a : G\u2080} (hf : Tendsto f l (\ud835\udcdd a)) (m : \u2124)\n(h : a \u2260 0 \u2228 0 \u2264 m) : Tendsto (fun x => f x ^ m) l (\ud835\udcdd (a ^ m)) :=", "model_response": "lemma continuousAt_zpow_const_iff [simp]:\n\"ContinuousAt (\\<lambda>x. f x ^ m) x \\<longleftrightarrow> (a \\<noteq> 0 \\<or> m \\<ge> 0) \\<and> ContinuousAt f x\""}
{"gold_output": "theorem map_linearMap_volume_pi_eq_smul_volume_pi {f : (\u03b9 \u2192 \u211d) \u2192\u2097[\u211d] \u03b9 \u2192 \u211d}\n(hf : LinearMap.det f \u2260 0) : Measure.map f volume =\nENNReal.ofReal (abs (LinearMap.det f)\u207b\u00b9) \u2022 volume :=", "model_response": "lemma map_linearMap_volume_pi (f : (\u03b9 \u2192 \u211d) \u2192\u2097[\u211d] \u03b9 \u2192 \u211d) (hf : LinearMap.det f \u2260 0) :\nMeasure.map f volume = volume :="}
{"gold_output": "theorem ae_tendsto_measure_inter_div_of_measurableSet (\u03bc : Measure \u03b2) [IsLocallyFiniteMeasure \u03bc]\n{s : Set \u03b2} (hs : MeasurableSet s) :\n\u2200\u1d50 x \u2202\u03bc,\nTendsto (fun r => \u03bc (s \u2229 closedBall x r) / \u03bc (closedBall x r)) (\ud835\udcdd[>] 0)\n(\ud835\udcdd (s.indicator 1 x)) :=", "model_response": "lemma tendsto_measure_div_nhds_0:\n\"((\\<lambda>r. \u03bc (s \\<inter> closedBall x r) / \u03bc (closedBall x r)) \\<longlongrightarrow> s.indicator x x) (\ud835\udcdd[>] 0)\""}
{"gold_output": "theorem HasDerivAtFilter.add (hf : HasDerivAtFilter f f' x L)\n(hg : HasDerivAtFilter g g' x L) : HasDerivAtFilter (fun y => f y + g y) (f' + g') x L :=", "model_response": "lemma has_deriv_at_add_const (c : F) :\n\"((\\<lambda>x. x + c) has_deriv_at x) 1\""}
{"gold_output": "theorem eq_zero_iff {p : MvPolynomial \u03c3 R} : p = 0 \u2194 \u2200 d, coeff d p = 0 :=", "model_response": "lemma degree_C_mul_eq' [simp]:\n\"degree (C (a::'a::{mult_zero,zero}) * p) = degree p\" if \"a \\<noteq> 0\" \"p \\<noteq> 0\""}
{"gold_output": "theorem iSup_eq_of_mem_grothendieck (hR : Sieve.generate R \u2208 Opens.grothendieckTopology X U) :\niSup (coveringOfPresieve U R) = U :=", "model_response": "lemma coveringOfPresieve_eq_iff:\nassumes \"R \\<subseteq> \\<lbrakk>U\\<rbrakk>\\<^sub>P\"\nshows \"coveringOfPresieve U R = U \\<longleftrightarrow> R = \\<top>\\<^bsub>U\\<^esub>\""}
{"gold_output": "theorem to_map_ne_zero_of_mem_nonZeroDivisors [Nontrivial R] (hM : M \u2264 nonZeroDivisors R)\n{x : R} (hx : x \u2208 nonZeroDivisors R) : algebraMap R S x \u2260 0 :=", "model_response": "lemma algebraMap_inj [intro]: \"inj (algebraMap R S)\""}
{"gold_output": "theorem measurableSet_iSup {\u03b9} {m : \u03b9 \u2192 MeasurableSpace \u03b1} {s : Set \u03b1} :\nMeasurableSet[iSup m] s \u2194 GenerateMeasurable { s : Set \u03b1 | \u2203 i, MeasurableSet[m i] s } s :=", "model_response": "lemma measurable_toNat [simp]: \"measurable toNat\""}
{"gold_output": "theorem parts_inf (P Q : Finpartition a) :\n(P \u2293 Q).parts = ((P.parts \u00d7\u02e2 Q.parts).image fun bc : \u03b1 \u00d7 \u03b1 \u21a6 bc.1 \u2293 bc.2).erase \u22a5 :=", "model_response": "lemma parts_inf_eq_image [simp]:\n\"(P \u2293 Q).parts = ((P.parts \u00d7\u02e2 Q.parts).image fun bc : \u03b1 \u00d7 \u03b1 \u21a6 bc.1 \u2293 bc.2).erase \u22a5\""}
{"gold_output": "theorem erase_single_ne {i j : \u03b9} (x : \u03b2 i) (h : i \u2260 j) : (single i x).erase j = single i x :=", "model_response": "lemma continuousWithinAt_iff_continuousAt_restrict [simp]:\n\"continuousWithinAt f s x \\<longleftrightarrow> continuousAt (s.restrict f) s x\""}
{"gold_output": "theorem comp_surjective {f : A \u2192+* B} {g : B \u2192+* C} (hf : f.FinitePresentation) (hg : Surjective g)\n(hker : g.ker.FG) : (g.comp f).FinitePresentation :=", "model_response": "theorem of_comp_toFun {f : A \u2192+* B} : of \u2218 toFun f = f :="}
{"gold_output": "theorem Gamma1_mem' (N : \u2115) (\u03b3 : Gamma0 N) : \u03b3 \u2208 Gamma1' N \u2194 (Gamma0Map N) \u03b3 = 1 :=", "model_response": "lemma bij_to_nat : \"bij_betw (to_nat) (UNIV :: Gamma0 N set) (UNIV :: \u2115 set)\""}
{"gold_output": "theorem dichotomy (b : Bool) : b = false \u2228 b = true :=", "model_response": "lemma true_eq_set : \"{a . a = true} = {true}\""}
{"gold_output": "theorem index_pos (K : PositiveCompacts G) {V : Set G} (hV : (interior V).Nonempty) :\n0 < index (K : Set G) V :=", "model_response": "theorem index_univ [simp]: \"index s univ = index s\""}
{"gold_output": "theorem coe_ofClosureMEqTopLeft (f : M \u2192 N) (hs : closure s = \u22a4) (h1 hmul) :\n\u21d1(ofClosureMEqTopLeft f hs h1 hmul) = f :=", "model_response": "lemma coe_ofClosureMEqTopLeft :\n\"(ofClosureMEqTopLeft f hs h1 hmul : M \u2192 N) = f\""}
{"gold_output": "theorem existsUnique_add_zsmul_mem_Ico {a : \u03b1} (ha : 0 < a) (b c : \u03b1) :\n\u2203! m : \u2124, b + m \u2022 a \u2208 Set.Ico c (c + a) :=", "model_response": "lemma toIcoMod_eq_iff':\n\"toIcoMod hp a b = y \u2194 \u2203 m : \u2124, y = b + m \u2022 a \u2227 m \u2208 Set.Ico (0 : \u03b1) (hp / a)\""}
{"gold_output": "theorem differentiableOn_univ : DifferentiableOn \ud835\udd5c f univ \u2194 Differentiable \ud835\udd5c f :=", "model_response": "lemma differentiableOn_eq_differentiableOn_derivWithin :\n\"f differentiableOn s = f differentiableOn {x \\<in> s. DifferentiableAt \ud835\udd5c f x}\""}
{"gold_output": "theorem lcomp\u209b\u2097_apply (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] N) (g : N \u2192\u209b\u2097[\u03c3\u2082\u2083] P) (x : M) :\nlcomp\u209b\u2097 P \u03c3\u2082\u2083 f g x = g (f x) :=", "model_response": "lemma toLinearMap_lcomp\u209b\u2097:\n\"toLinearMap.comp (lcomp\u209b\u2097 P \u03c3\u2082\u2083 f g) = lcomp\u209b\u2097 P \u03c3\u2081\u2083 (toLinearMap.comp f) (toLinearMap.comp g)\""}
{"gold_output": "theorem disjSum_mono (hs : s\u2081 \u2286 s\u2082) (ht : t\u2081 \u2286 t\u2082) : s\u2081.disjSum t\u2081 \u2286 s\u2082.disjSum t\u2082 :=", "model_response": "lemma disjSum_empty1 [simp]: \"{||}.disjSum t = {||}\""}
{"gold_output": "theorem pnatCast_one [Fact (\u2200 I : Ideal R, I \u2260 \u22a4 \u2192 CharZero (R \u29f8 I))] : ((1 : \u2115+) : R\u02e3) = 1 :=", "model_response": "lemma pnat_one_eq_one [simp]:\n\"((1 : \u2115+) : R\u02e3) = 1\""}
{"gold_output": "theorem LinearMap.toMatrix\u2082'_mul (B : (n \u2192 R) \u2192\u2097[R] (m \u2192 R) \u2192\u2097[R] R) (M : Matrix m m' R) :\ntoMatrix\u2082' B \u2b1d M = toMatrix\u2082' (B.compl\u2082 <| toLin' M) :=", "model_response": "lemma LinearMap.toMatrix\u2082'_comp (f : (n \u2192 R) \u2192\u2097[R] m \u2192 R) (g : (m' \u2192 R) \u2192\u2097[R] m \u2192 R) :\nLinearMap.toMatrix\u2082' (f.comp g) = LinearMap.toMatrix\u2082' f \u2b1d LinearMap.toMatrix\u2082' g :="}
{"gold_output": "theorem Set.Finite.isCompact_convexHull {s : Set E} (hs : s.Finite) :\nIsCompact (convexHull \u211d s) :=", "model_response": "lemma convex_hull_eq_Inter {s : Set E} (hs : s.Finite) :\nconvex hull s = \u22c2 t : { t. Convex \u211d t \u2227 s \u2286 t }, t :="}
{"gold_output": "theorem exists_linearIndependent :\n\u2203 (b : _)(_ : b \u2286 t), span K b = span K t \u2227 LinearIndependent K ((\u2191) : b \u2192 V) :=", "model_response": "lemma subset_ker_of_subset : { x \\<in> s . f x = 0 } \\<subseteq> LinearMap.ker (of s t f) :="}
{"gold_output": "theorem ordConnectedComponent_eq_empty : ordConnectedComponent s x = \u2205 \u2194 x \u2209 s :=", "model_response": "lemma ordConnectedComponent_eq_Inter:\n\"ordConnectedComponent s x = \\<Inter>{t |t. ordConnectedSection s t \\<and> x \\<in> t}\""}
{"gold_output": "theorem angle_eq_arcsin_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n(h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 \u2260 p\u2082) : \u2220 p\u2082 p\u2083 p\u2081 = Real.arcsin (dist p\u2081 p\u2082 / dist p\u2081 p\u2083) :=", "model_response": "lemma angle_eq_pi_div_two_iff_angle_eq_zero:\n\"\u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2 \\<longleftrightarrow> \u2220 p\u2082 p\u2083 p\u2081 = 0\""}
{"gold_output": "theorem LinearMap.derivWithin (hxs : UniqueDiffWithinAt \ud835\udd5c s x) :\nderivWithin e s x = e 1 :=", "model_response": "lemma derivWithin_f: \"derivWithin f s x = f' x\""}
{"gold_output": "theorem continuous_removeNth {n : \u2115} {i : Fin (n + 1)} :\nContinuous (removeNth i : Vector \u03b1 (n + 1) \u2192 Vector \u03b1 n) :=", "model_response": "lemma continuous_removeNth {n : \u2115} {i : Fin (n + 1)} :\nContinuous (removeNth i : Vector \u03b1 (n + 1) \u2192 Vector \u03b1 n) :="}
{"gold_output": "theorem Groupoid.isIsomorphic_iff_nonempty_hom {C : Type u} [Groupoid.{v} C] {X Y : C} :\nIsIsomorphic X Y \u2194 Nonempty (X \u27f6 Y) :=", "model_response": "lemma comp_id_id (X Y : C) : \ud835\udfd9 X \u226b \ud835\udfd9 Y = \ud835\udfd9 (X \u226b Y) :="}
{"gold_output": "theorem AntisymmRel.trans [IsTrans \u03b1 r] {a b c : \u03b1} (hab : AntisymmRel r a b)\n(hbc : AntisymmRel r b c) : AntisymmRel r a c :=", "model_response": "lemma antisymmRel_of_rel_of_trans:\nassumes \"trans r\"\nshows \"r a b \\<Longrightarrow> r b c \\<Longrightarrow> antisymmRel r a c\""}
{"gold_output": "theorem exists_inv_two_pow_lt (ha : a \u2260 0) : \u2203 n : \u2115, 2\u207b\u00b9 ^ n < a :=", "model_response": "lemma inv_two_pow_lt_iff : 2\u207b\u00b9 ^ n < a \u2194 2 ^ n \u2264 a :="}
{"gold_output": "theorem norm_const_eq [h : Nonempty \u03b1] (b : \u03b2) : \u2016const \u03b1 b\u2016 = \u2016b\u2016 :=", "model_response": "lemma norm_id_le: \"norm (id_blinfun : E \u2192SL[\u03c3] E) \u2264 1\""}
{"gold_output": "theorem pow_succ (a : M) (n : \u2115) : a ^ (n + 1) = a * a ^ n :=", "model_response": "lemma pow_succ_of_pos [simp]:\nassumes a0: \"0 \\<le> a\" shows \"a ^ Suc n = a * a ^ n\""}
{"gold_output": "theorem cthickening_cthickening (h\u03b5 : 0 \u2264 \u03b5) (h\u03b4 : 0 \u2264 \u03b4) (s : Set E) :\ncthickening \u03b5 (cthickening \u03b4 s) = cthickening (\u03b5 + \u03b4) s :=", "model_response": "lemma norm_indicator_cthickening_le:\n\"norm (indicator s x) \\<le> norm (indicator s y)\"\nif \"x \\<in> s\" \"y \\<in> cthickening \u03b4 s\""}
{"gold_output": "theorem eleven_dvd_iff :\n11 \u2223 n \u2194 (11 : \u2124) \u2223 ((digits 10 n).map fun n : \u2115 => (n : \u2124)).alternatingSum :=", "model_response": "lemma ofNat_one [simp]:\n\"ofNat 1 = 1\""}
{"gold_output": "theorem finrank_R [Fintype \u03c3] : FiniteDimensional.finrank K (R \u03c3 K) = Fintype.card (\u03c3 \u2192 K) :=", "model_response": "lemma card_fun_pow [simp]: \"Fintype.card (\u03c3 \u2192 K) = Fintype.card \u03c3 ^ Fintype.card K\""}
{"gold_output": "theorem prod_sum {\u03b4 : \u03b1 \u2192 Type _} [DecidableEq \u03b1] [\u2200 a, DecidableEq (\u03b4 a)] {s : Finset \u03b1}\n{t : \u2200 a, Finset (\u03b4 a)} {f : \u2200 a, \u03b4 a \u2192 \u03b2} :\n(\u220f a in s, \u2211 b in t a, f a b) = \u2211 p in s.pi t, \u220f x in s.attach, f x.1 (p x.1 x.2) :=", "model_response": "lemma summable_sum_iff_summable_prod_right:\n\"summable f \\<longleftrightarrow> summable (\\<lambda>x. \u2211'a, f a x)\""}
{"gold_output": "theorem le_induction_down {P : \u2124 \u2192 Prop} {m : \u2124} (h0 : P m)\n(h1 : \u2200 n : \u2124, n \u2264 m \u2192 P n \u2192 P (n - 1)) (n : \u2124) : n \u2264 m \u2192 P n :=", "model_response": "lemma le_induction_down[consumes 1, case_names step]:\nfixes P :: \"int \\<Rightarrow> bool\"\nassumes \"P m\"\nand     \"\\<And>n. n \\<le> m \\<Longrightarrow> P n \\<Longrightarrow> P (n - 1)\"\nand     \"n \\<le> m\"\nshows \"P n\""}
{"gold_output": "theorem cospanExt_app_right : (cospanExt iX iY iZ wf wg).app WalkingCospan.right = iY :=", "model_response": "lemma cospanExt_comp_right : \"cospanExt iX iY iZ wf wg \u226b \u03b9 arrows = iY\""}
{"gold_output": "theorem mul_le_mul_three [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n[CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 \u2264 \u00b7)] {a b c d e f : \u03b1} (h\u2081 : a \u2264 d) (h\u2082 : b \u2264 e)\n(h\u2083 : c \u2264 f) :\na * b * c \u2264 d * e * f :=", "model_response": "lemma of_nat_inj [simp]: \"of_nat n = of_nat m \\<longleftrightarrow> n = m\""}
{"gold_output": "theorem ord_aleph_isLimit (o : Ordinal) : (aleph o).ord.IsLimit :=", "model_response": "lemma card_funcset_fin (n) (\u03b1 : Type _) [Fintype \u03b1] :\n\"card (Set.functions (Fin n) \u03b1) = card \u03b1 ^ n\""}
{"gold_output": "theorem monotone_map {f : M \u2192[L] N} : Monotone (map f) :=", "model_response": "lemma (in OrderTop) monotone_map: \"monotone (map f)\""}
{"gold_output": "theorem interior_frontier {s : Set \u03b1} (h : IsClosed s) : interior (frontier s) = \u2205 :=", "model_response": "lemma interior_frontier {s : Set \u03b1} (h : IsClosed s) : interior (frontier s) = \u2205 :="}
{"gold_output": "theorem _root_.OrderIso.isBoundedUnder_le_comp [Preorder \u03b1] [Preorder \u03b2] (e : \u03b1 \u2243o \u03b2) {l : Filter \u03b3}\n{u : \u03b3 \u2192 \u03b1} : (IsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => e (u x)) \u2194 IsBoundedUnder (\u00b7 \u2264 \u00b7) l u :=", "model_response": "lemma continuous_at [simp]: \"continuous (at x) e\""}
{"gold_output": "theorem rotate'_nil (n : \u2115) : ([] : List \u03b1).rotate' n = [] :=", "model_response": "lemma continuousAt_iff_continuousAt_univ [simp]:\n\"ContinuousAt f x \u2194 ContinuousWithinAt f univ x\""}
{"gold_output": "theorem not_isUnit_X : \u00acIsUnit (X : R[X]) :=", "model_response": "lemma degree_X [simp]: \"degree (X : R[X]) = 1\""}
{"gold_output": "theorem Tendsto.mul {f : Filter \u03b1} {ma : \u03b1 \u2192 \u211d\u22650\u221e} {mb : \u03b1 \u2192 \u211d\u22650\u221e} {a b : \u211d\u22650\u221e}\n(hma : Tendsto ma f (\ud835\udcdd a)) (ha : a \u2260 0 \u2228 b \u2260 \u22a4) (hmb : Tendsto mb f (\ud835\udcdd b))\n(hb : b \u2260 0 \u2228 a \u2260 \u22a4) : Tendsto (fun a => ma a * mb a) f (\ud835\udcdd (a * b)) :=", "model_response": "lemma continuous_iff_continuous_ereal:\n\"continuous f x \\<longleftrightarrow> continuous (\\<lambda>x. ereal (f x)) x\""}
{"gold_output": "theorem range_eq_iff (f : \u03b1 \u2192 \u03b2) (s : Set \u03b2) :\nrange f = s \u2194 (\u2200 a, f a \u2208 s) \u2227 \u2200 b \u2208 s, \u2203 a, f a = b :=", "model_response": "lemma range_eq_iff: \"range f = s \u2194 (\u2200 a, f a \u2208 s) \u2227 \u2200 b \u2208 s, \u2203 a, f a = b\""}
{"gold_output": "theorem disjoint_pure_atBot [Preorder \u03b1] [NoMinOrder \u03b1] (x : \u03b1) : Disjoint (pure x) atBot :=", "model_response": "lemma Iic_disjoint_Ici [simp]: \"Disjoint (Iic a) (Ici a)\""}
{"gold_output": "theorem sign_coe_pi : (\u03c0 : Angle).sign = 0 :=", "model_response": "lemma sign_neg [simp]: \"- \u03b8 = - (\u03b8 : Angle).sign\""}
{"gold_output": "theorem Antitone.covariant_of_const' {\u03bc : N \u2192 N \u2192 N} [CovariantClass N N (swap \u03bc) (\u00b7 \u2264 \u00b7)]\n(hf : Antitone f) (m : N) : Antitone fun n \u21a6 f (\u03bc n m) :=", "model_response": "lemma antitone: \"Antitone f\""}
{"gold_output": "theorem universalHom_apply {r : R} {s : S} :\nuniversalHom f fS hf (r /\u2092 s) = f r * ((fS s)\u207b\u00b9 : Units T) :=", "model_response": "lemma universalHom_map_div :\n\"universalHom f fS hf (r /\u2092 s) = f r * ((fS s)\u207b\u00b9 : Units T)\""}
{"gold_output": "theorem prod_eq_pow_card (l : List M) (m : M) (h : \u2200 x \u2208 l, x = m) : l.prod = m ^ l.length :=", "model_response": "lemma prod_of_list_map_correct :\n\"prod_of_list (l.map toProd) = prod_of_list_map f l\""}
{"gold_output": "theorem Units.mk0_prod [CommGroupWithZero \u03b2] (s : Finset \u03b1) (f : \u03b1 \u2192 \u03b2) (h) :\nUnits.mk0 (\u220f b in s, f b) h =\n\u220f b in s.attach, Units.mk0 (f b) fun hh => h (Finset.prod_eq_zero b.2 hh) :=", "model_response": "lemma mk_prod: \"mk (\u220f b in s, f b) = \u220f b in s, mk (f b)\""}
{"gold_output": "theorem cramer_is_linear : IsLinearMap \u03b1 (cramerMap A) :=", "model_response": "lemma det_row_sum : det (updRow M i (sum a S)) = sum (fun x => det (updRow M i (a x))) S :="}
{"gold_output": "theorem comp_assoc {\u03b1 \u03b2 \u03b3 \u03b4 : TypeVec n} (h : \u03b3 \u27f9 \u03b4) (g : \u03b2 \u27f9 \u03b3) (f : \u03b1 \u27f9 \u03b2) :\n(h \u229a g) \u229a f = h \u229a g \u229a f :=", "model_response": "lemma drop_comp_cons: \"dropFun n f \u229a consFun a g = dropFun n (f \u229a g)\""}
{"gold_output": "theorem norm_iteratedFDerivWithin_mul_le {f : E \u2192 A} {g : E \u2192 A} {N : \u2115\u221e} (hf : ContDiffOn \ud835\udd5c N f s)\n(hg : ContDiffOn \ud835\udd5c N g s) (hs : UniqueDiffOn \ud835\udd5c s) {x : E} (hx : x \u2208 s) {n : \u2115}\n(hn : (n : \u2115\u221e) \u2264 N) : \u2016iteratedFDerivWithin \ud835\udd5c n (fun y => f y * g y) s x\u2016 \u2264\n\u2211 i in Finset.range (n + 1), (n.choose i : \u211d) * \u2016iteratedFDerivWithin \ud835\udd5c i f s x\u2016 *\n\u2016iteratedFDerivWithin \ud835\udd5c (n - i) g s x\u2016 :=", "model_response": "lemma norm_iteratedFDerivWithin_mul_le:\n\"norm (iteratedFDerivWithin \ud835\udd5c n (\\<lambda>y. f y * g y) s x) \\<le>\n(\\<Sum>i\\<in>{0..n}. (n.choose i : \u211d) * norm (iteratedFDerivWithin \ud835\udd5c i f s x) *\nnorm (iteratedFDerivWithin \ud835\udd5c (n - i) g s x))\""}
{"gold_output": "theorem orderOf_mul_eq_right_of_forall_prime_mul_dvd (hy : IsOfFinOrder y)\n(hdvd : \u2200 p : \u2115, p.Prime \u2192 p \u2223 orderOf x \u2192 p * orderOf x \u2223 orderOf y) :\norderOf (x * y) = orderOf y :=", "model_response": "lemma orderOf_mul_eq_right (hx : IsOfFinOrder x) (hy : IsOfFinOrder y)\n(hdvd : \u2200 p : \u2115, p.Prime \u2192 p \u2223 orderOf x \u2192 p * orderOf x \u2223 orderOf y) :\norderOf (x * y) = orderOf y :="}
{"gold_output": "theorem fst_sInf [InfSet \u03b1] [InfSet \u03b2] (s : Set (\u03b1 \u00d7 \u03b2)) : (sInf s).fst = sInf (Prod.fst '' s) :=", "model_response": "lemma fst_sSup [simp]: \"fst (sSup s) = sSup (Prod.fst '' s)\""}
{"gold_output": "theorem mk_compl_eq_mk_compl_finite {\u03b1 \u03b2 : Type u} [Finite \u03b1] {s : Set \u03b1} {t : Set \u03b2}\n(h1 : (#\u03b1) = (#\u03b2)) (h : (#s) = (#t)) : (#(s\u1d9c : Set \u03b1)) = (#(t\u1d9c : Set \u03b2)) :=", "model_response": "lemma mk_compl_eq (s : Set \u03b1) (t : Set \u03b2) (h1 : (#\u03b1) = (#\u03b2)) (h : (#s) = (#t)) :\n(#(s\u1d9c : Set \u03b1)) = (#(t\u1d9c : Set \u03b2)) :="}
{"gold_output": "theorem card_pair (a b : \u03b1) : card {a, b} = 2 :=", "model_response": "lemma mk_pairs_def (\u03b1) : \"card {(a, b) | a b. True} = (#\u03b1)^2\""}
{"gold_output": "theorem closure_coe_completion_v_lt {\u03b3 : \u0393\u2080\u02e3} :\nclosure ((\u2191) '' { x : K | v x < (\u03b3 : \u0393\u2080) }) =\n{ x : hat K | extensionValuation x < (\u03b3 : \u0393\u2080) } :=", "model_response": "lemma closure_coe_completion_v_lt (\u03b3 : \u0393\u2080\u02e3) :\nclosure ((\u2191) '' { x : K | v x < (\u03b3 : \u0393\u2080) }) =\n{ x : hat K | (v.extend hat K) x < (\u03b3 : \u0393\u2080) } :="}
{"gold_output": "theorem re_le_norm (z : K) : re z \u2264 \u2016z\u2016 :=", "model_response": "lemma norm_mul_conj_eq (x y : K) : \u2016x * conj y\u2016 = \u2016x\u2016 * \u2016y\u2016 :="}
{"gold_output": "theorem approx_of_nmem_U (c : CU X) (n : \u2115) {x : X} (hx : x \u2209 c.U) : c.approx n x = 1 :=", "model_response": "lemma toFinsupp_inj: \"toFinsupp x = toFinsupp y \\<longleftrightarrow> x = y\""}
{"gold_output": "theorem RingHom.iterate_map_frobenius (f : R \u2192+* R) (p : \u2115) [Fact p.Prime] [CharP R p] (n : \u2115) :\n(f^[n]) (frobenius R p x) = frobenius R p ((f^[n]) x) :=", "model_response": "lemma frobenius_add (x y) : frobenius R p (x + y) = frobenius R p x + frobenius R p y :="}
{"gold_output": "theorem cancel_mono_id (f : X \u27f6 Y) [Mono f] {g : X \u27f6 X} : g \u226b f = f \u2194 g = \ud835\udfd9 X :=", "model_response": "theorem inv_comp_self (f : X \u27f6 Y) [Mono f] : inv f \u226b f = \ud835\udfd9 (dom f) :="}
{"gold_output": "theorem countable : Set.Countable { x : A | IsAlgebraic R x } :=", "model_response": "theorem countable_isAlgebraic :\n\"Set.Countable { x \\<in> A. IsAlgebraic R x }\""}
{"gold_output": "theorem mul_le_right {x y : I} : x * y \u2264 y :=", "model_response": "lemma ofRealAm_add: \"ofRealAm (x + y) = ofRealAm x + ofRealAm y\""}
{"gold_output": "theorem pushoutCocone_inl :\n(pushoutCocone f g).inl = by\nletI := f.toAlgebra\nletI := g.toAlgebra\nexact Algebra.TensorProduct.includeLeft.toRingHom :=", "model_response": "lemma inl_comp_inr_pushoutCocone [simp]:\n\"pushoutCocone f g).inl \u226b (pushoutCocone f g).inr = \ud835\udfd9 _\""}
{"gold_output": "theorem dFrom_eq_zero {i : \u03b9} (h : \u00acc.Rel i (c.next i)) : C.dFrom i = 0 :=", "model_response": "lemma dFrom_comp_dFrom_next_eq_zero (i : \u03b9) (h : \u00acc.Rel i (c.next i)) :\nC.dFrom i i \u226b C.dFrom i (c.next i) = 0 :="}
{"gold_output": "theorem subsingleton_iff : Subsingleton (LieSubmodule R L M) \u2194 Subsingleton M :=", "model_response": "lemma lie_submodule_is_singleton_iff :\n\"lie_submodule.bracket I N \u2264 max_triv_submodule R L M  \\<longleftrightarrow> (\\<forall>x\\<in>I. \\<forall>m\\<in>N. \u2045x, m\u2046 = 0)\""}
{"gold_output": "theorem neg_left (x y : M\u2081) : B\u2081 (-x) y = -B\u2081 x y :=", "model_response": "lemma neg_left: \"B\u2081 (-x) y = -B\u2081 x y\""}
{"gold_output": "theorem differentiableAt_arccos {x : \u211d} : DifferentiableAt \u211d arccos x \u2194 x \u2260 -1 \u2227 x \u2260 1 :=", "model_response": "lemma arccos_eq_pi_div_two_iff {x : \u211d} : arccos x = \u03c0 / 2 \u2194 x = 0 :="}
{"gold_output": "theorem closure_empty : closure L (\u2205 : Set M) = \u22a5 :=", "model_response": "lemma closure_empty [simp]: \"closure L (\u2205 : Set M) = \u22a5\""}
{"gold_output": "theorem blimsup_cthickening_ae_eq_blimsup_thickening {p : \u2115 \u2192 Prop} {s : \u2115 \u2192 Set \u03b1} {r : \u2115 \u2192 \u211d}\n(hr : Tendsto r atTop (\ud835\udcdd 0)) (hr' : \u2200\u1da0 i in atTop, p i \u2192 0 < r i) :\n(blimsup (fun i => cthickening (r i) (s i)) atTop p : Set \u03b1) =\u1d50[\u03bc]\n(blimsup (fun i => thickening (r i) (s i)) atTop p : Set \u03b1) :=", "model_response": "lemma measure_blimsup_cthickening_eq_measure_blimsup_thickening:\n\"measure M (blimsup (\\<lambda>i. cthickening (r i) (s i)) atTop p) = measure M (blimsup (\\<lambda>i. thickening (r i) (s i)) atTop p)\""}
{"gold_output": "theorem LinearEquiv.nonempty_equiv_iff_rank_eq :\nNonempty (V \u2243\u2097[K] V\u2081) \u2194 Module.rank K V = Module.rank K V\u2081 :=", "model_response": "theorem rank_span_singleton_eq_one_iff :\nModule.rank K (K \u2219 v) = 1 \u2194 v \u2260 0 :="}
{"gold_output": "theorem nonempty_def : s.Nonempty \u2194 \u2203 x, x \u2208 s :=", "model_response": "lemma isCont_leftLim_eq_rightLim: \"isCont f x \\<longleftrightarrow> leftLim f x = rightLim f x\""}
{"gold_output": "theorem toMeasure_apply (hs : MeasurableSet s) : p.toMeasure s = \u2211' x, s.indicator p x :=", "model_response": "lemma support_eq_indicator : \"support p = {x. pmf p x \\<noteq> 0}\""}
{"gold_output": "theorem ball_eq' (y : E) (\u03b5 : \u211d) : ball y \u03b5 = { x | \u2016x / y\u2016 < \u03b5 } :=", "model_response": "lemma continuous_at_def:\n\"continuous (at x) f \\<longleftrightarrow> (\\<forall>\u03b5>0. \\<exists>\u03b4>0. \\<forall>y. norm (y - x) < \u03b4 \\<longrightarrow> norm (f y - f x) < \u03b5)\""}
{"gold_output": "theorem continuous_infNndist_pt (s : Set \u03b1) : Continuous fun x => infNndist x s :=", "model_response": "lemma continuous_infNndist_pt :\n\"continuous (infNndist x)\""}
{"gold_output": "theorem div_le_of_nonneg_of_le_mul (hb : 0 \u2264 b) (hc : 0 \u2264 c) (h : a \u2264 c * b) : a / b \u2264 c :=", "model_response": "lemma to_nat_of_nat (n : \u2115) : to_nat (of_nat n) = n :="}
{"gold_output": "theorem coe_trans (e : P\u2081 \u2243\u1d43[k] P\u2082) (e' : P\u2082 \u2243\u1d43[k] P\u2083) : \u21d1(e.trans e') = e' \u2218 e :=", "model_response": "lemma to_basis_trans_compose: \"b\u2081.to_basis.trans b\u2082.to_basis = b\u2083.to_basis\""}
{"gold_output": "theorem Convex.convex_remove_iff_not_mem_convexHull_remove {s : Set E} (hs : Convex \ud835\udd5c s) (x : E) :\nConvex \ud835\udd5c (s \\ {x}) \u2194 x \u2209 convexHull \ud835\udd5c (s \\ {x}) :=", "model_response": "lemma convex_hull_insert:\n\"convex hull (insert a s) = {a + c * b | c b. c \\<ge> 0 \\<and> c + b \\<ge> 0 \\<and> c + b \\<le> 1 \\<and> b \\<in> convex hull s}\""}
{"gold_output": "theorem closure_le {s : Set K} {t : Subfield K} : closure s \u2264 t \u2194 s \u2286 t :=", "model_response": "lemma closure_eq_top_iff: \"closure s = \u22a4 \u2194 s \u2286 carrier R\""}
{"gold_output": "theorem val_eq_zero : \u2200 {n : \u2115} (a : ZMod n), a.val = 0 \u2194 a = 0", "model_response": "lemma val_mul [simp]:\n\"(a * b : ZMod n).val = (a * b) mod n\""}
{"gold_output": "theorem summable_toNNReal_of_tsum_ne_top {\u03b1 : Type _} {f : \u03b1 \u2192 \u211d\u22650\u221e} (hf : (\u2211' i, f i) \u2260 \u221e) :\nSummable (ENNReal.toNNReal \u2218 f) :=", "model_response": "lemma isCont_toNNReal: \"isCont toNNReal x\""}
{"gold_output": "theorem add_eq_top : a + b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4 :=", "model_response": "lemma add_eq_top_iff : a + b = \u22a4 \u2194 a = \u22a4 \u2228 b = \u22a4 :="}
{"gold_output": "theorem derivedSeries_add_eq_bot {k l : \u2115} {I J : LieIdeal R L} (hI : derivedSeries R I k = \u22a5)\n(hJ : derivedSeries R J l = \u22a5) : derivedSeries R (I + J) (k + l) = \u22a5 :=", "model_response": "theorem derivedSeries_add (I J : LieIdeal R L) (hI : derivedSeries R I k = \u22a5)\n(hJ : derivedSeries R J l = \u22a5) : derivedSeries R (I + J) (k + l) = \u22a5 :="}
{"gold_output": "theorem AffineSubspace.convex (Q : AffineSubspace \ud835\udd5c E) : Convex \ud835\udd5c (Q : Set E) :=", "model_response": "lemma convex_same_ray: \"convex \ud835\udd5c { x : E | same_ray \ud835\udd5c x\u2080 x \u2227 x \u2208 Q }\""}
{"gold_output": "theorem inv_left (a : N \u22ca[\u03c6] G) : a\u207b\u00b9.left = \u03c6 a.right\u207b\u00b9 a.left\u207b\u00b9 :=", "model_response": "lemma inv_right' [simp]: \"a\u207b\u00b9.right = (a.right)\u207b\u00b9\""}
{"gold_output": "theorem stronglyMeasurable_mk (hf : AEStronglyMeasurable f \u03bc) : StronglyMeasurable (hf.mk f) :=", "model_response": "lemma measurable_mk : Measurable (mk f) :="}
{"gold_output": "theorem coeff_eq_d : P.toPoly.coeff 0 = P.d :=", "model_response": "lemma coeff_0_eq_d : \"Q.toPoly.coeff 0 = Q.d\""}
{"gold_output": "theorem of_is_bilimit' {b : BinaryBicone X Y} (h : b.IsBilimit) :\nIsPullback (0 : 0 \u27f6 X) (0 : 0 \u27f6 Y) b.inl b.inr :=", "model_response": "lemma diagonal_fst_snd (f : X \u27f6 Y) [HasPullback f f] [HasDiagonal f] :\npullback.fst \u226b diagonal f = pullback.snd \u226b diagonal f :="}
{"gold_output": "theorem iInf_ne_top_subtype (f : \u03b9 \u2192 \u03b1) : (\u2a05 i : { i // f i \u2260 \u22a4 }, f i) = \u2a05 i, f i :=", "model_response": "lemma iInf_ne_top_subtype_eq : \"iInf {i. f i \u2260 \u22a4} = \u2a05 i, f i\""}
{"gold_output": "theorem IsLeast.unique (Ha : IsLeast s a) (Hb : IsLeast s b) : a = b :=", "model_response": "lemma isCont_left_right_eq: \"isCont f x \\<longleftrightarrow> left f x = right f x\""}
{"gold_output": "theorem tsum_op : (\u2211' x, MulOpposite.op (f x)) = MulOpposite.op (\u2211' x, f x) :=", "model_response": "lemma tsum_op [simp]: \"(\\<Sum>x\\<in>s. op (f x)) = op (\u2211' x : s. f x)\""}
{"gold_output": "theorem condition_\u03c0' : kernel.lift g f w \u226b \u03c0' f g w = 0 :=", "model_response": "theorem kernel.condition : kernel.lift g f w \u226b \u03c0' f g w = 0 :="}
{"gold_output": "theorem ContinuousLinearEquiv.contDiffWithinAt_comp_iff (e : G \u2243L[\ud835\udd5c] E) :\nContDiffWithinAt \ud835\udd5c n (f \u2218 e) (e \u207b\u00b9' s) (e.symm x) \u2194 ContDiffWithinAt \ud835\udd5c n f s x :=", "model_response": "lemma contDiffWithinAt_prod_map_iff1 [simp]:\n\"(\\<lambda>x. (e x, f x)) contDiffWithinAt \ud835\udd5c n s x \\<longleftrightarrow> f contDiffWithinAt \ud835\udd5c n s x \\<and> e contDiffWithinAt \ud835\udd5c n s x\""}
{"gold_output": "theorem norm_toAdd (x) : \u2016(toAdd x : E)\u2016 = \u2016x\u2016 :=", "model_response": "lemma norm_toAdd_mul (x y) : \u2016(toAdd x * toAdd y : E)\u2016 = \u2016x\u2016 * \u2016y\u2016 :="}
{"gold_output": "theorem AnalyticAt.add (hf : AnalyticAt \ud835\udd5c f x) (hg : AnalyticAt \ud835\udd5c g x) : AnalyticAt \ud835\udd5c (f + g) x :=", "model_response": "lemma analyticAt_add_iff : (AnalyticAt \ud835\udd5c (\\<lambda>x. f x + g x) x) \\<longleftrightarrow> (AnalyticAt \ud835\udd5c f x \\<and> AnalyticAt \ud835\udd5c g x) :="}
{"gold_output": "theorem tendsto_prod_principal_iff {c : \u03b2} :\nTendsto (\u21bfF) (p \u00d7\u02e2 \ud835\udcdf s) (\ud835\udcdd c) \u2194 TendstoUniformlyOn F (fun _ => c) p s :=", "model_response": "lemma tendsto_iff_tendstoUniformlyOn_principal_univ :\n\"Tendsto (\u21bfF) (p \u00d7\u02e2 \ud835\udcdf (Set.univ)) (\ud835\udcdd c) \\<longleftrightarrow> TendstoUniformlyOn F (\\<lambda>_. c) p Set.univ\""}
{"gold_output": "theorem gramSchmidtOrthonormalBasis_inv_blockTriangular :\n((gramSchmidtOrthonormalBasis h f).toBasis.toMatrix f).BlockTriangular id :=", "model_response": "lemma gramSchmidtOrthonormalBasis_inv :\n\"Invertible ((gramSchmidtOrthonormalBasis h f).toBasis.toMatrix f)\""}
{"gold_output": "theorem mul_succ (a b : Ordinal) : a * succ b = a * b + a :=", "model_response": "lemma mul_succ_right:\nassumes \"isLimit a\"\nshows \"a * succ b = a * b + a\""}
{"gold_output": "theorem hasGroupoid_of_pregroupoid (PG : Pregroupoid H) (h : \u2200 {e e' : LocalHomeomorph M H},\ne \u2208 atlas H M \u2192 e' \u2208 atlas H M \u2192 PG.property (e.symm \u226b\u2095 e') (e.symm \u226b\u2095 e').source) :\nHasGroupoid M PG.groupoid :=", "model_response": "lemma embedding_map [simp]: \"embedding_map f\""}
{"gold_output": "theorem infty_coeFn_pow (f : lp B \u221e) (n : \u2115) : \u21d1(f ^ n) = (\u21d1f) ^ n :=", "model_response": "lemma norm_pow (f : lp B \u221e) (n : \u2115) : \u2016f ^ n\u2016 = \u2016f\u2016 ^ n :="}
{"gold_output": "theorem conjTranspose_col [Star \u03b1] (v : m \u2192 \u03b1) : (col v)\u1d34 = row (star v) :=", "model_response": "lemma col_conj_transpose [simp]:\n\"(col v)\u1d34 = row (star v)\""}
{"gold_output": "theorem Prime.even_sub_one {p : \u2115} (hp : p.Prime) (h2 : p \u2260 2) : Even (p - 1) :=", "model_response": "lemma ofNat_0 [simp]: \"ofNat 0 = 0\""}
{"gold_output": "theorem eq_of_forall_proj_eq [T2Space X] [CompactSpace X] [disc : TotallyDisconnectedSpace X]\n{x y : X} (h : \u2200 Q : DiscreteQuotient X, Q.proj x = Q.proj y) : x = y :=", "model_response": "lemma proj_inj [simp]: \"proj x = proj y \u2194 x = y\""}
{"gold_output": "theorem coe_div (r s : R) : \u2191(r / s) = (\u2191r / \u2191s : A) :=", "model_response": "lemma of_div [simp]: \"of (r / s) = of r / of s\""}
{"gold_output": "theorem zpowers_le {g : G} {H : Subgroup G} : zpowers g \u2264 H \u2194 g \u2208 H :=", "model_response": "theorem zpowers_eq_iff_mem: \"zpowers g = H \u2194 g \u2208 H\""}
{"gold_output": "theorem Iio_union_Icc_eq_Iic (h : a \u2264 b) : Iio a \u222a Icc a b = Iic b :=", "model_response": "lemma Iio_eq_Iic_iff : \"Iio a = Iic b \\<longleftrightarrow> a = b\""}
{"gold_output": "theorem fromRel_bot : fromRel (fun (x y : \u03b1) z => z : Symmetric \u22a5) = \u2205 :=", "model_response": "lemma fromRel_bot : fromRel (fun (x y : \u03b1) z => z = \u22a5) x = {x} :="}
{"gold_output": "theorem modEq_iff_toIocMod_eq_right : a \u2261 b [PMOD p] \u2194 toIocMod hp a b = a + p :=", "model_response": "lemma toIocMod_eq_toIocMod : \"toIocMod hp a b = toIocMod hp a b\""}
{"gold_output": "theorem lift_mk (f : \u03b1 \u2192 \u03b2) (c) (a : \u03b1) : lift f c (mk a) = f a :=", "model_response": "lemma lift_mk [simp]: \"lift f c (mk a) = f a\""}
{"gold_output": "theorem repr_range : LinearMap.range (b.repr : M \u2192\u2097[R] \u03b9 \u2192\u2080 R) = Finsupp.supported R R univ :=", "model_response": "lemma summable_congr: \"f summable \\<longleftrightarrow> g summable\" if \"f = g\""}
{"gold_output": "theorem noZeroDivisors_of_finite (R : Type u) (\u03c3 : Type v) [CommSemiring R] [Finite \u03c3]\n[NoZeroDivisors R] : NoZeroDivisors (MvPolynomial \u03c3 R) :=", "model_response": "theorem toFinsupp_injective : Function.Injective (toFinsupp : MvPolynomial \u03c3 R \u2192 \u03c3 \u2192\u2080 R) :="}
{"gold_output": "theorem getRight_eq_none_iff : x.getRight = none \u2194 x.isLeft :=", "model_response": "lemma card_fset_eq_zero_iff [simp]:\nshows \"card_fset xs = 0 \\<longleftrightarrow> xs = {||}\""}
{"gold_output": "theorem round_neg_two_inv : round (-2\u207b\u00b9 : \u03b1) = 0 :=", "model_response": "lemma round_one [simp]: \"round (1 : \u03b1) = 1\""}
{"gold_output": "theorem comp_eval (p : R[X]) (q : PolynomialModule R M) (r : R) :\neval r (comp p q) = eval (p.eval r) q :=", "model_response": "lemma eval_comp : \"eval x (p.comp q) = eval (eval x q) p\""}
{"gold_output": "theorem poly_binom_aux3 (f : R[X]) (x y : R) :\nf.eval (x + y) =\n((f.sum fun e a => a * x ^ e) + f.sum fun e a => a * e * x ^ (e - 1) * y) +\nf.sum fun e a => a * (polyBinomAux1 x y e a).val * y ^ 2 :=", "model_response": "lemma polyBinomAux1_altdef:\n\"polyBinomAux1 x y e a = (\\<Sum>k\\<in>{0..e}. a * x ^ (e - k) * y ^ k)\""}
{"gold_output": "theorem setToL1S_zero_left (f : \u03b1 \u2192\u2081\u209b[\u03bc] E) : setToL1S (0 : Set \u03b1 \u2192 E \u2192L[\u211d] F) f = 0 :=", "model_response": "lemma setToL1S_zero_left (f : \u03b1 \u2192\u2081\u209b[\u03bc] E) : setToL1S (0 : Set \u03b1 \u2192 E \u2192L[\u211d] F) f = 0 :="}
{"gold_output": "theorem append_right (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : \u2200 {s\u2081 s\u2082} (t), Lex r s\u2081 s\u2082 \u2192 Lex r s\u2081 (s\u2082 ++ t)", "model_response": "lemma lex_append_right :\nassumes \"Lex r s\u2081 s\u2082\"\nshows \"Lex r s\u2081 (s\u2082 ++ t)\""}
{"gold_output": "theorem image_update_Ico_right (f : \u2200 i, \u03b1 i) (i : \u03b9) (b : \u03b1 i) :\nupdate f i '' Ico (f i) b = Ico f (update f i b) :=", "model_response": "lemma image_update_Ico_right: \"update f i '' Ico (f i) b = Ico f (update f i b)\""}
{"gold_output": "theorem exists_frequently_lt_of_liminf_ne_top {\u03b9 : Type _} {l : Filter \u03b9} {x : \u03b9 \u2192 \u211d}\n(hx : liminf (fun n => (Real.nnabs (x n) : \u211d\u22650\u221e)) l \u2260 \u221e) : \u2203 R, \u2203\u1da0 n in l, x n < R :=", "model_response": "lemma continuousAt_of_real: \"continuousAt of_real x\""}
{"gold_output": "theorem toEnd_pow (x : CentroidHom \u03b1) (n : \u2115) : (x ^ n).toEnd = x.toEnd ^ n :=", "model_response": "theorem toEnd_injective: \"Function.Injective toEnd\""}
{"gold_output": "theorem multiplesHom_apply [AddMonoid A] (x : A) (n : \u2115) : multiplesHom A x n = n \u2022 x :=", "model_response": "lemma of_mul [simp]: \"of (a * b) = of a * of b\""}
{"gold_output": "theorem tendsto_atTop_add_nonneg_left' (hf : \u2200\u1da0 x in l, 0 \u2264 f x) (hg : Tendsto g l atTop) :\nTendsto (fun x => f x + g x) l atTop :=", "model_response": "lemma isLittleO_iff: \"f \\<in> o[l](g) \\<longleftrightarrow> (\\<forall>C. 0 < C \\<longrightarrow> eventually (\\<lambda>x. C \\<le> norm (f x)) l)\""}
{"gold_output": "theorem neBot_of_comap (h : (comap m g).NeBot) : g.NeBot :=", "model_response": "lemma comap_eq_map_symm : \"comap m g = map m.symm g\""}
{"gold_output": "theorem le_pow_of_le_ramificationIdx {n : \u2115} (hn : n \u2264 ramificationIdx f p P) :\nmap f p \u2264 P ^ n :=", "model_response": "lemma inj_on_pow_comap_prime_pow (n : \u2115) (h : n \u2264 ramificationIdx f p P) :\nSet.InjOn f { x | f x \u2208 p ^ n } :="}
{"gold_output": "theorem coe_toContinuousMap (f : \u03b1 \u2192CO \u03b2) : (f.toContinuousMap : \u03b1 \u2192 \u03b2) = f :=", "model_response": "lemma isCont_left_right_eq: \"isCont f x \\<longleftrightarrow> leftLim f x = rightLim f x\""}
{"gold_output": "theorem topEquiv_toMulHom :\n(topEquiv : _ \u2243* M).toMulHom = MulMemClass.subtype (\u22a4 : Subsemigroup M) :=", "model_response": "lemma toMulBot_strictMono[simp, intro]: \"StrictMono toMulBot\""}
{"gold_output": "theorem adjoin_insert_adjoin (x : E) :\nadjoin F (insert x (adjoin F S : Set E)) = adjoin F (insert x S) :=", "model_response": "lemma adjoin_sep_eq_adjoin_adjoin:\n\"{ x \\<in> adjoin F (insert x S) . p x } = adjoin F { x \\<in> S . p x }\""}
{"gold_output": "theorem types_comp {X Y Z : Type u} (f : X \u27f6 Y) (g : Y \u27f6 Z) : f \u226b g = g \u2218 f :=", "model_response": "theorem comp_id {X Y : Type u} (f : X \u27f6 Y) : \ud835\udfd9 X \u226b \ud835\udfd9 Y = \ud835\udfd9 (X \u27f6 Y) :="}
{"gold_output": "theorem _root_.IsMax.isPredLimit : IsMax a \u2192 IsPredLimit a :=", "model_response": "lemma pred_succ [simp]: \"pred (succ o) = o\""}
{"gold_output": "theorem toDfinsupp_sub [AddGroup M] (f g : \u03b9 \u2192\u2080 M) :\n(f - g).toDfinsupp = f.toDfinsupp - g.toDfinsupp :=", "model_response": "lemma support_sub [simp]: \"support (f - g) \u2286 support f \u222a support g\""}
{"gold_output": "theorem map_mk' (x) (y : S) : f.map hy k (f.mk' x y) = k.mk' (g x) \u27e8g y, hy y\u27e9 :=", "model_response": "theorem toMap_comp: \"f.toMap \u2218 g.toMap = k.toMap\""}
{"gold_output": "theorem rid_tmul (m : M) (r : R) : (TensorProduct.rid R M) (m \u2297\u209c r) = r \u2022 m :=", "model_response": "lemma rid_tmul (m : M) (r : R) : (TensorProduct.rid R M) (m \u2297\u209c r) = r \u2022 m :="}
{"gold_output": "theorem sup_sdiff_right {\u03b1 \u03b2 : Type _} [GeneralizedBooleanAlgebra \u03b1] (s : Finset \u03b2) (f : \u03b2 \u2192 \u03b1)\n(a : \u03b1) : (s.sup fun b => f b \\ a) = s.sup f \\ a :=", "model_response": "lemma sup_sdiff_right:\n\"(s.sup f) \\ a = s.sup fun b => f b \\ a\""}
{"gold_output": "theorem normSq_zero : normSq (0 : K) = 0 :=", "model_response": "lemma normSq_def: \"normSq a = (star a * a).re\""}
{"gold_output": "theorem AlgebraicIndependent.mvPolynomialOptionEquivPolynomialAdjoin_X_none\n(hx : AlgebraicIndependent R x) :\nhx.mvPolynomialOptionEquivPolynomialAdjoin (X none) = Polynomial.X :=", "model_response": "lemma toFinsupp_inj : \"toFinsupp x = toFinsupp y \\<Longrightarrow> x = y\""}
{"gold_output": "theorem coe_contLinear_eq_linear (f : P \u2192A[R] Q) :\n(f.contLinear : V \u2192\u2097[R] W) = (f : P \u2192\u1d43[R] Q).linear :=", "model_response": "lemma contLinear_linear (f : P \u2192A[R] Q) :\n(f.contLinear : V \u2192\u2097[R] W) = (f : P \u2192\u1d43[R] Q).linear :="}
{"gold_output": "theorem prod_bot_sup_bot_prod (s : Subring R) (t : Subring S) : s.prod \u22a5 \u2294 prod \u22a5 t = s.prod t :=", "model_response": "lemma prod_bot_sup_bot_prod [simp]: \"s.prod \u22a5 \u2294 prod \u22a5 t = s.prod t\""}
{"gold_output": "theorem liftAux_tprod (\u03c6 : MultilinearMap R s E) (f : \u2200 i, s i) : liftAux \u03c6 (tprod R f) = \u03c6 f :=", "model_response": "lemma liftAux_tprod (\u03c6 : MultilinearMap R s E) (f : \u2200 i, s i) : liftAux \u03c6 (tprod R f) = \u03c6 f :="}
{"gold_output": "theorem coord_toSpanNonzeroSingleton {x : E} (h : x \u2260 0) (c : \ud835\udd5c) :\ncoord \ud835\udd5c x h (toSpanNonzeroSingleton \ud835\udd5c x h c) = c :=", "model_response": "lemma coord_norm_eq_norm [simp]: \"\u2016coord \ud835\udd5c x h (toSpanNonzeroSingleton \ud835\udd5c x h c)\u2016 = \u2016c\u2016\""}
{"gold_output": "theorem card_le_one_iff_eq_bot [Fintype H] : Fintype.card H \u2264 1 \u2194 H = \u22a5 :=", "model_response": "theorem card_subgroups_le: \"card {H. Subgroup H G} \\<le> card (G :: 'a set)\""}
{"gold_output": "theorem AntivaryOn.comp_right (h : AntivaryOn f g s) (k : \u03b9' \u2192 \u03b9) :\nAntivaryOn (f \u2218 k) (g \u2218 k) (k \u207b\u00b9' s) :=", "model_response": "lemma dual_comp_commute : \"dual f \\<circ> g = f \\<circ> dual g\""}
{"gold_output": "theorem mk'_zero (s : S) : mk' f 0 s = 0 :=", "model_response": "lemma mk'_zero' (s : S) : mk' f 0 s = 0 :="}
{"gold_output": "theorem continuousAt_add_coe_coe (a b : \u211d) :\nContinuousAt (fun p : EReal \u00d7 EReal => p.1 + p.2) (a, b) :=", "model_response": "lemma continuousAt_add_ereal_ereal [continuous_intros]:\n\"continuousAt (fun p : ereal \u00d7 ereal => p.1 + p.2) (x, y)\""}
{"gold_output": "theorem HasDerivAtFilter.sub_const (hf : HasDerivAtFilter f f' x L) (c : F) :\nHasDerivAtFilter (fun x => f x - c) f' x L :=", "model_response": "lemma fderiv_sub_const (c : F) (hf : HasDerivAtFilter f f' x L) :\nHasDerivAtFilter (fun x => f x - c) f' x L :="}
{"gold_output": "theorem nndist_triangle_left (x y z : \u03b1) : nndist x y \u2264 nndist z x + nndist z y :=", "model_response": "lemma nndist_triangle_left' (x y z : \u03b1) : \"nndist x y \u2264 nndist x z + nndist y z\""}
{"gold_output": "theorem ncard_add_ncard_compl (s : Set \u03b1) (hs : s.Finite := by toFinite_tac)\n(hsc : s\u1d9c.Finite := by toFinite_tac) : s.ncard + s\u1d9c.ncard = Nat.card \u03b1 :=", "model_response": "lemma ncard_univ : (#(UNIV : Set \u2115)) = \u2135\u2080 :="}
{"gold_output": "theorem forall_or_of_or_forall (h : b \u2228 \u2200 x, p x) (x) : b \u2228 p x :=", "model_response": "lemma forall_or_of_or_forall_left :\nassumes \"b \\<or> (\\<forall>x. p x)\"\nshows \"(\\<forall>x. b \\<or> p x)\""}
{"gold_output": "theorem col_strict {\u03bc : YoungDiagram} (T : Ssyt \u03bc) {i1 i2 j : \u2115} (hi : i1 < i2)\n(hcell : (i2, j) \u2208 \u03bc) : T i1 j < T i2 j :=", "model_response": "lemma col_lt_of_lt_row_length:\nassumes \"i1 < i2\" \"(i2, j) \\<in> cells \\<mu>\"\nshows \"T i1 j < T i2 j\""}
{"gold_output": "theorem sizeUpTo_le (i : \u2115) : c.sizeUpTo i \u2264 n :=", "model_response": "lemma monotone_sizeUpTo [simp]: \"i \\<le> j \\<Longrightarrow> c.sizeUpTo i \\<le> c.sizeUpTo j\""}
{"gold_output": "theorem intCoe_one [AddGroupWithOne R] : ((1 : ArithmeticFunction \u2124) :\nArithmeticFunction R) = 1 :=", "model_response": "lemma intCoe_one [simp]: \"(1 : ArithmeticFunction \u2124) = (1 : ArithmeticFunction R)\""}
{"gold_output": "theorem noncommPiCoprod_mulSingle (i : \u03b9) (y : N i) :\nnoncommPiCoprod \u03d5 hcomm (Pi.mulSingle i y) = \u03d5 i y :=", "model_response": "lemma noncommPiCoprod_mulSingle_apply [simp]:\n\"noncommPiCoprod \u03d5 hcomm (Pi.mulSingle i y) = \u03d5 i y\""}
{"gold_output": "theorem constantCoeff_inv (\u03c6 : PowerSeries k) : constantCoeff k \u03c6\u207b\u00b9 = (constantCoeff k \u03c6)\u207b\u00b9 :=", "model_response": "lemma constantCoeff_inv [simp]:\n\"constantCoeff k \u03c6\u207b\u00b9 = (constantCoeff k \u03c6)\u207b\u00b9\""}
{"gold_output": "theorem refl_apply (x : M) : refl L M x = x :=", "model_response": "lemma refl_apply [simp]:\n\"refl L M x = x\""}
{"gold_output": "theorem limLax_map {F G : J \u2964 C} (\u03b1 : F \u27f6 G) : limLax.map \u03b1 = lim.map \u03b1 :=", "model_response": "lemma lim_cone_commutes:\n\"lim.\u03c0 _ j \u226b lim.\u03c0 _ i = lim.\u03c0 _ i \u226b lim.\u03c0 _ j\""}
{"gold_output": "theorem filter_image_quotient_mk''_isDiag [DecidableEq \u03b1] (s : Finset \u03b1) :\n((s \u00d7\u02e2 s).image Quotient.mk'').filter IsDiag = s.diag.image Quotient.mk'' :=", "model_response": "lemma image_mk''_diag [simp]: \"Quotient.mk'' ` s.diag = (Quotient.mk'' ` s).diag\""}
{"gold_output": "theorem Fix.ind_aux (a : q.P.A) (f : q.P.B a \u2192 q.P.W) :\nFix.mk (abs \u27e8a, fun x => \u27e6f x\u27e7\u27e9) = \u27e6\u27e8a, f\u27e9\u27e7 :=", "model_response": "lemma Fix.ind_rec:\nfixes f :: \"q.P.B a \\<rightarrow> q.P.W\" and a :: \"q.P.A\"\nassumes \"\\<And>a f. f a = Fix.mk (abs \u27e8a, fun x => \u27e6f x\u27e7\u27e9)\"\nshows \"f a = Fix.mk (abs \u27e8a, fun x => \u27e6f x\u27e7\u27e9)\""}
{"gold_output": "theorem MeasurableSet.pi {s : Set \u03b4} {t : \u2200 i : \u03b4, Set (\u03c0 i)} (hs : s.Countable)\n(ht : \u2200 i \u2208 s, MeasurableSet (t i)) : MeasurableSet (s.pi t) :=", "model_response": "lemma measurable_pi_iff:\n\"Measurable.measurable (PiM I M) f \\<longleftrightarrow> (\\<forall>i\\<in>I. Measurable.measurable (M i) (\\<lambda>x. f x i))\""}
{"gold_output": "theorem map_comp_eq (F : E \u2964 D) (G : D \u2964 C) : map (F \u22d9 G) = map F \u22d9 map G :=", "model_response": "lemma toStructuredArrow_comp:\n\"toStructuredArrow F \u22d9 toStructuredArrow G = toStructuredArrow (F \u22d9 G)\""}
{"gold_output": "theorem indicator_ae_eq_restrict (hs : MeasurableSet s) : indicator s f =\u1d50[\u03bc.restrict s] f :=", "model_response": "lemma measurable_indicator' [measurable]:\n\"indicator \\<in> measurable (s :: 'a set) (b :: 'a \\<Rightarrow> ('b :: {topological_space, zero}))\""}
{"gold_output": "theorem toSubmonoid_injective : Function.Injective (toSubmonoid : Subgroup G \u2192 Submonoid G) :=\n-- fun p q h => SetLike.ext'_iff.2 (show _ from SetLike.ext'_iff.1 h)", "model_response": "theorem toSubmonoid_injective :\n\"Function.Injective (toSubmonoid : Subgroup G \u2192 Submonoid G)\"\n\\<comment> \\<open>The proof of this theorem is not shown here.\\<close>"}
{"gold_output": "theorem measurable_of_Iio {f : \u03b4 \u2192 \u03b1} (hf : \u2200 x, MeasurableSet (f \u207b\u00b9' Iio x)) : Measurable f :=", "model_response": "lemma measurable: \"Measurable f\""}
{"gold_output": "theorem exists_nnreal_pos_mul_lt (ha : a \u2260 \u221e) (hb : b \u2260 0) : \u2203 n > 0, \u2191(n : \u211d\u22650) * a < b :=", "model_response": "lemma continuousAt_toReal: \"continuousAt toReal x\""}
{"gold_output": "theorem card_pow_div_pow_le (hA : A.Nonempty) (B : Finset \u03b1) (m n : \u2115) :\n((B ^ m / B ^ n).card) \u2264 ((A * B).card / A.card : \u211a\u22650) ^ (m + n) * A.card :=", "model_response": "lemma card_pow_div_pow_le (hA : A.Nonempty) (B : Finset \u03b1) (m n : \u2115) :\n(B ^ m / B ^ n).card = ((A * B).card / A.card : \u211a\u22650) ^ (m + n) * A.card :="}
{"gold_output": "theorem Iic_bot [PartialOrder \u03b1] [OrderBot \u03b1] : Iic (\u22a5 : \u03b1) = {\u22a5} :=", "model_response": "lemma Iic_bot [simp]: \"Iic a = {\u22a5}\""}
{"gold_output": "theorem eval_singleton (a : \u03b1) : M.eval [a] = M.step M.start a :=", "model_response": "lemma eval_eq_foldl : \"M.eval as = List.foldl M.step M.start as\""}
{"gold_output": "theorem ContinuousLinearMap.integrable_comp {\u03c6 : \u03b1 \u2192 H} (L : H \u2192L[\ud835\udd5c] E) (\u03c6_int : Integrable \u03c6 \u03bc) :\nIntegrable (fun a : \u03b1 => L (\u03c6 a)) \u03bc :=", "model_response": "lemma integral_comp_comm (L : H \u2192L[\ud835\udd5c] E) (\u03c6_int : Integrable \u03c6 \u03bc) :\n(\u222b a : \u03b1, L (\u03c6 a) \u2202\u03bc) = L (\u222b a : \u03b1, \u03c6 a \u2202\u03bc) :="}
{"gold_output": "theorem binomial_one [DecidableEq \u03b1] (h : a \u2260 b) (h\u2081 : f a = 1) :\nmultinomial {a, b} f = (f b).succ :=", "model_response": "lemma binomial_two [simp]: \"multinomial {a, b} f = (f b).succ\" if \"a \\<noteq> b\" \"f a = 1\""}
{"gold_output": "theorem continuousWithinAt_const_smul_iff (hc : IsUnit c) :\nContinuousWithinAt (fun x => c \u2022 f x) s b \u2194 ContinuousWithinAt f s b :=", "model_response": "lemma continuousWithinAt_smul_const_iff' [simp]:\n\"continuousWithinAt (\\<lambda>x. c \u2022 f x) s b \\<longleftrightarrow> continuousWithinAt f s b\" if \"c \\<in> G\""}
{"gold_output": "theorem HasSubset.Subset.eventuallyLE {\u03b1} {l : Filter \u03b1} {s t : Set \u03b1} (h : s \u2286 t) : s \u2264\u1da0[l] t :=", "model_response": "lemma eventually_mono_filter:\nassumes \"s \\<subseteq> t\"\nshows \"eventually (\\<lambda>x. x \\<in> s \\<longrightarrow> x \\<in> t) l\""}
{"gold_output": "theorem rtake_nil : rtake ([] : List \u03b1) n = [] :=", "model_response": "lemma rtake_eq_nil_of_le_length:\nassumes \"n \\<le> length l\"\nshows \"rtake l n = []\""}
{"gold_output": "theorem finprod_mem_comm {s : Set \u03b1} {t : Set \u03b2} (f : \u03b1 \u2192 \u03b2 \u2192 M) (hs : s.Finite) (ht : t.Finite) :\n(\u220f\u1da0 i \u2208 s, \u220f\u1da0 j \u2208 t, f i j) = \u220f\u1da0 j \u2208 t, \u220f\u1da0 i \u2208 s, f i j :=", "model_response": "lemma summable_norm_iff: \"summable (\\<lambda>x. norm (f x)) \\<longleftrightarrow> summable f\""}
{"gold_output": "theorem finrank_span_le_card (s : Set V) [Fintype s] : finrank K (span K s) \u2264 s.toFinset.card :=", "model_response": "lemma card_finfun_of_fin_n [simp]:\n\"card (finfun_of_fin (n :: nat) \\<alpha>) = card \\<alpha> ^ n\""}
{"gold_output": "theorem commutatorElement_one_left : \u2045(1 : G), g\u2046 = 1 :=", "model_response": "lemma commutatorElement_one_left [simp]: \"\u2045(1 : G), g\u2046 = 1\""}
{"gold_output": "theorem isBigOWith_self_const_mul (c : \ud835\udd5c) (hc : c \u2260 0) (f : \u03b1 \u2192 \ud835\udd5c) (l : Filter \u03b1) :\nIsBigOWith \u2016c\u2016\u207b\u00b9 l f fun x => c * f x :=", "model_response": "lemma isBigOWith_self_const_mul: \"isBigOWith \u2016c\u2016\u207b\u00b9 l f (\\<lambda>x. c * f x)\""}
{"gold_output": "theorem snorm'_const_smul {f : \u03b1 \u2192 F} (c : \ud835\udd5c) (hq_pos : 0 < q) :\nsnorm' (c \u2022 f) q \u03bc = \u2016c\u2016\u208a \u2022 snorm' f q \u03bc :=", "model_response": "lemma snorm'_zero [simp]: \"snorm' (0 : \u03b1 \u2192 F) q \u03bc = 0\""}
{"gold_output": "theorem isLowerSet_iff_Iio_subset : IsLowerSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Iio a \u2286 s :=", "model_response": "lemma Iic_sSup_eq_iUnion: \"{.. sSup S} = \u22c3 a \u2208 S, {.. a}\""}
{"gold_output": "theorem tendsto_iff_forall_eventually_mem {x : \u03b9 \u2192 \u03b1} {f : Filter \u03b1} {l : Filter \u03b9} :\nTendsto x l f \u2194 \u2200 s \u2208 f, \u2200\u1da0 n in l, x n \u2208 s :=", "model_response": "lemma continuous_at_def:\n\"continuous (at a) f \\<longleftrightarrow> (\\<forall>s. s \\<in> f a \\<longrightarrow> (\\<exists>t. a \\<in> t \\<and> t \\<in> at a \\<and> (\\<forall>x\\<in>t. f x \\<in> s)))\""}
{"gold_output": "theorem T_two : T R 2 = 2 * X ^ 2 - 1 :=", "model_response": "lemma T_one : \"T R 1 = X\""}
{"gold_output": "theorem Chain'.infix (h : Chain' R l) (h' : l\u2081 <:+: l) : Chain' R l\u2081 :=", "model_response": "lemma chain'_prefix:\nassumes \"chain' R l\" and \"l\\<^sub>1 \\<preceq>+: l\"\nshows \"chain' R l\\<^sub>1\""}
{"gold_output": "theorem dotProduct_eq (v w : n \u2192 R) (h : \u2200 u, dotProduct v u = dotProduct w u) : v = w :=", "model_response": "lemma dotProduct_zero_right [simp]: \"v \u2b1d\u1d65 (\\<lambda>i. 0) = 0\""}
{"gold_output": "theorem swap (hs : IsAntichain r s) : IsAntichain (swap r) s :=", "model_response": "lemma swap_setOf_eq : {x. (swap r) x y} = {x. r x y} :="}
{"gold_output": "theorem mem_nhds_toTopsp (F : Ctop \u03b1 \u03c3) {s : Set \u03b1} {a : \u03b1} :\ns \u2208 @nhds _ F.toTopsp a \u2194 \u2203 b, a \u2208 F b \u2227 F b \u2286 s :=", "model_response": "lemma continuousAt_def:\nfixes f :: \"'a::topologicalSpace \\<Rightarrow> 'b::topologicalSpace\"\nshows \"continuousAt f a = (\\<forall>s. IsOpen s \\<longrightarrow> a \\<in> s \\<longrightarrow> IsOpen (f ` s))\""}
{"gold_output": "theorem optionSubtype_apply_apply\n[DecidableEq \u03b2] (x : \u03b2)\n(e : { e : Option \u03b1 \u2243 \u03b2 // e none = x })\n(a : \u03b1)\n(h) : optionSubtype x e a = \u27e8(e : Option \u03b1 \u2243 \u03b2) a, h\u27e9 :=", "model_response": "lemma optionSubtype_apply [simp]:\n\"optionSubtype x e a = (e a, h)\""}
{"gold_output": "theorem properDivisors_one : properDivisors 1 = \u2205 :=", "model_response": "lemma properDivisors_one :\n\"properDivisors 1 = {}\""}
{"gold_output": "theorem _root_.aemeasurable_union_iff {s t : Set \u03b1} :\nAEMeasurable f (\u03bc.restrict (s \u222a t)) \u2194\nAEMeasurable f (\u03bc.restrict s) \u2227 AEMeasurable f (\u03bc.restrict t) :=", "model_response": "lemma aemeasurable_union_iff:\n\"AEMeasurable f (\u03bc.restrict (s \u222a t)) \u2194 AEMeasurable f (\u03bc.restrict s) \u2227 AEMeasurable f (\u03bc.restrict t)\""}
{"gold_output": "theorem tangentCone_mono (h : s \u2286 t) : tangentConeAt \ud835\udd5c s x \u2286 tangentConeAt \ud835\udd5c t x :=", "model_response": "lemma tangent_cone_subset_tangent_cone_univ :\n\"tangentConeAt \ud835\udd5c s x \\<subseteq> tangentConeAt \ud835\udd5c Univ x\""}
{"gold_output": "theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=", "model_response": "lemma fst_prodMap : \"fst R S \\<circ> (prodMap f g) = f\""}
{"gold_output": "theorem TopCat.Presheaf.isSheaf_of_openEmbedding (h : OpenEmbedding f) (hF : F.IsSheaf) :\nIsSheaf (h.isOpenMap.functor.op \u22d9 F) :=", "model_response": "lemma functor_comp_eq_comp_functor_op (I : f <$> op \u22d9 F) :\nI.functor.op \u22d9 F = F \u22d9 functor_op (Opens.map_functor f) :="}
{"gold_output": "theorem choose_spec (hp : \u2203! a, a \u2208 l \u2227 p a) : choose p l hp \u2208 l \u2227 p (choose p l hp) :=", "model_response": "lemma choose_spec_unique :\nassumes \"\\<exists>! a. a \\<in> l \\<and> p a\"\nshows \"choose p l (Existential.exists_unique p l) = choose p (filter p l) (Existential.exists_unique p (filter p l))\""}
{"gold_output": "theorem op_norm_eq_of_bounds {\u03c6 : E \u2192SL[\u03c3\u2081\u2082] F} {M : \u211d} (M_nonneg : 0 \u2264 M)\n(h_above : \u2200 x, \u2016\u03c6 x\u2016 \u2264 M * \u2016x\u2016) (h_below : \u2200 N \u2265 0, (\u2200 x, \u2016\u03c6 x\u2016 \u2264 N * \u2016x\u2016) \u2192 M \u2264 N) :\n\u2016\u03c6\u2016 = M :=", "model_response": "lemma norm_inv_blinmap:\nassumes \"f : E \u2192SL[\u03c3\u2081\u2082] F\"\nassumes \"0 \\<le> M\"\nassumes \"\\<And>x. \u2016f x\u2016 \u2264 M * \u2016x\u2016\"\nassumes \"\\<And>N. 0 \u2264 N \\<Longrightarrow> (\\<And>x. \u2016f x\u2016 \u2264 N * \u2016x\u2016) \\<Longrightarrow> M \u2264 N\"\nshows \"\u2016f\u207b\u00b9\u2016 = 1 / \u2016f\u2016\""}
{"gold_output": "theorem quot_mk_eq_\u03b9 (m : X) : Quot.mk (FreeAlgebra.Rel R X) m = \u03b9 R m :=", "model_response": "theorem \u03b9_surjective:\n\"Function.Surjective (\u03b9 R)\""}
{"gold_output": "theorem Antivary.sum_smul_le_sum_comp_perm_smul (hfg : Antivary f g) :\n(\u2211 i, f i \u2022 g i) \u2264 \u2211 i, f (\u03c3 i) \u2022 g i :=", "model_response": "theorem sum_smul_le_sum_comp_perm_smul:\n\"(\u2211 i, f i \u2022 g i) \u2264 \u2211 i, f (\u03c3 i) \u2022 g i\""}
{"gold_output": "theorem le_map_of_right_inverse {mab : \u03b1 \u2192 \u03b2} {mba : \u03b2 \u2192 \u03b1} {f : Filter \u03b1} {g : Filter \u03b2}\n(h\u2081 : mab \u2218 mba =\u1da0[g] id) (h\u2082 : Tendsto mba g f) : g \u2264 map mab f :=", "model_response": "lemma tendsto_iff_right_inverse:\n\"mab \\<midarrow>g\\<rightarrow> f \\<longleftrightarrow> (mab \\<circ> mba) \\<midarrow>g\\<rightarrow> id\""}
{"gold_output": "theorem LinearMap.toMatrix_one : LinearMap.toMatrix v\u2081 v\u2081 1 = 1 :=", "model_response": "lemma LinearMap.toMatrix_one'[simp]: \"LinearMap.toMatrix b b 1 = 1\""}
{"gold_output": "theorem card_fintypeIio : Fintype.card (Set.Iio b) = b :=", "model_response": "lemma card_fintypeIic_eq: \"Fintype.card (Set.Iic b) = succ b\""}
{"gold_output": "theorem le_add_right (s t : Multiset \u03b1) : s \u2264 s + t :=", "model_response": "lemma to_nat_add: \"to_nat (s + t) = to_nat s + to_nat t\""}
{"gold_output": "theorem integral_comp_mul_left (hc : c \u2260 0) :\n(\u222b x in a..b, f (c * x)) = c\u207b\u00b9 \u2022 \u222b x in c * a..c * b, f x :=", "model_response": "lemma integral_comp_mul_left' (hc : c \u2260 0) :\n(\u222b x in a..b, f (c * x)) = c\u207b\u00b9 \u2022 \u222b x in c * a..c * b, f x :="}
{"gold_output": "theorem ne_zero {a b c : \u2124} (h : Fermat42 a b c) : c \u2260 0 :=", "model_response": "theorem infinite_solutions_fermat42 :\n{ (x, y) | x y. Fermat42 x y }.Infinite :="}
{"gold_output": "theorem pullbackConeOfLeftIso_snd : (pullbackConeOfLeftIso f g).snd = \ud835\udfd9 _ :=", "model_response": "lemma pullback_snd_fst : pullback.snd \u226b pullback.fst = pullback.fst \u226b pullback.snd :="}
{"gold_output": "theorem iterate_eq_of_map_eq (h : Commute f g) (n : \u2115) {x} (hx : f x = g x) :\n(f^[n]) x = (g^[n]) x :=", "model_response": "lemma periodic_iff' (h : Commute f g) (n : \u2115) : Periodic f n \u2194 Periodic g n :="}
{"gold_output": "theorem nodup_roots {p : R[X]} (hsep : Separable p) : p.roots.Nodup :=", "model_response": "lemma degree_eq_zero_iff {p : R[X]} : degree p = 0 \u2194 p = 0 :="}
{"gold_output": "theorem map_prod_eq_map_prod [FreimanHomClass F A \u03b2 n] (f : F) {s t : Multiset \u03b1}\n(hsA : \u2200 \u2983x\u2984, x \u2208 s \u2192 x \u2208 A) (htA : \u2200 \u2983x\u2984, x \u2208 t \u2192 x \u2208 A)\n(hs : Multiset.card s = n) (ht : Multiset.card t = n)\n(h : s.prod = t.prod) : (s.map f).prod = (t.map f).prod :=", "model_response": "lemma inj_on_coe_iff [simp]: \"inj_on f (s : Set _) \u2194 (s : Multiset _).InjOn f\""}
{"gold_output": "theorem coeff_rename_mapDomain (f : \u03c3 \u2192 \u03c4) (hf : Injective f) (\u03c6 : MvPolynomial \u03c3 R) (d : \u03c3 \u2192\u2080 \u2115) :\n(rename f \u03c6).coeff (d.mapDomain f) = \u03c6.coeff d :=", "model_response": "lemma coeff_C_mul (a : R) (\u03c6 : MvPolynomial \u03c3 R) (d : \u03c3 \u2192\u2080 \u2115) :\n(C a * \u03c6).coeff d = a * \u03c6.coeff d :="}
{"gold_output": "theorem IsRoot.dvd {R : Type _} [CommSemiring R] {p q : R[X]} {x : R} (h : p.IsRoot x)\n(hpq : p \u2223 q) : q.IsRoot x :=", "model_response": "lemma degree_div_le (p q : R[X]) (x : R) (hp : p.IsRoot x) (hpq : p \u2223 q) :\ndegree (p / q) \u2264 degree p :="}
{"gold_output": "theorem domLCongr_single {\u03b1\u2081 : Type _} {\u03b1\u2082 : Type _} (e : \u03b1\u2081 \u2243 \u03b1\u2082) (i : \u03b1\u2081) (m : M) :\n(Finsupp.domLCongr e : _ \u2243\u2097[R] _) (Finsupp.single i m) = Finsupp.single (e i) m :=", "model_response": "lemma inj_domLCongr_iff [simp]:\n\"Injective (Finsupp.domLCongr e f) \u2194 Injective f\""}
{"gold_output": "theorem coe_subtype : (SubmonoidClass.Subtype S' : S' \u2192 M) = Subtype.val :=", "model_response": "lemma strictMonoOn_iff_lt:\n\"strictMonoOn f s \\<longleftrightarrow> (\\<forall>x\\<in>s. \\<forall>y\\<in>s. x < y \\<longrightarrow> f x < f y)\""}
{"gold_output": "theorem SL2_inv_expl (A : SL(2, R)) :\nA\u207b\u00b9 = \u27e8![![A.1 1 1, -A.1 0 1], ![-A.1 1 0, A.1 0 0]], SL2_inv_expl_det A\u27e9 :=", "model_response": "lemma det_A_nonzero : \"det (A :: real ^ 2 ^ 2) \u2260 0\""}
{"gold_output": "theorem fixedPoints_id : fixedPoints (@id \u03b1) = Set.univ :=", "model_response": "lemma fixedPoints_id : \"fixedPoints (id :: 'a set \\<Rightarrow> 'a set) = Set.univ\""}
{"gold_output": "theorem OrthogonalFamily.isInternal_iff_of_isComplete [DecidableEq \u03b9] {V : \u03b9 \u2192 Submodule \ud835\udd5c E}\n(hV : OrthogonalFamily \ud835\udd5c (fun i => V i) fun i => (V i).subtype\u2097\u1d62)\n(hc : IsComplete (\u2191(iSup V) : Set E)) : DirectSum.IsInternal V \u2194 (iSup V)\u15ee = \u22a5 :=", "model_response": "lemma toSpanSingleton_injective : Injective toSpanSingleton :="}
{"gold_output": "theorem natDegree_cancelLeads_lt_of_natDegree_le_natDegree (h : p.natDegree \u2264 q.natDegree)\n(hq : 0 < q.natDegree) : (p.cancelLeads q).natDegree < q.natDegree :=", "model_response": "lemma natDegree_cancelLeads_lt [simp]:\nassumes \"p.natDegree \\<le> q.natDegree\" and \"0 < q.natDegree\"\nshows \"(p.cancelLeads q).natDegree < q.natDegree\""}
{"gold_output": "theorem isGreatest_Ioc (h : a < b) : IsGreatest (Ioc a b) b :=", "model_response": "lemma toIcoMod_eq_self_iff:\n'toIcoMod hp a b = b  \\<longleftrightarrow> b \\<in> Ico a (a + p)'"}
{"gold_output": "theorem cast_mono : Monotone ((\u2191) : \u211a \u2192 K) :=", "model_response": "lemma ofRealAm_eq_ofReal: \"ofRealAm = ofReal\""}
{"gold_output": "theorem pumping_lemma [Fintype \u03c3] {x : List \u03b1} (hx : x \u2208 M.accepts)\n(hlen : Fintype.card \u03c3 \u2264 List.length x) :\n\u2203 a b c,\nx = a ++ b ++ c \u2227\na.length + b.length \u2264 Fintype.card \u03c3 \u2227 b \u2260 [] \u2227 {a} * {b}\u2217 * {c} \u2264 M.accepts :=", "model_response": "lemma lists_eq_powerset : \"lists \\<Sigma> = Pow (UNIV::'a set)\""}
{"gold_output": "theorem coe_toHom {f : M \u21aa[L] N} : (f.toHom : M \u2192 N) = f :=", "model_response": "lemma injective_toHom (f : M \u21aa[L] N) : (f.toHom : M \u2192 N) = f :="}
{"gold_output": "theorem NeBot.of_mul_left : (f * g).NeBot \u2192 f.NeBot :=", "model_response": "lemma measurable_set_const [measurable]:\n\"{x. x = a} \\<in> sets (trivial_sigma \\<Omega>)\""}
{"gold_output": "theorem Filter.Tendsto.mul {f g : \u03b1 \u2192 M} {x : Filter \u03b1} {a b : M} (hf : Tendsto f x (\ud835\udcdd a))\n(hg : Tendsto g x (\ud835\udcdd b)) : Tendsto (fun x => f x * g x) x (\ud835\udcdd (a * b)) :=", "model_response": "lemma tendsto_mul' [tendsto_intros]: \"((\\<lambda>x. f x * g x) \\<longlongrightarrow> a * b) x\" if \"(f \\<longlongrightarrow> a) x\" \"(g \\<longlongrightarrow> b) x\""}
{"gold_output": "theorem norm_self_mul_star {x : E} : \u2016x * x\u22c6\u2016 = \u2016x\u2016 * \u2016x\u2016 :=", "model_response": "lemma norm_self_mul_star: \"norm (x * x\u22c6) = norm x * norm x\""}
{"gold_output": "theorem cast_strictMono [OrderedRing \u03b1] [Nontrivial \u03b1] : StrictMono (fun x : \u2124 => (x : \u03b1)) :=", "model_response": "lemma strictMono_of_int [simp]: \"StrictMono of_int\""}
{"gold_output": "theorem surjOn_sUnion {s : Set \u03b1} {T : Set (Set \u03b2)} {f : \u03b1 \u2192 \u03b2} (H : \u2200 t \u2208 T, SurjOn f s t) :\nSurjOn f s (\u22c3\u2080T) :=", "model_response": "lemma surjOn_sUnion:\n\"surjOn f s (\\<Union>T) \\<longleftrightarrow> (\\<forall>y \\<in> \\<Union>T. \\<exists>x \\<in> s. f x = y)\""}
{"gold_output": "theorem smul_mem_smul : a \u2208 s \u2192 b \u2208 t \u2192 a \u2022 b \u2208 s \u2022 t :=", "model_response": "lemma continuous_on_iff_prod_self:\n\"continuous_on s f \\<longleftrightarrow> continuous_on s (\\<lambda>x. (f x, f x))\""}
{"gold_output": "theorem isMax_toDual_iff : IsMax (toDual a) \u2194 IsMin a :=", "model_response": "lemma isMax_toDual_iff :\n\"isMax (toDual a) (mkLess le_of_dual) \\<longleftrightarrow> isMin a\""}
{"gold_output": "theorem Icc_diff_both : Icc a b \\ {a, b} = Ioo a b :=", "model_response": "lemma Icc_diff_both_eq_Ioo : {x. a < x \\<and> x < b} = Ioo a b :="}
{"gold_output": "theorem prod_eq_biUnion_left : s \u00d7\u02e2 t = \u22c3 a \u2208 s, (fun b => (a, b)) '' t :=", "model_response": "lemma inj_on_to_nat : \"inj_on to_nat s\""}
{"gold_output": "theorem AffineMap.lineMap_mem_affineSpan_pair (r : k) (p\u2081 p\u2082 : P) :\nAffineMap.lineMap p\u2081 p\u2082 r \u2208 line[k, p\u2081, p\u2082] :=", "model_response": "lemma lineMap_eq_line: \"AffineMap.lineMap p\u2081 p\u2082 r = line[k, p\u2081, p\u2082] r\""}
{"gold_output": "theorem exists_partition_polynomial_aux (n : \u2115) {\u03b5 : \u211d} (h\u03b5 : 0 < \u03b5) {b : Fq[X]} (hb : b \u2260 0)\n(A : Fin n \u2192 Fq[X]) : \u2203 t : Fin n \u2192 Fin (Fintype.card Fq ^ \u2308-log \u03b5 / log (Fintype.card Fq)\u2309\u208a),\n\u2200 i\u2080 i\u2081 : Fin n, t i\u2080 = t i\u2081 \u2194\n(cardPowDegree (A i\u2081 % b - A i\u2080 % b) : \u211d) < cardPowDegree b \u2022 \u03b5 :=", "model_response": "lemma toFun_mult' [simp]:\n\"toFun (a * b) = toFun a * toFun b\""}
{"gold_output": "theorem mem_iSup_of_chain (a : \u2115 \u2192o Submodule R M) (m : M) : (m \u2208 \u2a06 k, a k) \u2194 \u2203 k, m \u2208 a k :=", "model_response": "lemma mono_f: \"mono f\""}
{"gold_output": "theorem rightInverse_bijInv (f_bij : Bijective f) : RightInverse (bijInv f_bij) f :=", "model_response": "lemma rightInverse_bijInv : \"RightInverse (bijInv f) f\""}
{"gold_output": "theorem zero_lf_le {x : PGame} : 0 \u29cf x \u2194 \u2203 i, 0 \u2264 x.moveLeft i :=", "model_response": "lemma finite_moveLefts {x : PGame} : (finite (x.moveLefts x)) :="}
{"gold_output": "theorem exists_ne_map_eq_of_ncard_lt_of_maps_to {t : Set \u03b2} (hc : t.ncard < s.ncard) {f : \u03b1 \u2192 \u03b2}\n(hf : \u2200 a \u2208 s, f a \u2208 t) (ht : t.Finite := by toFinite_tac) :\n\u2203 x \u2208 s, \u2203 y \u2208 s, x \u2260 y \u2227 f x = f y :=", "model_response": "lemma card_funcset_eq_power :\n\"card (s \\<rightarrow>\\<^sub>E t) = t.ncard ^ s.ncard\""}
{"gold_output": "theorem coe_trans (e\u2081 : A\u2081 \u2243\u2090[R] A\u2082) (e\u2082 : A\u2082 \u2243\u2090[R] A\u2083) : \u21d1(e\u2081.trans e\u2082) = e\u2082 \u2218 e\u2081 :=", "model_response": "lemma trans_symm_commute: \"(e\u2081.trans e\u2082).symm = e\u2082.symm.trans e\u2081.symm\""}
{"gold_output": "theorem coeff_invUnitsSub (u : R\u02e3) (n : \u2115) : coeff R n (invUnitsSub u) = 1 /\u209a u ^ (n + 1) :=", "model_response": "lemma coeff_invUnitsSub (u : R\u02e3) (n : \u2115) : coeff R n (invUnitsSub u) = 1 /\u209a u ^ (n + 1) :="}
{"gold_output": "theorem one_le_mul_of_one_le_of_one_le (ha : 1 \u2264 a) (hb : 1 \u2264 b) : (1 : \u03b1) \u2264 a * b :=", "model_response": "lemma to_nat_mul (a b : Ordinal) : to_nat (a * b) = to_nat a * to_nat b :="}
{"gold_output": "theorem isRat_add {\u03b1} [Ring \u03b1] {f : \u03b1 \u2192 \u03b1 \u2192 \u03b1} {a b : \u03b1} {na nb nc : \u2124} {da db dc k : \u2115} :\nf = HAdd.hAdd \u2192 IsRat a na da \u2192 IsRat b nb db \u2192\nInt.add (Int.mul na db) (Int.mul nb da) = Int.mul k nc \u2192\nNat.mul da db = Nat.mul k dc \u2192\nIsRat (f a b) nc dc :=", "model_response": "lemma rat_homo_add: \"rat_homo f (na::int) (da::nat) (nb::int) (db::nat) (HAdd.hAdd)\""}
{"gold_output": "theorem isAdjointPairLeftAdjointOfNondegenerate (B : BilinForm K V) (b : B.Nondegenerate)\n(\u03c6 : V \u2192\u2097[K] V) : IsAdjointPair B B (B.leftAdjointOfNondegenerate b \u03c6) \u03c6 :=", "model_response": "lemma leftAdjointOfNondegenerate_right_inv [simp]:\n\"(B.toLin \\<circ> (B.leftAdjointOfNondegenerate b \\<phi>).toLin) = LinearMap.id\""}
{"gold_output": "theorem dual_comp (g : \u03b2 \u2192o \u03b3) (f : \u03b1 \u2192o \u03b2) :\nOrderHom.dual (g.comp f) = (OrderHom.dual g).comp (OrderHom.dual f) :=", "model_response": "lemma dual_id [simp]: \"dual (OrderHom.id \u03b1) = OrderHom.id (\u03b1\u1d52\u1d48)\""}
{"gold_output": "theorem disjoint_left {s t : Multiset \u03b1} : Disjoint s t \u2194 \u2200 {a}, a \u2208 s \u2192 a \u2209 t :=", "model_response": "lemma inj_on_iff_eq : \"inj_on f s \\<longleftrightarrow> (\\<forall>x\\<in>s. \\<forall>y\\<in>s. f x = f y \\<longrightarrow> x = y)\""}
{"gold_output": "theorem gc_map_comap (f : A \u2192\u2090[R] B) : GaloisConnection (map f) (comap f) :=", "model_response": "lemma map_mono: \"mono (map f)\""}
{"gold_output": "theorem of_zero_smul {i} (a : A 0) (b : A i) : of _ _ (a \u2022 b) = of _ _ a * of _ _ b :=", "model_response": "lemma of_zero_smul_eq_smul_of (i) : of _ _ (A 0) (a \u2022 b) = of _ _ A 0 a * of _ _ A i b :="}
{"gold_output": "theorem toEquiv_fun (i : X \u2245 Y) : (i.toEquiv : X \u2192 Y) = i.hom :=", "model_response": "lemma toEquiv_to_fun [simp]: \"toEquiv i = i\""}
{"gold_output": "theorem tendstoIxxClass_of_subset {l\u2081 l\u2082 : Filter \u03b1} {Ixx Ixx' : \u03b1 \u2192 \u03b1 \u2192 Set \u03b1}\n(h : \u2200 a b, Ixx a b \u2286 Ixx' a b) [h' : TendstoIxxClass Ixx' l\u2081 l\u2082] : TendstoIxxClass Ixx l\u2081 l\u2082 :=", "model_response": "lemma monotone_Ixx_left : Monotone (Ixx a) :="}
{"gold_output": "theorem wellFounded_of_isEmpty {\u03b1} [IsEmpty \u03b1] (r : \u03b1 \u2192 \u03b1 \u2192 Prop) : WellFounded r :=", "model_response": "lemma wellFounded_singleton :\nassumes \"isEmpty \u03b1\"\nshows \"wellFounded r (singleton \u03b1)\""}
{"gold_output": "theorem Filter.Tendsto.sup_right_nhds {\u03b9 \u03b2} [TopologicalSpace \u03b2] [Sup \u03b2] [ContinuousSup \u03b2]\n{l : Filter \u03b9} {f g : \u03b9 \u2192 \u03b2} {x y : \u03b2} (hf : Tendsto f l (\ud835\udcdd x)) (hg : Tendsto g l (\ud835\udcdd y)) :\nTendsto (fun i => f i \u2294 g i) l (\ud835\udcdd (x \u2294 y)) :=", "model_response": "lemma tendsto_of_real_atBot [tendsto_intros]: \"tendsto of_real atBot (\ud835\udcdd 0)\""}
{"gold_output": "theorem Finite.offDiag {s : Set \u03b1} (hs : s.Finite) : s.offDiag.Finite :=", "model_response": "lemma offDiag_eq_Inter: \"s.offDiag = \\<Inter>{t |t. t \\<subseteq> s \\<and> t \\<noteq> s \\<and> t \\<subseteq> s.offDiag}\""}
{"gold_output": "theorem add_singleton_eq_iff {s t : Multiset \u03b1} {a : \u03b1} : s + {a} = t \u2194 a \u2208 t \u2227 s = t.erase a :=", "model_response": "lemma inj_on_iff_subset_singleton: \"inj_on f s \\<longleftrightarrow> f '' s \\<subseteq> {f a}\""}
{"gold_output": "theorem circleMap_mem_sphere (c : \u2102) {R : \u211d} (hR : 0 \u2264 R) (\u03b8 : \u211d) : circleMap c R \u03b8 \u2208 sphere c R :=", "model_response": "lemma norm_circleMap [simp]: \"norm (circleMap c R \u03b8) = R\""}
{"gold_output": "theorem toOuterMeasure_le : \u03bc\u2081.toOuterMeasure \u2264 \u03bc\u2082.toOuterMeasure \u2194 \u03bc\u2081 \u2264 \u03bc\u2082 :=", "model_response": "lemma toOuterMeasure_injective:\n\"toOuterMeasure \\<mu>\\<^sub>1 = toOuterMeasure \\<mu>\\<^sub>2 \\<longleftrightarrow> \\<mu>\\<^sub>1 = \\<mu>\\<^sub>2\""}
{"gold_output": "theorem mem_mk {s : Set M} {x : M} (h_one) (h_mul) : x \u2208 mk \u27e8s, h_mul\u27e9 h_one \u2194 x \u2208 s :=", "model_response": "lemma setOf_eq_coe_mk {P : M \u2192 Prop} (h_one) (h_mul) :\n{ x : M | P x } = mk \u27e8{ x | P x }, h_mul\u27e9 h_one :="}
{"gold_output": "theorem Basis.toMatrix_mul_toMatrix {\u03b9'' : Type _} [Fintype \u03b9'] (b'' : \u03b9'' \u2192 M) :\nb.toMatrix b' \u2b1d b'.toMatrix b'' = b.toMatrix b'' :=", "model_response": "lemma toMatrix_eq_matrix': \"toMatrix b b' = b.matrix b'\""}
{"gold_output": "theorem length_rowLens {\u03bc : YoungDiagram} : \u03bc.rowLens.length = \u03bc.colLen 0 :=", "model_response": "lemma rowLens_length [simp]: \"length \u03bc.rowLens = \u03bc.colLen 0\""}
{"gold_output": "theorem integral_sub_inv_smul_sub_smul (f : \u2102 \u2192 E) (c w : \u2102) (R : \u211d) :\n(\u222e z in C(c, R), (z - w)\u207b\u00b9 \u2022 (z - w) \u2022 f z) = \u222e z in C(c, R), f z :=", "model_response": "lemma integral_sub_inv_smul_sub_smul (f : \u2102 \u2192 E) (c w : \u2102) (R : \u211d) :\n(\u222e z in C(c, R), (z - w)\u207b\u00b9 \u2022 (z - w) \u2022 f z) = \u222e z in C(c, R), f z :="}
{"gold_output": "theorem toList_formPerm_singleton (x y : \u03b1) : toList (formPerm [x]) y = [] :=", "model_response": "lemma toList_formPerm_cons: \"toList (formPerm l x) = x # filter (x \\<noteq>) l\""}
{"gold_output": "theorem ae_map_iff {p : \u03b2 \u2192 Prop} {\u03bc : Measure \u03b1} : (\u2200\u1d50 x \u2202\u03bc.map f, p x) \u2194 \u2200\u1d50 x \u2202\u03bc, p (f x) :=", "model_response": "lemma continuous_at_eq_continuousWithinAt:\n\"ContinuousAt f x = ContinuousWithinAt f s x\""}
{"gold_output": "theorem isOpen_iff {s : Set \u0393\u2080} : IsOpen s \u2194 (0 : \u0393\u2080) \u2209 s \u2228 \u2203 \u03b3, \u03b3 \u2260 0 \u2227 Iio \u03b3 \u2286 s :=", "model_response": "lemma toIcoMod_eq_self_iff:\n\"toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)\""}
{"gold_output": "theorem edist_le_of_edist_le_geometric_of_tendsto\u2080 {a : \u03b1} (ha : Tendsto f atTop (\ud835\udcdd a)) :\nedist (f 0) a \u2264 C / (1 - r) :=", "model_response": "lemma edist_le_geometric_of_tendsto\u2080:\nassumes \"Tendsto f atTop (\ud835\udcdd a)\"\nshows \"edist (f 0) a \\<le> C / (1 - r)\""}
{"gold_output": "theorem prod_comm' : f \u00d7\u02e2 g = comap Prod.swap (g \u00d7\u02e2 f) :=", "model_response": "lemma prod_comm : f * g = comap Prod.swap (g * f) :="}
{"gold_output": "theorem conj_eq_iff_real {z : K} : conj z = z \u2194 \u2203 r : \u211d, z = (r : K) :=", "model_response": "lemma conj_conj [simp]: \"conj (conj z) = z\""}
{"gold_output": "theorem strongUniformity_topology_eq [UniformSpace F] [UniformAddGroup F] (\ud835\udd16 : Set (Set E)) :\n(strongUniformity \u03c3 F \ud835\udd16).toTopologicalSpace = strongTopology \u03c3 F \ud835\udd16 :=", "model_response": "lemma toWeakDualBCNN_continuous:\n\"continuous (toWeakDualBCNN \u03c3)\""}
{"gold_output": "theorem smul_le_smul : f\u2081 \u2264 f\u2082 \u2192 g\u2081 \u2264 g\u2082 \u2192 f\u2081 \u2022 g\u2081 \u2264 f\u2082 \u2022 g\u2082 :=", "model_response": "lemma to_nat_strictMono[simp, intro!]: \"StrictMono to_nat\""}
{"gold_output": "theorem cotangentIdeal_square (I : Ideal R) : I.cotangentIdeal ^ 2 = \u22a5 :=", "model_response": "lemma cotangentIdeal_square : \"I.cotangentIdeal ^ 2 = \u22a5\""}
{"gold_output": "theorem StrictAnti.isMax_of_apply (hf : StrictAnti f) (ha : IsMin (f a)) : IsMax a :=", "model_response": "lemma strictAntiOn_iff_lt:\n\"StrictAntiOn f s \\<longleftrightarrow> (\\<forall>a\\<in>s. \\<forall>b\\<in>s. a < b \\<longrightarrow> f b < f a)\""}
{"gold_output": "theorem of_apply (x : M) (n : \u2115) : (of I M x).1 n = mkQ _ x :=", "model_response": "lemma of_eq_ofFn: \"of I M x = ofFn (\\<lambda>i. mkQ I x)\""}
{"gold_output": "theorem abs_sin_eq_sqrt_one_sub_cos_sq (x : \u211d) : |sin x| = sqrt (1 - cos x ^ 2) :=", "model_response": "lemma abs_sin_eq_sqrt_one_sub_cos_sq: \"\\<bar>sin x\\<bar> = sqrt (1 - cos x ^ 2)\""}
{"gold_output": "theorem tendsto_iff_forall_eval_tendsto {l : Filter \u03b1} {f : \u03b1 \u2192 WeakBilin B} {x : WeakBilin B}\n(hB : Function.Injective B) :\nTendsto f l (\ud835\udcdd x) \u2194 \u2200 y, Tendsto (fun i => B (f i) y) l (\ud835\udcdd (B x y)) :=", "model_response": "lemma continuousAt_bilinear_iff:\n\"continuousAt f x \\<longleftrightarrow> (\\<forall>y. continuousAt (fun i => B (f i) y) x)\""}
{"gold_output": "theorem mapIso_refl (F : C \u2964 D) (X : C) : F.mapIso (Iso.refl X) = Iso.refl (F.obj X) :=", "model_response": "lemma triangle_left_associator_inv:\nshows \"(\u03bb_ F).inv \u25b7 F.hom \u25c1 (\u03b1_ F G H).hom = (\u03bb_ F).hom \u25b7 (\u03b1_ F G H).inv\""}
{"gold_output": "theorem left_hom_inv_right [IsIso sq] : sq.left \u226b g.hom \u226b inv sq.right = f.hom :=", "model_response": "theorem left_hom_inv_right : sq.left \u226b g.hom \u226b inv sq.right = f.hom :="}
{"gold_output": "theorem mem_nhdsWithin_of_mem_nhds {s t : Set \u03b1} {a : \u03b1} (h : s \u2208 \ud835\udcdd a) : s \u2208 \ud835\udcdd[t] a :=", "model_response": "lemma isCont_iff_leftLim_eq_rightLim: \"isCont f a \\<longleftrightarrow> leftLim f a = rightLim f a\""}
{"gold_output": "theorem subtype_comp_inclusion {H K : Subgroup G} (hH : H \u2264 K) :\nK.subtype.comp (inclusion hH) = H.subtype :=", "model_response": "theorem subtype_comp_inclusion [simp]:\n\"K.subtype.comp (inclusion hH) = H.subtype\""}
{"gold_output": "theorem absorbs_iUnion_finset {\u03b9 : Type _} {t : Finset \u03b9} {f : \u03b9 \u2192 Set E} :\nAbsorbs \ud835\udd5c s (\u22c3 i \u2208 t, f i) \u2194 \u2200 i \u2208 t, Absorbs \ud835\udd5c s (f i) :=", "model_response": "lemma absorbs_iUnion_iff: \"absorbs \ud835\udd5c s (\u22c3 i \u2208 t, f i) \u2194 \u2200 i \u2208 t, absorbs \ud835\udd5c s (f i)\""}
{"gold_output": "theorem erase_comm (s : Multiset \u03b1) (a b : \u03b1) : (s.erase a).erase b = (s.erase b).erase a :=", "model_response": "lemma card_erase_comm:\nassumes \"a \\<notin> s\" and \"b \\<notin> s\"\nshows \"card (s.erase a).erase b = card (s.erase b).erase a\""}
{"gold_output": "theorem sum_sub [Zero M] [AddCommGroup G] {f : \u03b1 \u2192\u2080 M} {h\u2081 h\u2082 : \u03b1 \u2192 M \u2192 G} :\n(f.sum fun a b => h\u2081 a b - h\u2082 a b) = f.sum h\u2081 - f.sum h\u2082 :=", "model_response": "lemma sum_sub_distrib [algebra_simps]:\n\"(f.sum fun a b => h\u2081 a b - h\u2082 a b) = f.sum h\u2081 - f.sum h\u2082\""}
{"gold_output": "theorem spectrum_eq_range (f : C(X, \ud835\udd5c)) : spectrum \ud835\udd5c f = Set.range f :=", "model_response": "lemma neg_eq_rangeS (f : C(X, \ud835\udd5c)) : -spectrum \ud835\udd5c f = -f.rangeS :="}
{"gold_output": "theorem antitone_of_deriv_nonpos {f : \u211d \u2192 \u211d} (hf : Differentiable \u211d f) (hf' : \u2200 x, deriv f x \u2264 0) :\nAntitone f :=", "model_response": "lemma differentiable_on : \"f differentiableOn s\""}
{"gold_output": "theorem restriction_zero : restriction (0 : R[X]) = 0 :=", "model_response": "lemma restriction_X : \"restriction (X : R[X]) = 1\""}
{"gold_output": "theorem _root_.MonotoneOn.monotone (h : MonotoneOn f s) :\nMonotone (f \u2218 Subtype.val : s \u2192 \u03b2) :=", "model_response": "lemma monotoneOn_subtype_val [simp]: \"monotoneOn (f \u2218 Subtype.val) s\""}
{"gold_output": "theorem pureOneHom_apply (a : \u03b1) : pureOneHom a = pure a :=", "model_response": "lemma pureOneHom_eq_pure: \"pureOneHom = pure\""}
{"gold_output": "theorem ContDiff.comp_contDiff_on\u2082 {g : E\u2081 \u00d7 E\u2082 \u2192 G} {f\u2081 : F \u2192 E\u2081} {f\u2082 : F \u2192 E\u2082} {s : Set F}\n(hg : ContDiff \ud835\udd5c n g) (hf\u2081 : ContDiffOn \ud835\udd5c n f\u2081 s) (hf\u2082 : ContDiffOn \ud835\udd5c n f\u2082 s) :\nContDiffOn \ud835\udd5c n (fun x => g (f\u2081 x, f\u2082 x)) s :=", "model_response": "lemma contDiffOn_prod_mk {f\u2081 : F \u2192 E\u2081} {f\u2082 : F \u2192 E\u2082} {s : Set F} :\nContDiffOn \ud835\udd5c n (fun x => (f\u2081 x, f\u2082 x)) s :="}
{"gold_output": "theorem filter_eq_indicator : \u21d1(f.filter p) = Set.indicator { x | p x } f :=", "model_response": "lemma continuous_on_iff_indicator_continuous_on :\n\"continuous_on s f \\<longleftrightarrow> continuous_on s (indicator s f)\""}
{"gold_output": "theorem csInf_image2_eq_csInf_csInf (h\u2081 : \u2200 b, GaloisConnection (l\u2081 b) (swap u b))\n(h\u2082 : \u2200 a, GaloisConnection (l\u2082 a) (u a)) :\ns.Nonempty \u2192 BddBelow s \u2192 t.Nonempty \u2192 BddBelow t \u2192 sInf (image2 u s t) = u (sInf s) (sInf t) :=", "model_response": "lemma csInf_image2_eq:\n\"sInf {u x y | x y. x \\<in> s \\<and> y \\<in> t} = u (sInf s) (sInf t)\""}
{"gold_output": "theorem Ico_subset_Iic_self : Ico a b \u2286 Iic b :=", "model_response": "lemma Ico_subset_Iic_self : \"Ico a b \\<subseteq> Iic b\""}
{"gold_output": "theorem obj_\u03b5_app (n : M) (X : C) :\n(F.obj n).map (F.\u03b5.app X) = (F.map (\u03bb_ n).inv).app X \u226b (F.\u03bcIso (\ud835\udfd9_ M) n).inv.app X :=", "model_response": "theorem obj_inv_map_app_\u03b5_app (n : M) (X : C) :\n(F.obj n).inv.map (F.\u03b5.app X) = (F.map (\u03bb_ n).hom).app X \u226b (F.\u03bcIso n (\ud835\udfd9_ M)).inv.app X :="}
{"gold_output": "theorem forall_mem_cons {\u03b1} {p : \u03b1 \u2192 Prop} {a : \u03b1} {l : Thunk (LazyList \u03b1)} :\n(\u2200 x \u2208 @LazyList.cons _ a l, p x) \u2194 p a \u2227 \u2200 x \u2208 l.get, p x :=", "model_response": "lemma set_filter_cons {\u03b1} (p : \u03b1 \u2192 Prop) (a : \u03b1) (l : Thunk (LazyList \u03b1)) :\n{ x | p x } = {a} \u222a { x | x \u2208 l.get \u2227 p x } :="}
{"gold_output": "theorem card_erase_add_one {a : \u03b1} {s : Multiset \u03b1} : a \u2208 s \u2192 card (s.erase a) + 1 = card s :=", "model_response": "lemma card_erase_lt_iff_mem {a : \u03b1} {s : Multiset \u03b1} : card (s.erase a) < card s \u2194 a \u2208 s :="}
{"gold_output": "theorem det_eq_zero_of_row_eq_zero {A : Matrix n n R} (i : n) (h : \u2200 j, A i j = 0) : det A = 0 :=", "model_response": "theorem det_apply' [code]:\n\"det A = \u2211 \u03c3 : Perm n, of_int (sign \u03c3) * \u220f i, A (\u03c3 i) i\""}
{"gold_output": "theorem ae_le_set_inter {s' t' : Set \u03b1} (h : s \u2264\u1d50[\u03bc] t) (h' : s' \u2264\u1d50[\u03bc] t') :\n(s \u2229 s' : Set \u03b1) \u2264\u1d50[\u03bc] (t \u2229 t' : Set \u03b1) :=", "model_response": "lemma measure_inter_le: \"measure M (s \\<inter> t) \\<le> measure M s + measure M t\""}
{"gold_output": "theorem coeff_X_add_one_pow (R : Type _) [Semiring R] (n k : \u2115) :\n((X + 1) ^ n).coeff k = (n.choose k : R) :=", "model_response": "lemma coeff_X_add_one_pow (n k : \u2115) : ((X + 1) ^ n).coeff k = (n.choose k : R) :="}
{"gold_output": "theorem differentiableAt : DifferentiableAt \ud835\udd5c iso x :=", "model_response": "lemma differentiable_iso: \"Differentiable \ud835\udd5c iso\""}
{"gold_output": "theorem liftPropAt_of_liftPropWithinAt (h : LiftPropWithinAt P g s x) (hs : s \u2208 \ud835\udcdd x) :\nLiftPropAt P g x :=", "model_response": "lemma continuous_at_iff:\n\"continuous (at x) f \\<longleftrightarrow> (\\<forall>\u03b5>0. \\<exists>\u03b4>0. \\<forall>y. dist y x < \u03b4 \\<longrightarrow> dist (f y) (f x) < \u03b5)\""}
{"gold_output": "theorem toSignedMeasure_smul (\u03bc : Measure \u03b1) [IsFiniteMeasure \u03bc] (r : \u211d\u22650) :\n(r \u2022 \u03bc).toSignedMeasure = r \u2022 \u03bc.toSignedMeasure :=", "model_response": "lemma ennreal_eq_measure (A : Set \u03b1) : m.measure A = ENNReal.ofReal (m' A) :="}
{"gold_output": "theorem set_walk_length_succ_eq (u v : V) (n : \u2115) :\n{p : G.Walk u v | p.length = n.succ} =\n\u22c3 (w : V) (h : G.Adj u w), Walk.cons h '' {p' : G.Walk w v | p'.length = n} :=", "model_response": "lemma set_walk_length_eq_union_neighborhood:\n\"{p : G.Walk u v | p.length = n} =\n(\\<Union> (w) (h : G.Adj u w). (Walk.cons h '' {p' : (G \\ fromVertex u).Walk w v | p'.length = n}))\""}
{"gold_output": "theorem denseEmbedding (hp_ne_top : p \u2260 \u221e) :\nDenseEmbedding ((\u2191) : Lp.simpleFunc E p \u03bc \u2192 Lp E p \u03bc) :=", "model_response": "lemma denseEmbedding_coe_Lp :\n\"denseEmbedding ((\u2191) : Lp.simpleFunc E p \u03bc \u2192 Lp E p \u03bc)\""}
{"gold_output": "theorem not_mem_of_lt_min {s : Finset \u03b1} {a b : \u03b1} (h\u2081 : a < b) (h\u2082 : s.min = \u2191b) : a \u2209 s :=", "model_response": "lemma min_singleton (a : \u03b1) : ({a} : Finset \u03b1).min = a :="}
{"gold_output": "theorem mk_preimage_prod_left_eq_if [DecidablePred (\u00b7 \u2208 t)] :\n(fun a => (a, b)) \u207b\u00b9' s \u00d7\u02e2 t = if b \u2208 t then s else \u2205 :=", "model_response": "lemma mk_preimage_prod_left [simp]: \"(\\<lambda>a. (a, b)) \u207b\u00b9' t = Prod.mk '' t b\""}
{"gold_output": "theorem matiyasevic {a k x y} :\n(\u2203 a1 : 1 < a, xn a1 k = x \u2227 yn a1 k = y) \u2194\n1 < a \u2227 k \u2264 y \u2227 (x = 1 \u2227 y = 0 \u2228\n\u2203 u v s t b : \u2115,\nx * x - (a * a - 1) * y * y = 1 \u2227 u * u - (a * a - 1) * v * v = 1 \u2227\ns * s - (b * b - 1) * t * t = 1 \u2227 1 < b \u2227 b \u2261 1 [MOD 4 * y] \u2227\nb \u2261 a [MOD u] \u2227 0 < v \u2227 y * y \u2223 v \u2227 s \u2261 x [MOD u] \u2227 t \u2261 k [MOD 4 * y]) :=", "model_response": "lemma pell_zd_aux_eq_one_zero (x y) :\n\"pell_zd_aux (1, 0) = (x, y)\""}
{"gold_output": "theorem superpolynomialDecay_iff_isBigO (hk : Tendsto k l atTop) :\nSuperpolynomialDecay l k f \u2194 \u2200 z : \u2124, f =O[l] fun a : \u03b1 => k a ^ z :=", "model_response": "lemma superpolynomialDecay_iff_isBigO:\n\"f =O[l] (\\<lambda>a. k a ^ z) \\<longleftrightarrow> (\\<forall>n. (fun n \\<in> o[l] fun a. k a ^ z))\""}
{"gold_output": "theorem Subperm.refl (l : List \u03b1) : l <+~ l :=", "model_response": "lemma sublist_of_sublists :\nassumes \"l \\<in> set (sublists l')\"\nshows \"sublist l l'\""}
{"gold_output": "theorem iUnion_iInter_subset {s : \u03b9 \u2192 \u03b9' \u2192 Set \u03b1} : (\u22c3 j, \u22c2 i, s i j) \u2286 \u22c2 i, \u22c3 j, s i j :=", "model_response": "lemma continuous_at_dist:\n\"continuous (at x) f \\<longleftrightarrow> (\\<forall>\u03b5>0. \\<exists>\u03b4>0. \\<forall>y. dist y x < \u03b4 \\<longrightarrow> dist (f y) (f x) < \u03b5)\""}
{"gold_output": "theorem map_id_obj (x : X) (U) : (map (\ud835\udfd9 X) x).obj U = U :=", "model_response": "theorem map_naturality (x : X) (U) :\n(map F x).obj U \u226b (F.\u03c4 x).app U = (F.\u03c4 x).app U \u226b (map F x).obj U :="}
{"gold_output": "theorem IsRefl.reflexive [IsRefl \u03b1 r] : Reflexive r :=", "model_response": "lemma reflexive_on_refl_of_reflexive:\nassumes \"reflexive_on \u03b1 r\"\nshows \"reflexive r\""}
{"gold_output": "theorem piPremeasure_pi_mono {s t : Set (\u2200 i, \u03b1 i)} (h : s \u2286 t) :\npiPremeasure m s \u2264 piPremeasure m t :=", "model_response": "lemma measurableSet_prod_fst_preimage [measurable]:\n\"Measurable.measurable (MeasurableSpace.prod_mk :: ('a \\<times> 'b) set) (Prod.fst \u207b\u00b9' s \u00d7\u02e2 t)\""}
{"gold_output": "theorem isPartition_splitMany (I : Box \u03b9) (s : Finset (\u03b9 \u00d7 \u211d)) : IsPartition (splitMany I s) :=", "model_response": "lemma toIcoMod_eq_self_iff: \"toIcoMod hp a b = b \u2194 b \u2208 Set.Icc a (a + p) \u2227 b \u2264 a + p - hp\""}
{"gold_output": "theorem mem_attach (s : Sym \u03b1 n) (x : { x // x \u2208 s }) : x \u2208 s.attach :=", "model_response": "lemma card_subtype_filter_eq {s : Finset \u03b1} :\n(#{ a // a \u2208 s \u2227 P a } : Cardinal) = (#{ a \u2208 s | P a } : Cardinal) :="}
{"gold_output": "theorem restrictOrthogonalSpanSingletonNondegenerate (B : BilinForm K V) (b\u2081 : B.Nondegenerate)\n(b\u2082 : B.IsRefl) {x : V} (hx : \u00acB.IsOrtho x x) :\nNondegenerate <| B.restrict <| B.orthogonal (K \u2219 x) :=", "model_response": "lemma BilinForm.toMatrix_eq_toMatrix' (B : BilinForm K V) (b\u2081 : B.Nondegenerate)\n(b\u2082 : B.IsRefl) : BilinForm.toMatrix b B = BilinForm.toMatrix' b B :="}
{"gold_output": "theorem GroupWithZero.mul_right_injective (h : x \u2260 0) :\nFunction.Injective fun y => y * x :=", "model_response": "lemma continuousAt_const_smul_iff [simp]:\n\"continuousAt (\\<lambda>x. c * f x) b \\<longleftrightarrow> continuousAt f b\""}
{"gold_output": "theorem pow_def (p : \u03b1 \u00d7 \u03b2) (c : E) : p ^ c = (p.1 ^ c, p.2 ^ c) :=", "model_response": "lemma continuousAt_prod_iff [simp]:\n\"continuousAt f x \\<longleftrightarrow> continuousAt (fst \\<circ> f) x \\<and> continuousAt (snd \\<circ> f) x\""}
{"gold_output": "theorem EventuallyEq.trans {l : Filter \u03b1} {f g h : \u03b1 \u2192 \u03b2} (H\u2081 : f =\u1da0[l] g) (H\u2082 : g =\u1da0[l] h) :\nf =\u1da0[l] h :=", "model_response": "lemma eventually_nonneg_filter_mono_iff:\n\"eventually_nonneg l (\\<lambda>x. g x = f x) \\<longleftrightarrow> eventually_nonneg l f\" if \"eventually_eq l f g\""}
{"gold_output": "theorem coe_comapOfKerIsPGroup (h\u03d5 : IsPGroup p \u03d5.ker) (h : \u2191P \u2264 \u03d5.range) :\n(P.comapOfKerIsPGroup \u03d5 h\u03d5 h : Subgroup K) = Subgroup.comap \u03d5 \u2191P :=", "model_response": "theorem comapOfKerIsPGroup_eq :\n\"(P.comapOfKerIsPGroup \u03d5 h\u03d5 h : Subgroup K) = Subgroup.comap \u03d5 \u2191P\""}
{"gold_output": "theorem inf_top_eq : a \u2293 \u22a4 = a :=", "model_response": "lemma inf_top_eq [simp]: \"a \u2293 \u22a4 = a\""}
{"gold_output": "theorem quasiMeasurePreserving_div [IsMulLeftInvariant \u03bc] :\nQuasiMeasurePreserving (fun p : G \u00d7 G => p.1 / p.2) (\u03bc.prod \u03bd) \u03bc :=", "model_response": "lemma quasiMeasurePreserving_div [measurable]:\n\"quasiMeasurePreserving (\\<lambda>p : G \\<times> G. p.1 / p.2) (\u03bc.prod \u03bd) \u03bc\""}
{"gold_output": "theorem eq_div_of_mul_eq_left {a b c : R} (hb : b \u2260 0) (h : a * b = c) : a = c / b :=", "model_response": "lemma eq_div_of_mul_eq_left_unit:\nfixes a b c :: R\nassumes b0: \"b \\<in> Units R\"\nand p: \"a * b = c\"\nshows \"a = c / b\""}
{"gold_output": "theorem dvd_iff_dvd_ofDigits (b b' : \u2115) (c : \u2124) (h : (b : \u2124) \u2223 (b' : \u2124) - c) (n : \u2115) :\nb \u2223 n \u2194 (b : \u2124) \u2223 ofDigits c (digits b' n) :=", "model_response": "lemma ofDigits_eq_sum_digits:\n\"ofDigits b ds = \u2211 i in Finset.range (ds.length), (ds.get i : \u2124) * b ^ i\""}
{"gold_output": "theorem tendsto_atBot_add_nonpos_left' (hf : \u2200\u1da0 x in l, f x \u2264 0) (hg : Tendsto g l atBot) :\nTendsto (fun x => f x + g x) l atBot :=", "model_response": "lemma continuous_at_iff_tendsto_uniformity:\n\"continuous (at x) f \\<longleftrightarrow> ((\\<lambda>x. (f x, f x)) \\<longlongrightarrow> (f x, f x)) (\ud835\udcdd (f x, f x)) (\ud835\udce4 (codomain f))\""}
{"gold_output": "theorem coe_inj {f g : LocallyConstant X Y} : (f : X \u2192 Y) = g \u2194 f = g :=", "model_response": "lemma injective_iff_ne_default: \"injective f \u2194 \u2200 x, f x \u2260 g default\""}
{"gold_output": "theorem mk_subtype_le {\u03b1 : Type u} (p : \u03b1 \u2192 Prop) : (#Subtype p) \u2264 (#\u03b1) :=", "model_response": "theorem mk_fin_fun (\u03b1 : Type u) (n : \u2115) : (#(Fin n \u2192 \u03b1)) = (#\u03b1) ^\u2115 n :="}
{"gold_output": "theorem normSq_lt_one (z : \ud835\udd3b) : normSq z < 1 :=", "model_response": "lemma norm_le_one_iff_re_le_zero:\n\"norm z \\<le> 1 \\<longleftrightarrow> 0 \\<le> re z \\<and> re z \\<le> 1 \\<or> im z \\<noteq> 0 \\<and> re z < 0\""}
{"gold_output": "theorem tsupport_fderiv_subset : tsupport (fderiv \ud835\udd5c f) \u2286 tsupport f :=", "model_response": "lemma continuousAt_add_const_iff:\n\"ContinuousAt (\\<lambda>x. f x + c) x \\<longleftrightarrow> ContinuousAt f x\""}
{"gold_output": "theorem right_mem_Icc : b \u2208 Icc a b \u2194 a \u2264 b :=", "model_response": "lemma toIcoMod_eq_self_iff: \"toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)\""}
{"gold_output": "theorem IsCoprime.of_isCoprime_of_dvd_left (h : IsCoprime y z) (hdvd : x \u2223 y) : IsCoprime x z :=", "model_response": "lemma coprime_of_dvd_left:\nassumes \"coprime y z\" \"x dvd y\"\nshows   \"coprime x z\""}
{"gold_output": "theorem range_id : range (id L M) = \u22a4 :=", "model_response": "lemma range_id_eq_top : \"range (id L) = \u22a4\""}
{"gold_output": "theorem zero_lt_iff : 0 < a \u2194 a \u2260 0 :=", "model_response": "lemma to_nat_of_nat : to_nat (of_nat n) = n :="}
{"gold_output": "theorem step5 {P : Sylow (Fintype.card N).minFac N} : P.1 \u2260 \u22a5 :=", "model_response": "theorem card_sylow_mod_card_subgroup_sylow [simp]:\n\"card (sylow p G) = card (sylow p N) [MOD p]\""}
{"gold_output": "theorem liftOne_zero_comm {Y Z : C} (f : Y \u27f6 Z) (P : ProjectiveResolution Y)\n(Q : ProjectiveResolution Z) :\nliftOne f P Q \u226b Q.complex.d 1 0 = P.complex.d 1 0 \u226b liftZero f P Q :=", "model_response": "lemma liftOne_zero_comm: \"liftOne f P Q \u226b Q.d 1 0 = P.d 1 0 \u226b liftZero f P Q\""}
{"gold_output": "theorem comp_def {M N K : Mat_ C} (f : M \u27f6 N) (g : N \u27f6 K) :\nf \u226b g = fun i k => \u2211 j : N.\u03b9, f i j \u226b g j k :=", "model_response": "lemma pullback_flip_eq: \"hom \\<cdot> inv (\u03b1.app X) = inv (\u03b1.app X) \\<cdot> hom\""}
{"gold_output": "theorem AntivaryOn.symm (h : AntivaryOn f g s) : AntivaryOn g f s :=", "model_response": "lemma antivaryOn_comp_symm_iff :\n\"AntivaryOn f g UNIV \\<longleftrightarrow> AntivaryOn g f UNIV\""}
{"gold_output": "theorem continuousAt_log (hx : x \u2260 0) : ContinuousAt log x :=", "model_response": "lemma continuousAt_log_pos (hx : 0 < x) : ContinuousAt log x :="}
{"gold_output": "theorem one_def : (1 : S') = \u27e81, OneMemClass.one_mem S'\u27e9 :=", "model_response": "lemma one_def': \"1\\<^bsub>S\\<^esub> = \\<lfloor>\\<one>, OneMemClass.one_mem S\\<rfloor>\""}
{"gold_output": "theorem lt_of_forall_lt_of_lt (a b : Lex (\u03b1 \u2192\u2080 N)) (i : \u03b1) :\n(\u2200 j < i, ofLex a j = ofLex b j) \u2192 ofLex a i < ofLex b i \u2192 a < b :=", "model_response": "lemma ofLex_strictMono: \"StrictMono ofLex\""}
{"gold_output": "theorem quotient_prod_linearEquiv (p : Submodule K V) : Nonempty (((V \u29f8 p) \u00d7 p) \u2243\u2097[K] V) :=", "model_response": "lemma mkQ_inj: \"inj (mkQ p)\""}
{"gold_output": "theorem mk_coe_finset {\u03b1 : Type u} {s : Finset \u03b1} : (#s) = \u2191(Finset.card s) :=", "model_response": "lemma mk_fin_fun_eq_pow (\u03b1 : Type u) (n : \u2115) : (#(Fin n \u2192 \u03b1)) = (#\u03b1) ^\u2115 n :="}
{"gold_output": "theorem zpow_bit1_pos_iff : 0 < a ^ bit1 n \u2194 0 < a :=", "model_response": "lemma continuousAt_iff_continuousAt_left_right :\n\"ContinuousAt f x \\<longleftrightarrow> ContinuousAt f (left x) \\<and> ContinuousAt f (right x)\""}
{"gold_output": "theorem prod_le_prod {\u03b9} (f g : \u03b9 \u2192 Cardinal) (H : \u2200 i, f i \u2264 g i) : prod f \u2264 prod g :=", "model_response": "lemma prod_le_prod': \"prod f s \\<le> prod g s\""}
{"gold_output": "theorem continuous_sum_map {f : \u03b1 \u2192 \u03b2} {g : \u03b3 \u2192 \u03b4} :\nContinuous (Sum.map f g) \u2194 Continuous f \u2227 Continuous g :=", "model_response": "lemma continuous_sumMap: \"continuous (sumMap f g)\""}
{"gold_output": "theorem Nonempty.of_sups_right : (s \u22bb t).Nonempty \u2192 t.Nonempty :=", "model_response": "lemma sup_eq_union: \"s \u22bb t = s \u222a t\""}
{"gold_output": "theorem length_nil {a : V} : (nil : Path a a).length = 0 :=", "model_response": "lemma length_singleton [simp]: \"length [a] = 1\""}
{"gold_output": "theorem Adhesive.isPullback_of_isPushout_of_mono_right [Adhesive C] (H : IsPushout f g h i)\n[Mono g] : IsPullback f g h i :=", "model_response": "lemma (in category) coequalizer_cofork_inl_comp_pushout_inl [simp]:\n\"coequalizer.\u03c0 (coequalizer_cofork f g) hom \u226b pushout.inl = pushout.inl\""}
{"gold_output": "theorem prod_replicate (n : \u2115) (a : \u03b1) : (replicate n a).prod = a ^ n :=", "model_response": "lemma prod_replicate [simp]: \"prod (replicate n a) = a ^ n\""}
{"gold_output": "theorem mul_rightUnitor {M : Mon_ C} :\n(tensor_\u03bc C (M.X, \ud835\udfd9_ C) (M.X, \ud835\udfd9_ C) \u226b (M.mul \u2297 (\u03bb_ (\ud835\udfd9_ C)).hom)) \u226b (\u03c1_ M.X).hom =\n((\u03c1_ M.X).hom \u2297 (\u03c1_ M.X).hom) \u226b M.mul :=", "model_response": "lemma mul_rightUnitor: \"(M.mul \u2297 (\u03bb_ (\ud835\udfd9_ C)).hom) \u226b (\u03c1_ M.X).hom = ((\u03c1_ M.X).hom \u2297 (\u03c1_ M.X).hom) \u226b M.mul\""}
{"gold_output": "theorem toNNReal_nat (n : \u2115) : (n : \u211d\u22650\u221e).toNNReal = n :=", "model_response": "lemma continuous_toNNReal : \"continuous toNNReal\""}
{"gold_output": "theorem iSup_approx_apply [TopologicalSpace \u03b2] [CompleteLattice \u03b2] [OrderClosedTopology \u03b2] [Zero \u03b2]\n[MeasurableSpace \u03b2] [OpensMeasurableSpace \u03b2] (i : \u2115 \u2192 \u03b2) (f : \u03b1 \u2192 \u03b2) (a : \u03b1) (hf : Measurable f)\n(h_zero : (0 : \u03b2) = \u22a5) : (\u2a06 n, (approx i f n : \u03b1 \u2192\u209b \u03b2) a) = \u2a06 (k) (_ : i k \u2264 f a), i k :=", "model_response": "lemma iSup_approx_eq_iSup_le [simp]:\n\"(\u2a06 n, (approx i f n : \u03b1 \u2192\u209b \u03b2) a) = \u2a06 (k) (_ : i k \u2264 f a), i k\""}
{"gold_output": "theorem Periodic.int_mul_eq [Ring \u03b1] (h : Periodic f c) (n : \u2124) : f (n * c) = f 0 :=", "model_response": "lemma Periodic_neg_iff [simp]: \"Periodic f c \\<longleftrightarrow> Periodic f (-c)\""}
{"gold_output": "theorem HasDerivAt.arctan (hf : HasDerivAt f f' x) :\nHasDerivAt (fun x => arctan (f x)) (1 / (1 + f x ^ 2) * f') x :=", "model_response": "lemma deriv_arctan [simp]: \"deriv (arctan o f) x = 1 / (1 + f x ^ 2) * deriv f x\""}
{"gold_output": "theorem exists_seq_norm_le_one_le_norm_sub (h : \u00acFiniteDimensional \ud835\udd5c E) :\n\u2203 (R : \u211d)(f : \u2115 \u2192 E), 1 < R \u2227 (\u2200 n, \u2016f n\u2016 \u2264 R) \u2227 \u2200 m n, m \u2260 n \u2192 1 \u2264 \u2016f m - f n\u2016 :=", "model_response": "lemma norm_prod_le_has_sum_norm:\nfixes f : \u2115 \u2192 E\nassumes \" summable (\\<lambda>n. \u2016f n\u2016)\"\nshows \"\u2016\u220f n. f n\u2016 \u2264 \u2211' n, \u2016f n\u2016\""}
{"gold_output": "theorem Units.isSMulRegular (a : R\u02e3) : IsSMulRegular M (a : R) :=", "model_response": "lemma Units.isMonoidHom: \"IsMonoidHom f\" for a :: \"R\u02e3\""}
{"gold_output": "theorem isUnit_or_isUnit [Monoid \u03b1] {p : \u03b1} (hp : Irreducible p) {a b : \u03b1} (h : p = a * b) :\nIsUnit a \u2228 IsUnit b :=", "model_response": "lemma associated_prime_irreducible:\nassumes \"prime p\" \"p dvd a\"\nshows   \"p ~\u1d64 a\""}
{"gold_output": "theorem prod_symm (e : LocalEquiv \u03b1 \u03b2) (e' : LocalEquiv \u03b3 \u03b4) :\n(e.prod e').symm = e.symm.prod e'.symm :=", "model_response": "lemma prod_coe_symm [simp]:\n\"(e.prod e').symm = e.symm.prod e'.symm\""}
{"gold_output": "theorem not_finite_iff_infinite : \u00acFinite \u03b1 \u2194 Infinite \u03b1 :=", "model_response": "lemma card_finfun_iff_pow :\n\"CARD('a \u2192\u2080 'b::finite) = CARD('b) ^ n\""}
{"gold_output": "theorem ne_zero_of_a_ne_zero (ha : P.a \u2260 0) : P.toPoly \u2260 0 :=", "model_response": "lemma leading_coeff_ne_zero [simp]: \"P.a \u2260 0\""}
{"gold_output": "theorem Functor.isZero (F : C \u2964 D) (hF : \u2200 X, IsZero (F.obj X)) : IsZero F :=", "model_response": "lemma zero_comp (F : C \u2964 D) (G : D \u2964 E) : (0 : C \u2964 D) \u22d9 G = 0 :="}
{"gold_output": "theorem of_comp_finiteType (f : A \u2192+* B) {g : B \u2192+* C} (hg : (g.comp f).FinitePresentation)\n(hf : f.FiniteType) : g.FinitePresentation :=\n-- Porting note : need to specify some instances", "model_response": "lemma mono_iff_ker_eq_bot :\n\"mono f \\<longleftrightarrow> (ker f) = bot\""}
{"gold_output": "theorem concat_nil {u v : V} (h : G.Adj u v) : nil.concat h = cons h nil :=", "model_response": "lemma concat_cons_comm {u v : V} (h : G.Adj u v) (l : List (Sym2 V)) :\n(concat (cons h nil) l).tail = concat (cons h l.tail) :="}
{"gold_output": "theorem map_finsupp_prod {\u03b1 : Type _} [Zero \u03b1] {\u03b9 : Type _} (f : \u03b9 \u2192\u2080 \u03b1) (g : \u03b9 \u2192 \u03b1 \u2192 A) :\n\u03c6 (f.prod g) = f.prod fun i a => \u03c6 (g i a) :=", "model_response": "lemma toFinsupp_injective:\n\"Function.Injective toFinsupp\""}
{"gold_output": "theorem eventually_sup {p : \u03b1 \u2192 Prop} {f g : Filter \u03b1} :\n(\u2200\u1da0 x in f \u2294 g, p x) \u2194 (\u2200\u1da0 x in f, p x) \u2227 \u2200\u1da0 x in g, p x :=", "model_response": "lemma eventually_sup_iff:\n\"{x\\<in>f\\<squnion>g. p x} = {x\\<in>f. p x} \\<inter> {x\\<in>g. p x}\""}
{"gold_output": "theorem div_le_div_flip {\u03b1 : Type _} [CommGroup \u03b1] [LinearOrder \u03b1]\n[CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] {a b : \u03b1} : a / b \u2264 b / a \u2194 a \u2264 b :=", "model_response": "lemma flip_le_iff_le:\nassumes \"covariant_class \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)\"\nshows \"flip a \\<le> flip b \\<longleftrightarrow> b \\<le> a\""}
{"gold_output": "theorem Pairwise.mono (hr : Pairwise r) (h : \u2200 \u2983i j\u2984, r i j \u2192 p i j) : Pairwise p :=", "model_response": "lemma pairwise_imp_exists_unique_witness:\nassumes \"pairwise r\" and \"\\<And>i j. r i j \\<Longrightarrow> \\<exists>!a. p i a \\<and> p j a\"\nshows \"pairwise p\""}
{"gold_output": "theorem continuousOn_iff' {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} :\nContinuousOn f s \u2194 \u2200 t : Set \u03b2, IsOpen t \u2192 \u2203 u, IsOpen u \u2227 f \u207b\u00b9' t \u2229 s = u \u2229 s :=", "model_response": "lemma continuousOn_iff_open_preimage:\n\"ContinuousOn f s \\<longleftrightarrow> (\\<forall>t. IsOpen t \\<longrightarrow> (\\<exists>u. IsOpen u \\<and> f \u207b\u00b9' t \\<inter> s = u \\<inter> s))\""}
{"gold_output": "theorem AddMonoid.End.coe_pow {A} [AddMonoid A] (f : AddMonoid.End A) (n : \u2115) : \u21d1(f ^ n) = f^[n] :=", "model_response": "theorem toFun_mk': \"toFun (mk' f h) = f\""}
{"gold_output": "theorem map_uncurry_zip_eq_zipWith (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l : List \u03b1) (l' : List \u03b2) :\nmap (Function.uncurry f) (l.zip l') = zipWith f l l' :=", "model_response": "lemma continuousWithinAt_prod_swap:\n\"continuousWithinAt f s x \\<longleftrightarrow> continuousWithinAt (\\<lambda>(x, y). f x y) (s \\<times> t) x\""}
{"gold_output": "theorem norm_eq_one_iff_mem_unitary {d : \u2124} {a : \u2124\u221ad} : a.norm = 1 \u2194 a \u2208 unitary (\u2124\u221ad) :=", "model_response": "lemma norm_eq_1_iff_mem_unitary [simp]: \"a.norm = 1 \u2194 a \u2208 unitary (\u2124\u221ad)\""}
{"gold_output": "theorem mapEvalEquiv_apply [FiniteDimensional K V] (W : Subspace K V) :\nmapEvalEquiv K V W = W.map (eval K V) :=", "model_response": "lemma map_injective [simp]: \"injective (W.map (eval K V))\""}
{"gold_output": "theorem mapsTo_union : MapsTo f (s\u2081 \u222a s\u2082) t \u2194 MapsTo f s\u2081 t \u2227 MapsTo f s\u2082 t :=", "model_response": "lemma continuousOn_union_iff [simp]:\n\"continuousOn f (s\\<^sub>1 \\<union> s\\<^sub>2) \\<longleftrightarrow> continuousOn f s\\<^sub>1 \\<and> continuousOn f s\\<^sub>2\""}
{"gold_output": "theorem rotate_eq_iff {l l' : List \u03b1} {n : \u2115} :\nl.rotate n = l' \u2194 l = l'.rotate (l'.length - n % l'.length) :=", "model_response": "lemma rotate_eq_iff_eq_rotate:\nassumes \"length l = length l'\"\nshows \"l.rotate n = l' \\<longleftrightarrow> l = l'.rotate n\""}
{"gold_output": "theorem div_lt_div_iff_right (c : \u03b1) : a / c < b / c \u2194 a < b :=", "model_response": "lemma toIcoMod_eq_sub_toIcoDiv_zsmul: \"toIcoMod hp a b = b - toIcoDiv hp a b \u2022 p\""}
{"gold_output": "theorem Directed.convex_iUnion {\u03b9 : Sort _} {s : \u03b9 \u2192 Set E} (hdir : Directed (\u00b7 \u2286 \u00b7) s)\n(hc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)) : Convex \ud835\udd5c (\u22c3 i, s i) :=", "model_response": "lemma convex_hull_iUnion {\u03b9 : Sort _} {s : \u03b9 \u2192 Set E} (hdir : Directed (\u00b7 \u2286 \u00b7) s)\n(hc : \u2200 \u2983i : \u03b9\u2984, Convex \ud835\udd5c (s i)) : convex hull \u22c3 i, s i = \u22c3 i, convex hull s i :="}
{"gold_output": "theorem nhds_top_basis : (\ud835\udcdd \u221e).HasBasis (fun a => a < \u221e) fun a => Ioi a :=", "model_response": "lemma tendsto_of_real_nhds_top: \"Tendsto of_real atTop (\ud835\udcdd \u221e)\""}
{"gold_output": "theorem comp_id (f : \u03b1 \u2192CO \u03b2) : f.comp (ContinuousOpenMap.id \u03b1) = f :=", "model_response": "lemma id_comp (f : \u03b1 \u2192CO \u03b3) : (ContinuousOpenMap.id \u03b2).comp f = f :="}
{"gold_output": "theorem _root_.Subgroup.ker_subtype (H : Subgroup G) : H.subtype.ker = \u22a5 :=", "model_response": "theorem subgroup_stabilizer_eq_self: \"{ x : G | x \\<in> H } = H\""}
{"gold_output": "theorem comp_snoc {\u03b1 : Type _} {\u03b2 : Type _} (g : \u03b1 \u2192 \u03b2) (q : Fin n \u2192 \u03b1) (y : \u03b1) :\ng \u2218 snoc q y = snoc (g \u2218 q) (g y) :=", "model_response": "lemma comp_snoc: \"(snoc q y) \u2218 g = snoc (g \u2218 q) (g y)\""}
{"gold_output": "theorem isNoetherian_of_submodule_of_noetherian (R M) [Semiring R] [AddCommMonoid M] [Module R M]\n(N : Submodule R M) (h : IsNoetherian R M) : IsNoetherian R N :=", "model_response": "lemma noetherian_submodule_incl_set_incl :\n\"{ x \\<in> carrier M. x \\<in> N } \\<subseteq> N\""}
{"gold_output": "theorem comp_assoc (f : \u03b3 \u2192CO \u03b4) (g : \u03b2 \u2192CO \u03b3) (h : \u03b1 \u2192CO \u03b2) :\n(f.comp g).comp h = f.comp (g.comp h) :=", "model_response": "lemma ofReal_toReal_comp :\n\"ofRealClm \\<circ> toRealClm = (id::real \\<Rightarrow> real)\""}
{"gold_output": "theorem IsCompactOperator.comp_clm [AddCommMonoid M\u2082] [Module R\u2082 M\u2082] {f : M\u2082 \u2192 M\u2083}\n(hf : IsCompactOperator f) (g : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) : IsCompactOperator (f \u2218 g) :=", "model_response": "lemma ofCompact_comp_toCompact[simp]: \"ofCompact R\u2082 M\u2082 (toCompact R\u2082 M\u2082 f) = f\""}
{"gold_output": "theorem uniformity_edist : \ud835\udce4 \u03b3 = \u2a05 \u03b5 > 0, \ud835\udcdf { p : \u03b3 \u00d7 \u03b3 | edist p.1 p.2 < \u03b5 } :=", "model_response": "lemma Metric.uniformity_edist:\n\"\ud835\udce4 \u03b3 = \u2a05 \u03b5 > 0. \ud835\udcdf { p : \u03b3 \u00d7 \u03b3 | edist p.1 p.2 < \u03b5 }\""}
{"gold_output": "theorem invOfMemRange_surjective : Function.Surjective f.invOfMemRange :=", "model_response": "lemma inv_ofDual_eq [simp]:\n\"inv (ofDual::'a::type \\<Rightarrow> 'a dual) = toDual\""}
{"gold_output": "theorem Subsingleton.monovaryOn [Subsingleton \u03b9] (f : \u03b9 \u2192 \u03b1) (g : \u03b9 \u2192 \u03b2) (s : Set \u03b9) :\nMonovaryOn f g s :=", "model_response": "lemma monovaryOn_refl [simp]: \"monovaryOn f f s\""}
{"gold_output": "theorem PreEnvelGroupRel.refl {R : Type u} [Rack R] {a : PreEnvelGroup R} :\nPreEnvelGroupRel R a a :=", "model_response": "lemma preEnvelGroupRel_refl:\nassumes \"a \\<in> PreEnvelGroup R\"\nshows \"PreEnvelGroupRel R a a\""}
{"gold_output": "theorem hall_cond_of_compl {\u03b9 : Type u} {t : \u03b9 \u2192 Finset \u03b1} {s : Finset \u03b9}\n(hus : s.card = (s.biUnion t).card) (ht : \u2200 s : Finset \u03b9, s.card \u2264 (s.biUnion t).card)\n(s' : Finset (s\u1d9c : Set \u03b9)) : s'.card \u2264 (s'.biUnion fun x' => t x' \\ s.biUnion t).card :=", "model_response": "lemma card_funcset_fin_eq_pow:\n\"card (Set.Fin (n::nat) \\<rightarrow> Set.Fin (m::nat)) = (card (Set.Fin n)) ^ m\""}
{"gold_output": "theorem exists_norm_le_le_norm_sub_of_finset {c : \ud835\udd5c} (hc : 1 < \u2016c\u2016) {R : \u211d} (hR : \u2016c\u2016 < R)\n(h : \u00acFiniteDimensional \ud835\udd5c E) (s : Finset E) : \u2203 x : E, \u2016x\u2016 \u2264 R \u2227 \u2200 y \u2208 s, 1 \u2264 \u2016y - x\u2016 :=", "model_response": "lemma norm_smul_le_norm_mul_norm {a : \ud835\udd5c} (hc : 1 < \u2016a\u2016) {R : \u211d} (hR : \u2016a\u2016 < R)\n(h : \u00acFiniteDimensional \ud835\udd5c E) (s : Finset E) : \u2203 x : E, \u2016x\u2016 \u2264 R \u2227 \u2200 y \u2208 s, 1 \u2264 \u2016y - x\u2016 :="}
{"gold_output": "theorem setToL1_nonneg {T : Set \u03b1 \u2192 G' \u2192L[\u211d] G''} {C : \u211d} (hT : DominatedFinMeasAdditive \u03bc T C)\n(hT_nonneg : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 \u2200 x, 0 \u2264 x \u2192 0 \u2264 T s x) {f : \u03b1 \u2192\u2081[\u03bc] G'}\n(hf : 0 \u2264 f) : 0 \u2264 setToL1 hT f :=", "model_response": "lemma setToL1_eq_integral:\n\"setToL1 hT f = (\\<integral>\\<^sup>+g : lp G 1 \u03bc. ennreal (\u27eaf, g\u27eb) \\<partial>\u03bc)\""}
{"gold_output": "theorem insertNth_length_self (l : List \u03b1) (x : \u03b1) : insertNth l.length x l = l ++ [x] :=", "model_response": "lemma insertNth_length_succ :\nassumes \"i \\<le> length l\"\nshows \"insertNth (i + 1) x l = insertNth i x l\""}
{"gold_output": "theorem affineIsometryOfStrictConvexSpace_apply {f : PF \u2192 PE} (hi : Isometry f) (p : PF) :\nhi.affineIsometryOfStrictConvexSpace p = f p :=", "model_response": "lemma continuousAt_iff_continuousAt {f : PF \u2192 PE} {x : PF} :\nContinuousAt f x \u2194 ContinuousAt f x :="}
{"gold_output": "theorem div_eq_one_iff_eq (h : IsUnit b) : a / b = 1 \u2194 a = b :=", "model_response": "lemma toAddSubmonoid_injective :\n\"Function.Injective (toAddSubmonoid : Submodule R M \u2192 AddSubmonoid M)\""}
{"gold_output": "theorem comap_equiv_eq_map_symm (f : N \u2243* M) (K : Submonoid M) :\nK.comap f.toMonoidHom = K.map f.symm.toMonoidHom :=", "model_response": "lemma comap_top : \"comap f \u22a4 = map f.symm \u22a4\""}
{"gold_output": "theorem mk'_num_den' (x : K) : algebraMap A K (num A x) / algebraMap A K (den A x) = x :=", "model_response": "lemma num_fract [simp]: \"num A (fract A x) = fract A (num A x)\""}
{"gold_output": "theorem range_familyOfBFamily' {\u03b9 : Type u} (r : \u03b9 \u2192 \u03b9 \u2192 Prop) [IsWellOrder \u03b9 r] {o}\n(ho : type r = o) (f : \u2200 a < o, \u03b1) : range (familyOfBFamily' r ho f) = brange o f :=", "model_response": "lemma range_familyOfBFamily':\n\"range (familyOfBFamily' r ho f) = brange o f\""}
{"gold_output": "theorem iterate_iterate (h : Commute f g) (m n : \u2115) : Commute (f^[m]) (g^[n]) :=", "model_response": "lemma of_nat_injective:\n\"injective of_nat\""}
{"gold_output": "theorem disjoint_atTop_principal_Iic [Preorder \u03b1] [NoMaxOrder \u03b1] (x : \u03b1) :\nDisjoint atTop (\ud835\udcdf (Iic x)) :=", "model_response": "lemma disjoint_atTop_principal_Iic [simp]: \"disjoint atTop (\ud835\udcdf (Iic x))\""}
{"gold_output": "theorem ext_of_generate_finite (C : Set (Set \u03b1)) (hA : m0 = generateFrom C) (hC : IsPiSystem C)\n[IsFiniteMeasure \u03bc] (h\u03bc\u03bd : \u2200 s \u2208 C, \u03bc s = \u03bd s) (h_univ : \u03bc univ = \u03bd univ) : \u03bc = \u03bd :=", "model_response": "lemma measure_eq_on_univ : \"measure \u03bc univ = measure \u03bd univ\""}
{"gold_output": "theorem mk_mul_mk (x y : M) (hx : x \u2208 S') (hy : y \u2208 S') :\n(\u27e8x, hx\u27e9 : S') * \u27e8y, hy\u27e9 = \u27e8x * y, mul_mem hx hy\u27e9 :=", "model_response": "lemma mk_mul_mk [simp]:\n\"(\u27e8x, hx\u27e9 : S') * \u27e8y, hy\u27e9 = \u27e8x * y, mul_mem hx hy\u27e9\""}
{"gold_output": "theorem finprod_eq_of_bijective {f : \u03b1 \u2192 M} {g : \u03b2 \u2192 M} (e : \u03b1 \u2192 \u03b2) (he\u2080 : Bijective e)\n(he\u2081 : \u2200 x, f x = g (e x)) : (\u220f\u1da0 i, f i) = \u220f\u1da0 j, g j :=", "model_response": "lemma finprod_eq_of_bij: \"(\\<And>x. f x = g (e x)) \\<Longrightarrow> summable f \\<longleftrightarrow> summable g\""}
{"gold_output": "theorem op_surjective : Surjective (op : \u03b1 \u2192 \u03b1\u1d50\u1d52\u1d56) :=", "model_response": "lemma surjective_unop [simp]: \"surjective (unop : \u03b1\u1d50\u1d52\u1d56 \u2192 \u03b1)\" if \"hasOp \u03b1\""}
{"gold_output": "theorem HasDerivAtFilter.const_smul (c : R) (hf : HasDerivAtFilter f f' x L) :\nHasDerivAtFilter (fun y => c \u2022 f y) (c \u2022 f') x L :=", "model_response": "lemma deriv_const_smul (c : R) (hf : HasDerivAtFilter f f' x L) :\nderiv (fun y => c \u2022 x) x = c \u2022 deriv f x :="}
{"gold_output": "theorem chain'_iff_pairwise [IsTrans \u03b1 R] : \u2200 {l : List \u03b1}, Chain' R l \u2194 Pairwise R l", "model_response": "lemma chain'_coe [simp]:\nshows \"chain' R (list_of xs) \\<longleftrightarrow> chain R xs\""}
{"gold_output": "theorem FamilyOfElements.Compatible.compPresheafMap (f : P \u27f6 Q) {x : FamilyOfElements P R}\n(h : x.Compatible) : (x.compPresheafMap f).Compatible :=", "model_response": "lemma const_comp (a : A) : (const A a).comp F = const (F.obj <| op a) (F.map a) :="}
{"gold_output": "theorem mul_sup (a b c : \u211d\u22650) : a * (b \u2294 c) = a * b \u2294 a * c :=", "model_response": "lemma mul_sup_distrib : a * (b \u2294 c) = a * b \u2294 a * c :="}
{"gold_output": "theorem exists\u2082_comm {\u03ba\u2081 : \u03b9\u2081 \u2192 Sort _} {\u03ba\u2082 : \u03b9\u2082 \u2192 Sort _} {p : \u2200 i\u2081, \u03ba\u2081 i\u2081 \u2192 \u2200 i\u2082, \u03ba\u2082 i\u2082 \u2192 Prop} :\n(\u2203 i\u2081 j\u2081 i\u2082 j\u2082, p i\u2081 j\u2081 i\u2082 j\u2082) \u2194 \u2203 i\u2082 j\u2082 i\u2081 j\u2081, p i\u2081 j\u2081 i\u2082 j\u2082 :=", "model_response": "lemma exists_swap [swap_intro]:\nassumes \"(\\<exists>x y. P x y)\"\nshows \"(\\<exists>y x. P x y)\""}
{"gold_output": "theorem trailingDegree_one_le : (0 : \u2115\u221e) \u2264 trailingDegree (1 : R[X]) :=", "model_response": "lemma trailingDegree_one : trailingDegree (1 : R[X]) = 0 :="}
{"gold_output": "theorem infinitePos_mul_of_infiniteNeg_not_infinitesimal_neg {x y : \u211d*} :\nInfiniteNeg x \u2192 \u00acInfinitesimal y \u2192 y < 0 \u2192 InfinitePos (x * y) :=", "model_response": "lemma infinitePos_mul_iff:\n\"infinitePos (x * y) \\<longleftrightarrow> (infiniteNeg x \\<and> not_infinitesimal y \\<and> y < 0) \\<or> (infinitePos x \\<and> not_infinitesimal y \\<and> y > 0)\""}
{"gold_output": "theorem exists_measurable_nonneg {\u03b2} [Preorder \u03b2] [Zero \u03b2] {m\u03b2 : MeasurableSpace \u03b2} {f : \u03b1 \u2192 \u03b2}\n(hf : AEMeasurable f \u03bc) (f_nn : \u2200\u1d50 t \u2202\u03bc, 0 \u2264 f t) : \u2203 g, Measurable g \u2227 0 \u2264 g \u2227 f =\u1d50[\u03bc] g :=", "model_response": "lemma aemeasurable_indicator_iff [simp]:\n\"(AEMeasurable f (\u03bc.restrict s)) = (AEMeasurable (indicator s f) \u03bc)\""}
{"gold_output": "theorem LeftInvOn.mono (hf : LeftInvOn f' f s) (ht : s\u2081 \u2286 s) : LeftInvOn f' f s\u2081 :=", "model_response": "lemma injOn_iff_injOn' : \"injOn f s \\<longleftrightarrow> injOn f' s'\""}
{"gold_output": "theorem iterToSum_C_X (c : S\u2082) : iterToSum R S\u2081 S\u2082 (C (X c)) = X (Sum.inr c) :=", "model_response": "lemma iterToSum_X_C_right [simp]: \"iterToSum R S\u2081 S\u2082 (C (X c)) = X (Sum.inr c)\""}
{"gold_output": "theorem rtakeWhile_eq_nil_iff : rtakeWhile p l = [] \u2194 \u2200 hl : l \u2260 [], \u00acp (l.getLast hl) :=", "model_response": "lemma rtakeWhile_eq_nil_iff:\nassumes \"l \\<noteq> []\"\nshows \"rtakeWhile p l = [] \\<longleftrightarrow> (\\<forall>hl : l \\<noteq> [] \\<longrightarrow> \\<not> p (l.getLast hl))\""}
{"gold_output": "theorem coeff_coe (n : \u03c3 \u2192\u2080 \u2115) : MvPowerSeries.coeff R n \u2191\u03c6 = coeff n \u03c6 :=", "model_response": "lemma coeff_coe : \"MvPowerSeries.coeff R n (\u03c6 :: 'a :: ring_1 mps) = coeff n \u03c6\""}
{"gold_output": "theorem eq_one_iff_not_exists_prime_dvd {n : \u2115} : n = 1 \u2194 \u2200 p : \u2115, p.Prime \u2192 \u00acp \u2223 n :=", "model_response": "lemma set_compr_eq_finset_of : { a | a \u2264 n \u2227 P a } = { a \u2208 finset_of n . P a } :="}
{"gold_output": "theorem left_eq_id {X Y : StructuredArrow S T} (f : X \u27f6 Y) :\nf.left = \ud835\udfd9 _ :=", "model_response": "lemma id_right_id_left [simp]:\n\"(\ud835\udfd9 X).left \u226b (iso (\ud835\udfd9 X).right).hom = (\ud835\udfd9 X).left\""}
{"gold_output": "theorem mem_lieSpan {x : M} : x \u2208 lieSpan R L s \u2194 \u2200 N : LieSubmodule R L M, s \u2286 N \u2192 x \u2208 N :=", "model_response": "lemma lieSpan_lie_mem_iff :\n\"\u2045x, m\u2046 \u2208 lieSpan R L I N \u2194 m \u2208 N\""}
{"gold_output": "theorem unpair_pair (a b : \u2115) : unpair (pair a b) = (a, b) :=", "model_response": "lemma pair_unpair :\nassumes \"pair a b = unpair x\"\nshows \"x = pair a b\""}
{"gold_output": "theorem IsBigOWith.trans_isLittleO (hfg : IsBigOWith c l f g) (hgk : g =o[l] k) (hc : 0 < c) :\nf =o[l] k :=", "model_response": "lemma isLittleO_prod_left_iff [simp]:\n\"(\\<lambda>x. (f' x, g' x)) =o[l] k  \\<longleftrightarrow> f' =o[l] k \\<and> g' =o[l] k\""}
{"gold_output": "theorem minFac_lemma (n k : \u2115) (h : \u00acn < k * k) : sqrt n - k < sqrt n + 2 - k :=", "model_response": "lemma sqrt_le_sqrt_add_two (n : \u2115) : sqrt n \u2264 sqrt (n + 2) :="}
{"gold_output": "theorem mk_quaternion_of_infinite [Infinite R] : (#\u210d[R]) = (#R) :=", "model_response": "theorem mk_quaternion_of_infinite (R : Type u) [Ring R] [Infinite R] : (#\u210d[R]) = (#R) :="}
{"gold_output": "theorem ContinuousLinearMap.norm_iteratedFDeriv_le_of_bilinear (B : E \u2192L[\ud835\udd5c] F \u2192L[\ud835\udd5c] G) {f : D \u2192 E}\n{g : D \u2192 F} {N : \u2115\u221e} (hf : ContDiff \ud835\udd5c N f) (hg : ContDiff \ud835\udd5c N g) (x : D) {n : \u2115}\n(hn : (n : \u2115\u221e) \u2264 N) :\n\u2016iteratedFDeriv \ud835\udd5c n (fun y => B (f y) (g y)) x\u2016 \u2264 \u2016B\u2016 * \u2211 i in Finset.range (n + 1),\n(n.choose i : \u211d) * \u2016iteratedFDeriv \ud835\udd5c i f x\u2016 * \u2016iteratedFDeriv \ud835\udd5c (n - i) g x\u2016 :=", "model_response": "lemma norm_iteratedFDeriv_le_of_bilinear:\n\"norm (iteratedFDeriv \ud835\udd5c n (\\<lambda>y. B (f y) (g y)) x) \\<le>\nnorm B * \u2211 i in Finset.range (n + 1), (n.choose i : \u211d) * norm (iteratedFDeriv \ud835\udd5c i f x) *\nnorm (iteratedFDeriv \ud835\udd5c (n - i) g x)\""}
{"gold_output": "theorem toFunLinear_tmul_apply (a : A) (p : R[X]) :\ntoFunLinear R A (a \u2297\u209c[R] p) = toFunBilinear R A a p :=", "model_response": "lemma toFunLinear_tmul_eq: \"toFunLinear R A (a \u2297\u209c[R] p) = toFunBilinear R A a p\""}
{"gold_output": "theorem le_trans : \u2200 {a b c : \u03b1}, a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c :=", "model_response": "lemma le_of_lt_tsub:\nassumes \"a < b\"\nshows \"a \\<le> b - a\""}
{"gold_output": "theorem empty_mem_powerset (s : Finset \u03b1) : \u2205 \u2208 powerset s :=", "model_response": "lemma empty_mem_finset : \"\u2205 \u2208 finset\""}
{"gold_output": "theorem _root_.isAntichain_insert :\nIsAntichain r (insert a s) \u2194 IsAntichain r s \u2227 \u2200 \u2983b\u2984, b \u2208 s \u2192 a \u2260 b \u2192 \u00acr a b \u2227 \u00acr b a :=", "model_response": "lemma refl_rtrancl_eq_trancl :\n\"{ a . r\\<^sup>*\\<^sup>* a a } = { a . r\\<^sup>+\\<^sup>+ a a }\""}
{"gold_output": "theorem Range.isSubmonoid {\u03b3 : Type _} [Monoid \u03b3] {f : M \u2192 \u03b3} (hf : IsMonoidHom f) :\nIsSubmonoid (Set.range f) :=", "model_response": "theorem inverse_range_is_submonoid : IsSubmonoid (Set.range (inverse : M \u2192 \u03b3)) :="}
{"gold_output": "theorem add_lt_top {x y : EReal} (hx : x \u2260 \u22a4) (hy : y \u2260 \u22a4) : x + y < \u22a4 :=", "model_response": "lemma of_nat_add_of_nat : (of_nat m + of_nat n : EReal) = of_nat (m + n) :="}
{"gold_output": "theorem tsub_lt_tsub_iff_left_of_le_of_le [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 < \u00b7)]\n(hb : AddLECancellable b) (hab : AddLECancellable (a - b)) (h\u2081 : b \u2264 a) (h\u2082 : c \u2264 a) :\na - b < a - c \u2194 c < b :=", "model_response": "lemma toIcoMod_inj_right [simp]: \"toIcoMod hp a b = toIcoMod hp a c \u2194 b = c\""}
{"gold_output": "theorem C_add : C (a + b) = C a + C b :=", "model_response": "lemma toMulBot_add :\n\"toMulBot (a + b) = toMulBot a + toMulBot b\""}
{"gold_output": "theorem filter_zero : filter p 0 = 0 :=", "model_response": "lemma filter_eq_filter' {s} : filter p s = filter' s :="}
{"gold_output": "theorem ContDiffAt.hasStrictDerivAt {f : \ud835\udd42 \u2192 F'} {x : \ud835\udd42} (hf : ContDiffAt \ud835\udd42 n f x) (hn : 1 \u2264 n) :\nHasStrictDerivAt f (deriv f x) x :=", "model_response": "lemma deriv_neg' : \"deriv (\\<lambda>w. - f w) x = - deriv f x\""}
{"gold_output": "theorem BilinForm.toMatrix_basisFun :\nBilinForm.toMatrix (Pi.basisFun R\u2082 n) = BilinForm.toMatrix' :=", "model_response": "lemma toMatrix\u2082'_eq_toMatrix\u2082: \"toMatrix\u2082' = toMatrix\u2082\""}
{"gold_output": "theorem map_le_map_iff' {f : F} (hf : ker f = \u22a5) {p p'} : map f p \u2264 map f p' \u2194 p \u2264 p' :=", "model_response": "lemma map_bot (f : F) (hf : ker f = \u22a5) : map f \u22a5 = \u22a5 :="}
{"gold_output": "theorem swap_mul_eq_mul_swap (f : Perm \u03b1) (x y : \u03b1) : swap x y * f = f * swap (f\u207b\u00b9 x) (f\u207b\u00b9 y) :=", "model_response": "lemma inv_swap_mul [simp]:\n\"(swap x y)\u207b\u00b9 = swap x y\""}
{"gold_output": "theorem image_subtype_univ_ssubset_image_univ [Fintype \u03b1] [DecidableEq \u03b2] (k : \u03b2) (b : \u03b1 \u2192 \u03b2)\n(hk : k \u2208 Finset.image b univ) (p : \u03b2 \u2192 Prop) [DecidablePred p] (hp : \u00acp k) :\nimage (fun i : { a // p (b a) } => b \u2191i) univ \u2282 image b univ :=", "model_response": "lemma image_coe_subtype_eq_image_subtype [simp]:\n\"(image (fun (i : { a // p a }) => (b i : \u03b1)) { x // p x }) = image b { x | x \u2208 { x // p x }. p (b x) }\""}
{"gold_output": "theorem HasFDerivWithinAt.csin (hf : HasFDerivWithinAt f f' s x) :\nHasFDerivWithinAt (fun x => Complex.sin (f x)) (Complex.cos (f x) \u2022 f') s x :=", "model_response": "lemma fderiv_csin: \"fderiv  (\\<lambda>x. Complex.sin (f x)) s x = Complex.cos (f x) \u2022 fderiv f s x\""}
{"gold_output": "theorem Fintype.card_coe (s : Finset \u03b1) [Fintype s] : Fintype.card s = s.card :=", "model_response": "lemma card_lists (\u03b1) [simp]: \"CARD('a list) = sum fun n => CARD('a) ^ n\""}
{"gold_output": "theorem hasFTaylorSeriesUpToOn_univ_iff :\nHasFTaylorSeriesUpToOn n f p univ \u2194 HasFTaylorSeriesUpTo n f p :=", "model_response": "lemma hasFTaylorSeriesUpToOn_univ_iff :\n\"hasFTaylorSeriesUpToOn n f p univ \\<longleftrightarrow> hasFTaylorSeriesUpTo n f p\""}
{"gold_output": "theorem head_zero : vecHead (0 : Fin n.succ \u2192 \u03b1) = 0 :=", "model_response": "lemma vecHead_zero [simp]: \"vecHead (0 : Fin n.succ \u2192 \u03b1) = 0\""}
{"gold_output": "theorem integral_radius_zero (f : \u2102 \u2192 E) (c : \u2102) : (\u222e z in C(c, 0), f z) = 0 :=", "model_response": "lemma integral_circle_eq_zero_iff_radius_neg :\n\"(\u222e z in C c r, f z) = 0 \\<longleftrightarrow> r < 0\""}
{"gold_output": "theorem contDiffOn_succ_of_fderiv_apply [FiniteDimensional \ud835\udd5c E] {n : \u2115} {f : E \u2192 F} {s : Set E}\n(hf : DifferentiableOn \ud835\udd5c f s) (h : \u2200 y, ContDiffOn \ud835\udd5c n (fun x => fderivWithin \ud835\udd5c f s x y) s) :\nContDiffOn \ud835\udd5c (n + 1 : \u2115) f s :=", "model_response": "lemma contDiffOn_succ_iff_fderivWithin:\n\"contDiffOn \ud835\udd5c (n + 1 : \u2115) f s \\<longleftrightarrow>\n(\\<forall>x\\<in>s. DifferentiableWithinAt \ud835\udd5c f s x \\<and> contDiffOn \ud835\udd5c n (fun x => fderivWithin \ud835\udd5c f s x) s x)\""}
{"gold_output": "theorem complete_of_cauchySeq_tendsto :\n(\u2200 u : \u2115 \u2192 \u03b1, CauchySeq u \u2192 \u2203 a, Tendsto u atTop (\ud835\udcdd a)) \u2192 CompleteSpace \u03b1 :=", "model_response": "lemma atTop_empty : {a | a < a} = \u2205 :="}
{"gold_output": "theorem splits_map_iff (j : L \u2192+* F) {f : K[X]} : Splits j (f.map i) \u2194 Splits (j.comp i) f :=", "model_response": "lemma injective_i: \"Function.Injective i\""}
{"gold_output": "theorem lf_def {x y : PGame} :\nx \u29cf y \u2194\n(\u2203 i, (\u2200 i', x.moveLeft i' \u29cf y.moveLeft i) \u2227 \u2200 j, x \u29cf (y.moveLeft i).moveRight j) \u2228\n\u2203 j, (\u2200 i, (x.moveRight j).moveLeft i \u29cf y) \u2227 \u2200 j', x.moveRight j \u29cf y.moveRight j' :=", "model_response": "lemma finite_le_nat [simp]: \"finite {(i, j) | i j :: nat. i \u2264 j}\""}
{"gold_output": "theorem bliminf_or_le_inf_aux_left : (bliminf u f fun x => p x \u2228 q x) \u2264 bliminf u f p :=", "model_response": "lemma measurableSet_subtype_left [measurable (raw)]:\n\"{x\\<in>space M. p x} \\<in> sets M\""}
{"gold_output": "theorem map_nonempty : (s.map f).Nonempty \u2194 s.Nonempty :=", "model_response": "lemma inj_on_iff_subsingleton_image : \"inj_on f s \\<longleftrightarrow> (subsingleton (f '' s))\""}
{"gold_output": "theorem sumAssoc_symm_apply_inr_inr {\u03b1 \u03b2 \u03b3} (c) : (sumAssoc \u03b1 \u03b2 \u03b3).symm (inr (inr c)) = inr c :=", "model_response": "lemma sumAssoc_inr_inr:\nshows \"(sumAssoc \u03b1 \u03b2 \u03b3).symm (inr (inr c)) = inr c\""}
{"gold_output": "theorem invAct_apply (x y : R) : (act' x)\u207b\u00b9 y = x \u25c3\u207b\u00b9 y :=", "model_response": "lemma invAct_def: \"invAct x y = (x \u25c3 y)\u207b\u00b9\""}
{"gold_output": "theorem biprod.map_fst {W X Y Z : C} [HasBinaryBiproduct W X] [HasBinaryBiproduct Y Z] (f : W \u27f6 Y)\n(g : X \u27f6 Z) : biprod.map f g \u226b biprod.fst = biprod.fst \u226b f :=", "model_response": "lemma biprod.fst_inl [simp]: \"biprod.fst \u226b biprod.inl = biprod.fst\""}
{"gold_output": "theorem map_map_permutations'Aux (f : \u03b1 \u2192 \u03b2) (t : \u03b1) (ts : List \u03b1) :\nmap (map f) (permutations'Aux t ts) = permutations'Aux (f t) (map f ts) :=", "model_response": "lemma permutations_set_altdef:\n\"set (permutations xs) = foldl (\\<lambda>A x. A \\<union> {ys. ys \\<in> A \\<and> x # ys \\<in> permutations xs}) {[]} xs\""}
{"gold_output": "theorem Ioc_union_Ico_eq_Ioo (h\u2081 : a < b) (h\u2082 : b < c) : Ioc a b \u222a Ico b c = Ioo a c :=", "model_response": "lemma Ioc_union_Ico_eq_Ioo: \"Ioc a b \u222a Ico b c = Ioo a c\""}
{"gold_output": "theorem IsPositive.inner_nonneg_left {T : E \u2192L[\ud835\udd5c] E} (hT : IsPositive T) (x : E) :\n0 \u2264 re \u27eaT x, x\u27eb :=", "model_response": "lemma inner_self_nonneg {x : E} : 0 \u2264 re \u27eax, x\u27eb :="}
{"gold_output": "theorem inv_reindex (e\u2081 e\u2082 : n \u2243 m) (A : Matrix n n \u03b1) : (reindex e\u2081 e\u2082 A)\u207b\u00b9 = reindex e\u2082 e\u2081 A\u207b\u00b9 :=", "model_response": "lemma inv_reindex_reindex_apply [simp]:\n\"(reindex e\u2081 e\u2082 A)\u207b\u00b9 = reindex e\u2082.symm e\u2081.symm A\u207b\u00b9\""}
{"gold_output": "theorem ideal_prod_eq (I : Ideal (R \u00d7 S)) :\nI = Ideal.prod (map (RingHom.fst R S) I : Ideal R) (map (RingHom.snd R S) I) :=", "model_response": "lemma continuousAt: \"continuousAt f x\""}
{"gold_output": "theorem snd_imK_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n(dualNumberEquiv.symm d).imK.snd = d.snd.imK :=", "model_response": "lemma snd_imK_dualNumberEquiv_symm_1_0_0_0 [simp]:\n\"(dualNumberEquiv.symm (1, 0, 0, 0)).snd.imK = 0\""}
{"gold_output": "theorem wbtw_swap_right_iff [NoZeroSMulDivisors R V] (x : P) {y z : P} :\nWbtw R x y z \u2227 Wbtw R x z y \u2194 y = z :=", "model_response": "lemma wbtw_swap_right_iff:\n\"{y. Wbtw R x y z} = {y. Wbtw R x z y}\""}
{"gold_output": "theorem trans_bot (f : \u03b1 \u2243. \u03b2) : f.trans (\u22a5 : \u03b2 \u2243. \u03b3) = \u22a5 :=", "model_response": "lemma bot_trans [simp]:\n\"(\u22a5 : \u03b1 \u2243. \u03b2).trans f = \u22a5\""}
{"gold_output": "theorem Subsingleton.le [Preorder \u03b1] [Subsingleton \u03b1] (x y : \u03b1) : x \u2264 y :=", "model_response": "lemma subsingleton_le [simp]:\nassumes \"subsingleton \u03b1\"\nshows \"x \\<le> y\" for x y :: \u03b1"}
{"gold_output": "theorem mul_mul_div (a : \u03b1) (h : IsUnit b) : a * b * (1 / b) = a :=", "model_response": "lemma is_unit_div :\nassumes \"IsUnit b\"\nshows \"IsUnit (a / b)\""}
{"gold_output": "theorem Convex.strictConvex' {s : Set E} (hs : Convex \ud835\udd5c s)\n(h : (s \\ interior s).Pairwise fun x y => \u2203 c : \ud835\udd5c, lineMap x y c \u2208 interior s) :\nStrictConvex \ud835\udd5c s :=", "model_response": "lemma interior_subset {s : Set E} (hs : Convex \ud835\udd5c s) : interior s \u2286 s :="}
{"gold_output": "theorem baseChange_eq_ltensor : (f.baseChange A : A \u2297 M \u2192 A \u2297 N) = f.lTensor A :=", "model_response": "lemma symm_comp_toLinearMap :\n\"(LinearEquiv.symm R M N).toLinearMap.comp (toLinearMap R M N) = LinearMap.id R N\""}
{"gold_output": "theorem equivRealProd_apply_le (z : \u2102) : \u2016equivRealProd z\u2016 \u2264 abs z :=", "model_response": "lemma norm_exp_eq_norm_exp_re (z : \u2102) : \u2016exp z\u2016 = \u2016exp z.re\u2016 :="}
{"gold_output": "theorem mul_self_lt_mul_self (h1 : 0 \u2264 a) (h2 : a < b) : a * a < b * b :=", "model_response": "lemma normSq_lt_normSq_iff : \"normSq a < normSq b  \\<longleftrightarrow> norm a < norm b\""}
{"gold_output": "theorem odd_mul : Odd (m * n) \u2194 Odd m \u2227 Odd n :=", "model_response": "lemma odd_mul' : Odd (m * n) = (Odd m \\<or> Odd n \\<and> \\<not> (Odd m \\<and> Odd n)) :="}
{"gold_output": "theorem le_sin_mul {x : \u211d} (hx : 0 \u2264 x) (hx' : x \u2264 1) : x \u2264 sin (\u03c0 / 2 * x) :=", "model_response": "lemma sin_pi_sub (x : \u211d) : sin (\u03c0 - x) = sin x :="}
{"gold_output": "theorem StrictMonoOn.continuousWithinAt_right_of_exists_between {f : \u03b1 \u2192 \u03b2} {s : Set \u03b1} {a : \u03b1}\n(h_mono : StrictMonoOn f s) (hs : s \u2208 \ud835\udcdd[\u2265] a) (hfs : \u2200 b > f a, \u2203 c \u2208 s, f c \u2208 Ioc (f a) b) :\nContinuousWithinAt f (Ici a) a :=", "model_response": "lemma continuousWithinAt_Ici_of_exists_between:\n\"continuousWithinAt f (Ici a) a\"\nif \"StrictMonoOn f s\" \"s \u2208 \ud835\udcdd[\u2265] a\" \"\\<And>b. b > f a \\<Longrightarrow> \\<exists>c\\<in>s. f c \\<in> Ioc (f a) b\""}
{"gold_output": "theorem smul_fst (s : S) (a : \ud835\udcdc(\ud835\udd5c, A)) : (s \u2022 a).fst = s \u2022 a.fst :=", "model_response": "lemma neg_fst : (-x).fst = -x.fst :="}
{"gold_output": "theorem not_wSameSide_bot (x y : P) : \u00ac(\u22a5 : AffineSubspace R P).WSameSide x y :=", "model_response": "lemma wSameSide_bot [simp]:\n\"(\u22a5 : AffineSubspace R P).WSameSide x y \\<longleftrightarrow> x = y\""}
{"gold_output": "theorem symmDiff_sdiff : a \u2206 b \\ c = a \\ (b \u2294 c) \u2294 b \\ (a \u2294 c) :=", "model_response": "lemma symmDiff_inf_absorb [simp]: \"(a \u2206 b) \\ a = a \u2293 b\""}
{"gold_output": "theorem Prime.not_dvd_one {p : \u2115} (pp : Prime p) : \u00acp \u2223 1 :=", "model_response": "lemma finite_setOf_prime [simp]: {a. p a}.Finite :="}
{"gold_output": "theorem cast_eq_zero [AddGroupWithOne \u03b1] [CharZero \u03b1] {n : \u2124} : (n : \u03b1) = 0 \u2194 n = 0 :=", "model_response": "lemma of_int_eq_id [simp]:\n\"of_int n = n\""}
{"gold_output": "theorem mul_right_surjective\u2080 {a : G\u2080} (h : a \u2260 0) : Surjective fun g => g * a :=", "model_response": "lemma surjective_const_mul' [simp]: \"surjective fun g => g * a\""}
{"gold_output": "theorem inv {\u03b1 \u03b2} [Mul \u03b1] [CommGroup \u03b2] {f : \u03b1 \u2192 \u03b2} (hf : IsMulHom f) : IsMulHom fun a => (f a)\u207b\u00b9 :=", "model_response": "lemma Multiplicative.of_nat_int: \"Multiplicative.of_nat \\<in> nat_to_int \\<rightarrow>\\<^sub>E int_to_int\""}
{"gold_output": "theorem toFinset_eq_iff_perm_dedup : l.toFinset = l'.toFinset \u2194 l.dedup ~ l'.dedup :=", "model_response": "theorem toFinset_injective : Injective toFinset :="}
{"gold_output": "theorem HasCompactMulSupport.mono {f' : \u03b1 \u2192 \u03b3} (hf : HasCompactMulSupport f)\n(hff' : mulSupport f' \u2286 mulSupport f) : HasCompactMulSupport f' :=", "model_response": "lemma mulT_support_mul : \"mulT_support (f * g) \\<subseteq> mulT_support f \\<union> mulT_support g\""}
{"gold_output": "theorem lift'_eq_freeGroup_lift {A : Type u} : @lift (FreeGroup A) _ _ H _ = FreeGroup.lift :=", "model_response": "theorem Fintype.card_eq_card_freeGroup (a : Type u) :\nFintype.card a = Fintype.card (FreeGroup a) :="}
{"gold_output": "theorem image_mono {s t : Set \u03b1} (h : s \u2286 t) : f.image s \u2286 f.image t :=", "model_response": "lemma image_subset_image [iff]: \"f ` s \\<subseteq> f ` t \\<longleftrightarrow> s \\<subseteq> t\""}
{"gold_output": "theorem map_id {f : StructuredArrow S T} : (map (\ud835\udfd9 S)).obj f = f :=", "model_response": "theorem naturality_id (f : StructuredArrow S T) :\nG.map (\ud835\udfd9 S) \u226b f = \ud835\udfd9 (f.cod) :="}
{"gold_output": "theorem Filter.tendsto_mul_iff_of_ne_zero [T1Space G\u2080] {f g : \u03b1 \u2192 G\u2080} {l : Filter \u03b1} {x y : G\u2080}\n(hg : Tendsto g l (\ud835\udcdd y)) (hy : y \u2260 0) :\nTendsto (fun n => f n * g n) l (\ud835\udcdd <| x * y) \u2194 Tendsto f l (\ud835\udcdd x) :=", "model_response": "lemma isTheta_mul_inverse_iff_right [simp]:\n\"(\\<lambda>n. f n * g n) \\<in> \\<Theta>[l](f) \\<longleftrightarrow> g \\<in> \\<Theta>[l](\\<lambda>n. inverse (f n))\""}
{"gold_output": "theorem setToFun_congr_left (hT : DominatedFinMeasAdditive \u03bc T C)\n(hT' : DominatedFinMeasAdditive \u03bc T' C') (h : T = T') (f : \u03b1 \u2192 E) :\nsetToFun \u03bc T hT f = setToFun \u03bc T' hT' f :=", "model_response": "lemma setToFun_meas [measurable]:\n\"setToFun (\u03bc :: 'a measure) (T :: 'a \\<Rightarrow> 'b \\<Rightarrow> 'e :: {banach, second_countable_topology}) C f \\<in> measurable _ _\""}
{"gold_output": "theorem tail_cons (x : \u03b1) (u : Fin m \u2192 \u03b1) : vecTail (vecCons x u) = u :=", "model_response": "lemma vecTail_vecOfList [simp]: \"vecTail (vecOfList as) = vecOfList (tl as)\""}
{"gold_output": "theorem choose_property (hp : \u2203! a, a \u2208 l \u2227 p a) : p (choose p l hp) :=", "model_response": "lemma choose_spec :\nassumes \"\\<exists>! a. a \\<in> l \\<and> p a\"\nshows \"choose p l hp \\<in> l \\<and> p (choose p l hp)\""}
{"gold_output": "theorem geometric_hahn_banach_point_point [T1Space E] (hxy : x \u2260 y) :\n\u2203 f : E \u2192L[\u211d] \u211d, f x < f y :=", "model_response": "lemma coe_mk_continuous [simp]: \"mk_continuous f h = f\""}
{"gold_output": "theorem modEq_zero_iff_dvd : a \u2261 0 [ZMOD n] \u2194 n \u2223 a :=", "model_response": "lemma toIcoMod_commute: \"toIcoMod hp a b = toIcoMod hp b a\""}
{"gold_output": "theorem tendsto_setToFun_of_dominated_convergence (hT : DominatedFinMeasAdditive \u03bc T C)\n{fs : \u2115 \u2192 \u03b1 \u2192 E} {f : \u03b1 \u2192 E} (bound : \u03b1 \u2192 \u211d)\n(fs_measurable : \u2200 n, AEStronglyMeasurable (fs n) \u03bc) (bound_integrable : Integrable bound \u03bc)\n(h_bound : \u2200 n, \u2200\u1d50 a \u2202\u03bc, \u2016fs n a\u2016 \u2264 bound a)\n(h_lim : \u2200\u1d50 a \u2202\u03bc, Tendsto (fun n => fs n a) atTop (\ud835\udcdd (f a))) :\nTendsto (fun n => setToFun \u03bc T hT (fs n)) atTop (\ud835\udcdd <| setToFun \u03bc T hT f) :=", "model_response": "lemma continuous_setToFun [continuous_intros]:\nassumes \"dominatedFinMeasAdditive \u03bc T C\"\nand fs_meas: \"\\<And>n. AEStronglyMeasurable (fs n) \u03bc\"\nand bound_integrable: \"integrable bound \u03bc\"\nand h_bound: \"\\<And>n. \u2200\u1d50 a \u2202\u03bc. \u2016fs n a\u2016 \u2264 bound a\"\nand h_lim: \"\u2200\u1d50 a \u2202\u03bc. Tendsto (fun n => fs n a) atTop (\ud835\udcdd (f a))\"\nshows \"continuous (setToFun \u03bc T hT f)\""}
{"gold_output": "theorem coe_pow (x : S) (n : \u2115) : (\u2191(x ^ n) : A) = (x : A) ^ n :=", "model_response": "lemma toFun_mul: \"toFun (f * g) = (toFun f) * (toFun g)\""}
{"gold_output": "theorem hasDerivAt_rpow_const {x p : \u211d} (h : x \u2260 0 \u2228 1 \u2264 p) :\nHasDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x :=", "model_response": "lemma hasDerivAt_rpow_const_of_ne_or_one_le (x p : \u211d) (h : x \u2260 0 \u2228 1 \u2264 p) :\nHasDerivAt (fun x => x ^ p) (p * x ^ (p - 1)) x :="}
{"gold_output": "theorem Ico_image_const_sub_eq_Ico (hac : a \u2264 c) :\n((Ico a b).image fun x => c - x) = Ico (c + 1 - b) (c + 1 - a) :=", "model_response": "lemma image_const_sub_Ico: \"((Ico a b).image fun x => c - x) = Ico (c + 1 - b) (c + 1 - a)\""}
{"gold_output": "theorem mul_le_mul_of_nonneg_right [MulPosMono \u03b1] (h : b \u2264 c) (a0 : 0 \u2264 a) : b * a \u2264 c * a :=", "model_response": "lemma of_nat_eq_of_int [simp]: \"of_nat n = of_int n\""}
{"gold_output": "theorem onFinset_apply {s : Finset \u03b1} {f : \u03b1 \u2192 M} {hf a} : (onFinset s f hf : \u03b1 \u2192\u2080 M) a = f a :=", "model_response": "lemma onFinset_apply [simp]: \"(onFinset s f hf) a = f a\""}
{"gold_output": "theorem UpperSemicontinuous.isClosed_preimage {f : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuous f) (y : \u03b3) :\nIsClosed (f \u207b\u00b9' Ici y) :=", "model_response": "lemma UpperSemicontinuous.isClosed_preimage {f : \u03b1 \u2192 \u03b3} (hf : UpperSemicontinuous f) (y : \u03b3) :\nIsClosed (f \u207b\u00b9' Ici y) :="}
{"gold_output": "theorem succAbove_right_inj {x : Fin (n + 1)} : x.succAbove a = x.succAbove b \u2194 a = b :=", "model_response": "lemma succAbove_right_inj [simp]: \"x.succAbove a = x.succAbove b  \\<longleftrightarrow> a = b\""}
{"gold_output": "theorem iInf_neBot_iff_of_directed' {f : \u03b9 \u2192 Filter \u03b1} [Nonempty \u03b9] (hd : Directed (\u00b7 \u2265 \u00b7) f) :\nNeBot (iInf f) \u2194 \u2200 i, NeBot (f i) :=", "model_response": "lemma iInf_filter_neBot_iff:\n\"(INF f | P f. f) \\<noteq> bot \u2194 \u2200 f \\<in> { f | P f. f }. f \\<noteq> bot\""}
{"gold_output": "theorem apply_mul_add_le (k n r) : u (k * n + r) \u2264 k * u n + u r :=", "model_response": "lemma u_smul_add_le: \"u (k \u2022 n + r) \u2264 k \u2022 u n + u r\""}
{"gold_output": "theorem projIcc_eq_right (h : a < b) :\nprojIcc a b h.le x = \u27e8b, right_mem_Icc.mpr h.le\u27e9 \u2194 b \u2264 x :=", "model_response": "lemma projIcc_eq_right_iff : projIcc a b h.le x = \u27e8b, right_mem_Icc.mpr h.le\u27e9 \u2194 b \u2264 x :="}
{"gold_output": "theorem sup_apply (f g : SupHom \u03b1 \u03b2) (a : \u03b1) : (f \u2294 g) a = f a \u2294 g a :=", "model_response": "lemma ran_sup_id_eq_id [simp]: \"(id_on (range f) \u2294 id_on (range g)) = id\""}
{"gold_output": "theorem IsMaximal.isPrime {I : Ideal \u03b1} (H : I.IsMaximal) : I.IsPrime :=", "model_response": "lemma (in ring) is_subring_of_units: \"is_subring { x \\<in> carrier \u03b1. IsUnit x }\""}
{"gold_output": "theorem unbounded_inter_not (H : \u2200 a b, \u2203 m, \u2200 c, r c a \u2228 r c b \u2192 r c m) (a : \u03b1) :\nUnbounded r (s \u2229 { b | \u00acr b a }) \u2194 Unbounded r s :=", "model_response": "lemma refl_trans_closure_self_eq : \"{ a' | a' r\\<^sup>*\\<^sup>* a } = {a}\""}
{"gold_output": "theorem Finite.card_pos [Finite \u03b1] [h : Nonempty \u03b1] : 0 < Nat.card \u03b1 :=", "model_response": "lemma card_lists_length_0 [simp]: \"card {l. length l = 0 \\<and> set l \u2286 \u03b1} = 1\""}
{"gold_output": "theorem gcd_a_eq : a = gcdA' a b * gcd a b :=", "model_response": "lemma gcd_rec_right : \"gcd a b = gcd b (a mod b)\""}
{"gold_output": "theorem continuous_comp {G : \u03b2 \u2192 \u03b3} {C : \u211d\u22650} (H : LipschitzWith C G) :\nContinuous (comp G H : (\u03b1 \u2192\u1d47 \u03b2) \u2192 \u03b1 \u2192\u1d47 \u03b3) :=", "model_response": "lemma toLp_comp_toContinuousMap:\n\"(toLp p \u03bc).comp (lp.toContinuousMap _) = toContinuousMap\""}
{"gold_output": "theorem ext_iff {\u03c7 \u03c7' : MulChar R R'} : \u03c7 = \u03c7' \u2194 \u2200 a : R\u02e3, \u03c7 a = \u03c7' a :=", "model_response": "lemma toUnitHom_injective [simp]:\n\"Function.Injective (toUnitHom : a \u2192 R\u02e3)\""}
{"gold_output": "theorem exact_comp_hom_inv_comp_iff (i : B \u2245 D) : Exact (f \u226b i.hom) (i.inv \u226b g) \u2194 Exact f g :=", "model_response": "theorem exact_comp_hom_inv_comp_iff : Exact (f \u226b i.hom) (i.inv \u226b g) \u2194 Exact f g :="}
{"gold_output": "theorem pairwise_bind {R : \u03b2 \u2192 \u03b2 \u2192 Prop} {l : List \u03b1} {f : \u03b1 \u2192 List \u03b2} :\nList.Pairwise R (l.bind f) \u2194\n(\u2200 a \u2208 l, Pairwise R (f a)) \u2227 Pairwise (fun a\u2081 a\u2082 => \u2200 x \u2208 f a\u2081, \u2200 y \u2208 f a\u2082, R x y) l :=", "model_response": "lemma pairwise_bind_iff:\nassumes \"\\<And>x y. x \\<in> l \\<Longrightarrow> y \\<in> l \\<Longrightarrow> Pairwise R (f x) (f y)\"\nshows \"Pairwise R (l.bind f) \\<longleftrightarrow> Pairwise (\\<lambda>x y. x \\<in> l \\<longrightarrow> y \\<in> l \\<longrightarrow> R x y) l\""}
{"gold_output": "theorem le_pi {g : Filter (\u2200 i, \u03b1 i)} : g \u2264 pi f \u2194 \u2200 i, Tendsto (eval i) g (f i) :=", "model_response": "lemma tendsto_eval_pi [tendsto_intros]: \"(eval i \\<longlongrightarrow> f i) g\""}
{"gold_output": "theorem eqLocus_same (f : M \u2192\u209b\u2097[\u03c4\u2081\u2082] M\u2082) : f.eqLocus f = \u22a4 :=", "model_response": "lemma continuousAt_iff_tendsto_zero:\n\"ContinuousAt f x \u2194 Tendsto (fun y => f (x + y)) (\ud835\udcdd 0) (\ud835\udcdd (f x))\""}
{"gold_output": "theorem zero_tsub (a : \u03b1) : 0 - a = 0 :=", "model_response": "lemma toIcoMod_eq_self_iff: \"toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)\""}
{"gold_output": "theorem coe_inv (U : unitary R) : \u2191U\u207b\u00b9 = (U\u207b\u00b9 : R) :=", "model_response": "lemma coe_inv_unitary [simp]: \u2191(U\u207b\u00b9 : unitary R) = (U : R)\u207b\u00b9 :="}
{"gold_output": "theorem \u03bc_naturality\u2082 {m n m' n' : M} (f : m \u27f6 m') (g : n \u27f6 n') (X : C) :\n(F.map g).app ((F.obj m).obj X) \u226b (F.obj n').map ((F.map f).app X) \u226b (F.\u03bc m' n').app X =\n(F.\u03bc m n).app X \u226b (F.map (f \u2297 g)).app X :=", "model_response": "theorem \u03bc_naturality\u2082_1 (m n m' n' : M) (f : m \u27f6 m') (g : n \u27f6 n') (X : C) :\n(F.map g).app ((F.obj m).obj X) \u226b (F.obj n').map ((F.map f).app X) =\n(F.\u03bc m n).app X \u226b (F.map (f \u2297 g)).app X :="}
{"gold_output": "theorem continuous : Continuous I :=", "model_response": "lemma continuousWithinAt : \"continuousWithinAt \ud835\udd5c f s x\""}
{"gold_output": "theorem continuousOn {s} : ContinuousOn e s :=", "model_response": "lemma continuousAt : \"continuousAt e x\""}
{"gold_output": "theorem coe_nil : \u2191(@Sym.nil \u03b1) = (0 : Multiset \u03b1) :=", "model_response": "lemma mk_lists_eq_mk_multiset : (#List \u03b1) = (#Multiset \u03b1) :="}
{"gold_output": "theorem mk_union_le {\u03b1 : Type u} (S T : Set \u03b1) : (#(S \u222a T : Set \u03b1)) \u2264 (#S) + (#T) :=", "model_response": "lemma mk_fin_fun_injective_aux:\n\"(#(Fin n \u2192 Fin m) ) = (#(Fin n \u2192 Fin m) // { f | f \u2208 (Finset.univ : Set (Fin n \u2192 Fin n)). Inj_on f (Finset.univ : Set (Fin n))})\""}
{"gold_output": "theorem Continuous.coinduced_le (h : Continuous[t, t'] f) : t.coinduced f \u2264 t' :=", "model_response": "lemma coinduced_eq_iInf:\n\"(coinduced I f s).topology = \u2a05 i : I, principal (f '' s)\""}
{"gold_output": "theorem Nat.cast_pow [Semiring R] (n m : \u2115) : (\u2191(n ^ m) : R) = (\u2191n : R) ^ m :=", "model_response": "lemma of_nat_mul [simp]: \"of_nat (n * m) = of_nat n * of_nat m\""}
{"gold_output": "theorem Nontrivial.choose_fst_ne_choose_snd (hs : s.Nontrivial) :\nhs.choose.fst \u2260 hs.choose.snd :=", "model_response": "lemma choose_fst_mem (hs : s.Nontrivial) : hs.choose.fst \u2208 s :="}
{"gold_output": "theorem le_pow_ramificationIdx : map f p \u2264 P ^ ramificationIdx f p P :=", "model_response": "lemma inj_on_comap_prime_of_is_unit:\n\"inj_on f {x. f x \\<in> prime_spectrum R \\<and> x \\<in> prime_spectrum R}\""}
{"gold_output": "theorem exp_nsmul (n : \u2115) (x : \ud835\udd38) : exp \ud835\udd42 (n \u2022 x) = exp \ud835\udd42 x ^ n :=", "model_response": "lemma exp_nsmul (n : \u2115) (x : \ud835\udd38) : exp \ud835\udd42 (n \u2022 x) = exp \ud835\udd42 x ^ n :="}
{"gold_output": "theorem IsClosed.leftCoset {U : Set G} (h : IsClosed U) (x : G) : IsClosed (leftCoset x U) :=", "model_response": "theorem leftCoset_eq: \"{g | g. g \\<in> U \\<and> g \\<in> x <# s} = x <# s\""}
{"gold_output": "theorem sub_right (x y z : M\u2081) : B\u2081 x (y - z) = B\u2081 x y - B\u2081 x z :=", "model_response": "lemma Matrix.toBilin_sub_right : \"Matrix.toBilin b (v \\<bullet> (w - w')) = Matrix.toBilin b (v \\<bullet> w) - Matrix.toBilin b (v \\<bullet> w')\""}
{"gold_output": "theorem mulRight_symm [IsometricSMul G\u1d50\u1d52\u1d56 G] (x : G) : (mulRight x).symm = mulRight x\u207b\u00b9 :=", "model_response": "lemma inv_mulRight [simp]:\n\"(mulRight x).symm = mulRight x\u207b\u00b9\""}
{"gold_output": "theorem IsLittleO.const_mul_right' {g : \u03b1 \u2192 R} {c : R} (hc : IsUnit c) (h : f =o[l] g) :\nf =o[l] fun x => c * g x :=", "model_response": "lemma isLittleO_const_mul_right_iff [simp]:\n\"(f =o[l] (\\<lambda>x. c * g x)) \\<longleftrightarrow> c \\<noteq> 0 \\<and> f =o[l] g\""}
{"gold_output": "theorem ciSup_le_iff [Nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} {a : \u03b1} (hf : BddAbove (range f)) :\niSup f \u2264 a \u2194 \u2200 i, f i \u2264 a :=", "model_response": "lemma ciSup_le_iff: \"(SUP i. f i) \\<le> a  \\<longleftrightarrow>  (\\<forall>i. f i \\<le> a)\""}
{"gold_output": "theorem mem_inf {S T : StarSubalgebra R A} {x : A} : x \u2208 S \u2293 T \u2194 x \u2208 S \u2227 x \u2208 T :=", "model_response": "lemma coe_subalgebra_self (S : StarSubalgebra R A) : (S : Set A) = { x \\<in> A | x \\<in> S } = S :="}
{"gold_output": "theorem exp_sub : exp (x - y) = exp x / exp y :=", "model_response": "lemma exp_multiset_sum: \"exp (sum m) = prod (image exp m)\" for m :: \"real multiset\""}
{"gold_output": "theorem conjTranspose_multiset_sum [AddCommMonoid \u03b1] [StarAddMonoid \u03b1]\n(s : Multiset (Matrix m n \u03b1)) : s.sum\u1d34 = (s.map conjTranspose).sum :=", "model_response": "lemma conjTranspose_sum [simp]:\n\"(sum f s)\u1d34 = sum (\\<lambda>i. (f i)\u1d34) s\""}
{"gold_output": "theorem mapMatrix_refl : (RingEquiv.refl \u03b1).mapMatrix = RingEquiv.refl (Matrix m m \u03b1) :=", "model_response": "lemma of_refl [simp]: \"of (RingEquiv.refl \u03b1) = RingEquiv.refl (Matrix m m \u03b1)\""}
{"gold_output": "theorem extend_coe : \u21d1(f.extend I) = I \u2218 f :=", "model_response": "lemma extend_coe : (f.extend I) = I \\<circ> f :="}
{"gold_output": "theorem inter_nonempty_iff_exists_right : (s \u2229 t).Nonempty \u2194 \u2203 x \u2208 t, x \u2208 s :=", "model_response": "lemma inter_ext_iff : \"{x \\<in> t. P x} = {x \\<in> s. Q x} \\<longleftrightarrow>\n(\\<forall>x \\<in> t. P x \\<longrightarrow> Q x) \\<and> (\\<forall>x \\<in> s. Q x \\<longrightarrow> P x)\""}
{"gold_output": "theorem rightDual_v [RightRigidCategory V] : X\u1601.V = X.V\u1601 :=", "model_response": "lemma rightUnitor_inv_naturality [simp]:\n\"(\u03c1_ X).inv \\<cdot> \\<a>[X, X, X].hom = \\<r>[X].hom \\<cdot> \\<a>[X, X, X].inv\""}
{"gold_output": "theorem IsCompact.exists_bound_of_continuous_on' [TopologicalSpace \u03b1] {s : Set \u03b1} (hs : IsCompact s)\n{f : \u03b1 \u2192 E} (hf : ContinuousOn f s) : \u2203 C, \u2200 x \u2208 s, \u2016f x\u2016 \u2264 C :=", "model_response": "lemma continuousOn_f: \"continuousOn f s\""}
{"gold_output": "theorem lt_pred_iff : n < pred m \u2194 succ n < m :=", "model_response": "lemma card_fset_lt [simp]:\nshows \"card_fset xs < card_fset ys \\<longleftrightarrow> card xs < card ys\""}
{"gold_output": "theorem eqOn_piecewise {f f' g : \u03b1 \u2192 \u03b2} {t} :\nEqOn (s.piecewise f f') g t \u2194 EqOn f g (t \u2229 s) \u2227 EqOn f' g (t \u2229 s\u1d9c) :=", "model_response": "lemma eqOn_piecewise_iff [simp]:\n\"EqOn (s.piecewise f f') g t \\<longleftrightarrow> EqOn f g (t \\<inter> s) \\<and> EqOn f' g (t \\<inter> s\u1d9c)\""}
{"gold_output": "theorem Icc_def (a b : \u03b1) : { x | a \u2264 x \u2227 x \u2264 b } = Icc a b :=", "model_response": "lemma Icc_def' : { x | a \\<le> x \\<and> x \\<le> b } = Icc a b :="}
{"gold_output": "theorem integral_indicatorConstLp {p : \u211d\u22650\u221e} (ht : MeasurableSet t) (h\u03bct : \u03bc t \u2260 \u221e) (x : E) :\n(\u222b a, indicatorConstLp p ht h\u03bct x a \u2202\u03bc) = (\u03bc t).toReal \u2022 x :=", "model_response": "lemma integral_indicator (s : Set \u03b1) : (\u222b a, indicator s a \u2202\u03bc) = (\u03bc s).toReal :="}
{"gold_output": "theorem coe_finset_sum [AddCommMonoid N] (S : Finset \u03b9) (f : \u03b9 \u2192 \u03b1 \u2192\u2080 N) :\n\u21d1(\u2211 i in S, f i) = \u2211 i in S, \u21d1(f i) :=", "model_response": "lemma summable_iff_summable_coe [simp]: \"summable f \\<longleftrightarrow> summable (\\<lambda>x. (f x : 'b::{comm_monoid_add,zero}))\""}
{"gold_output": "theorem HasBasis.inf_principal_neBot_iff (hl : l.HasBasis p s) {t : Set \u03b1} :\nNeBot (l \u2293 \ud835\udcdf t) \u2194 \u2200 \u2983i\u2984, p i \u2192 (s i \u2229 t).Nonempty :=", "model_response": "lemma measurableSet_fiber: \"Measurable.Set {x\\<in>space M. p (f -` {x})}\""}
{"gold_output": "theorem Ioi_zero_eq_map : Ioi (0 : Fin n.succ) = univ.map (Fin.succEmbedding _).toEmbedding :=", "model_response": "lemma Ioi_zero_eq_map : \"Ioi (0 : Fin n.succ) = univ.map (Fin.succEmbedding _).toEmbedding\""}
{"gold_output": "theorem mul_comm : M * N = N * M :=", "model_response": "lemma mul_comm_apply :\nassumes \"comp_fun_commute f\"\nshows \"f (a * b) = f (b * a)\""}
{"gold_output": "theorem eventually_swap_iff {p : \u03b1 \u00d7 \u03b2 \u2192 Prop} :\n(\u2200\u1da0 x : \u03b1 \u00d7 \u03b2 in f \u00d7\u02e2 g, p x) \u2194 \u2200\u1da0 y : \u03b2 \u00d7 \u03b1 in g \u00d7\u02e2 f, p y.swap :=", "model_response": "lemma continuousAt_swap[continuous_intros, simp]: \"continuousAt swap x\""}
{"gold_output": "theorem Colorable.of_embedding {V' : Type _} {G' : SimpleGraph V'} (f : G \u21aag G') {n : \u2115}\n(h : G'.Colorable n) : G.Colorable n :=", "model_response": "lemma fin_verts: \"finite (uverts G)\""}
{"gold_output": "theorem decode_eq_ofNat (\u03b1) [Denumerable \u03b1] (n : \u2115) : decode (\u03b1 := \u03b1) n = some (ofNat \u03b1 n) :=", "model_response": "lemma decode_encode [simp]:\nassumes \"a \\<in> denumerable \\<alpha>\"\nshows \"decode (encode a) = a\""}
{"gold_output": "theorem cotangent_subsingleton_iff : Subsingleton I.Cotangent \u2194 IsIdempotentElem I :=", "model_response": "lemma subsingleton_cotangent_iff : Subsingleton I.Cotangent \u2194 IsIdempotentElem I :="}
{"gold_output": "theorem neg_coeff (x : \ud835\udd4e R) (n : \u2115) : (-x).coeff n = peval (wittNeg p n) ![x.coeff] :=", "model_response": "lemma neg_coeff_zero [simp]: \"(-x).coeff 0 = -x.coeff 0\""}
{"gold_output": "theorem preimage_id_eq : preimage (id : \u03b1 \u2192 \u03b1) = id :=", "model_response": "lemma preimage_id_eq_id : \"preimage id s = id\""}
{"gold_output": "theorem isPreconnected_uIcc : IsPreconnected (uIcc a b) :=", "model_response": "lemma isPreconnected_Ici : \"IsPreconnected (Ici a)\"\nfor a :: \"'a::linorder_topology\""}
{"gold_output": "theorem hasPushout_of_left_iso : HasPushout f g :=", "model_response": "theorem of_pushout_inv_comm_iff : of f \u226b inv (of f) \u226b of g = inv (of g) \u226b of f \u226b of g \u2194 f \u226b g = g \u226b f :="}
{"gold_output": "theorem comap_smallSets (l : Filter \u03b2) (f : \u03b1 \u2192 Set \u03b2) :\ncomap f l.smallSets = l.lift' (preimage f \u2218 powerset) :=", "model_response": "lemma continuousAt_iff_continuousAt_top [simp]:\n\"continuousAt f x \\<longleftrightarrow> Topological.continuousAt f x\""}
{"gold_output": "theorem dist_triangle4 (x y z w : \u03b1) : dist x w \u2264 dist x y + dist y z + dist z w :=", "model_response": "lemma dist_mul_le (a b : \ud835\udd5c) (x y : \u03b1) : dist (a \u2022 x) (b \u2022 y) \u2264 \u2016a\u2016 * \u2016b\u2016 * dist x y :="}
{"gold_output": "theorem mul_le_of_le_one_right [PosMulMono \u03b1] (ha : 0 \u2264 a) (h : b \u2264 1) : a * b \u2264 a :=", "model_response": "lemma of_nat_le_iff_le_to_nat : (of_nat n : \u03b1) \u2264 a \u2194 n \u2264 to_nat a :="}
{"gold_output": "theorem equivOfEquiv_symm_algebraMap (hSR : S \u2243+* R) (r : R) :\n(equivOfEquiv L M hSR).symm (algebraMap R M r) = algebraMap S L (hSR.symm r) :=", "model_response": "lemma equivOfEquiv_symm_algebraMap_apply [simp]:\n\"(equivOfEquiv L M hSR).symm (algebraMap R M r) = algebraMap S L (hSR.symm r)\""}
{"gold_output": "theorem inseparable_iff_forall_open : (x ~\u1d62 y) \u2194 \u2200 s : Set X, IsOpen s \u2192 (x \u2208 s \u2194 y \u2208 s) :=", "model_response": "lemma isOpen_inseparable_set :\n\"isOpen {x. (x ~\u1d62 y)}\""}
{"gold_output": "theorem card_eq_zero [IsEmpty \u03b1] : card \u03b1 = 0 :=", "model_response": "lemma card_lists_length_0 [simp]: \"card {l. length l = 0 \\<and> set l \u2286 s} = 1\""}
{"gold_output": "theorem Tendsto.congr' {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (hl : f\u2081 =\u1da0[l\u2081] f\u2082)\n(h : Tendsto f\u2081 l\u2081 l\u2082) : Tendsto f\u2082 l\u2081 l\u2082 :=", "model_response": "lemma tendsto_of_real_nhds_nhds_of_real :\n\"Tendsto of_real (atTop) (\ud835\udcdd (atTop : Filter \u211d\u22650))\""}
{"gold_output": "theorem IsCoprime.ne_zero [Nontrivial R] {p : Fin 2 \u2192 R} (h : IsCoprime (p 0) (p 1)) : p \u2260 0 :=", "model_response": "lemma ofFn_ne_zero [simp]: \"ofFn p \u2260 0\""}
{"gold_output": "theorem Ioo_self (a : \u03b1) : Ioo a a = \u2205 :=", "model_response": "lemma toIcoMod_eq_self : toIcoMod hp a a = a :="}
{"gold_output": "theorem homQuotientZPowOfHom_id : homQuotientZPowOfHom (MonoidHom.id A) n = MonoidHom.id _ :=", "model_response": "lemma homQuotientZPowOfHom_id :\n\"homQuotientZPowOfHom (MonoidHom.id A) n = MonoidHom.id _\""}
{"gold_output": "theorem coe_toSubsemigroup (s : NonUnitalSubsemiring R) : (s.toSubsemigroup : Set R) = s :=", "model_response": "lemma coe_toSubsemigroup (s : Subring R) : (s.toSubsemigroup : Set R) = s :="}
{"gold_output": "theorem exists_right_complement'_of_coprime {N : Subgroup G} [N.Normal]\n(hN : Nat.coprime (Nat.card N) N.index) : \u2203 H : Subgroup G, IsComplement' N H :=", "model_response": "theorem card_sylow_mod_coprime:\n\"card (sylow p G) = card (sylow p (G \u29f8 N)) mod p ^ multiplicity p N.index\""}
{"gold_output": "theorem EqOnSource.restr {e e' : LocalEquiv \u03b1 \u03b2} (he : e \u2248 e') (s : Set \u03b1) :\ne.restr s \u2248 e'.restr s :=", "model_response": "lemma symm_restr (e : LocalEquiv \u03b1 \u03b2) (he : e \u2248 e') (s : Set \u03b1) :\n(e.restr s).symm = e.symm.restr s :="}
{"gold_output": "theorem UniformContinuous.pow_const [UniformSpace \u03b2] {f : \u03b2 \u2192 \u03b1} (hf : UniformContinuous f) :\n\u2200 n : \u2115, UniformContinuous fun x => f x ^ n", "model_response": "lemma UniformContinuous_pow_const [uniform_continuous_intros]:\nassumes \"UniformContinuous f\"\nshows \"UniformContinuous (\\<lambda>x. f x ^ n)\""}
{"gold_output": "theorem has_iUnion {\u03b2} [Countable \u03b2] {f : \u03b2 \u2192 Set \u03b1} (hd : Pairwise (Disjoint on f))\n(h : \u2200 i, d.Has (f i)) : d.Has (\u22c3 i, f i) :=", "model_response": "lemma measurable_toNat[measurable]: \"measurable toNat\""}
{"gold_output": "theorem biproduct.hom_ext {f : J \u2192 C} [HasBiproduct f] {Z : C} (g h : Z \u27f6 \u2a01 f)\n(w : \u2200 j, g \u226b biproduct.\u03c0 f j = h \u226b biproduct.\u03c0 f j) : g = h :=", "model_response": "lemma biproduct.lift_\u03c0_ext:\n\"biproduct.lift f g \u226b biproduct.\u03c0 f j = biproduct.lift f h \u226b biproduct.\u03c0 f j\""}
{"gold_output": "theorem card_le_card_of_forall_subsingleton (hs : \u2200 a \u2208 s, \u2203 b, b \u2208 t \u2227 r a b)\n(ht : \u2200 b \u2208 t, ({ a \u2208 s | r a b } : Set \u03b1).Subsingleton) : s.card \u2264 t.card :=", "model_response": "lemma card_sub_le_of_subsingleton:\n\"card { a \\<in> s. \\<exists>b \\<in> t. r a b } \\<le> card t\""}
{"gold_output": "theorem mk_preimage_prod_right_fn_eq_if [DecidablePred (\u00b7 \u2208 s)] (g : \u03b4 \u2192 \u03b2) :\n(fun b => (a, g b)) \u207b\u00b9' s \u00d7\u02e2 t = if a \u2208 s then g \u207b\u00b9' t else \u2205 :=", "model_response": "lemma mk_preimage_prod_left_fn_eq_if [simp]:\n\"(\\<lambda>a. (a, b)) \u207b\u00b9' s = (if b \u2208 t then s else {})\""}
{"gold_output": "theorem toOrderHom_eq_coe (f : \u03b1 \u2192*o \u03b2) : f.toOrderHom = f :=", "model_response": "lemma strictMonoOn_iff_lt:\n\"StrictMonoOn f s \\<longleftrightarrow> (\\<forall>x\\<in>s. \\<forall>y\\<in>s. x < y \\<longrightarrow> f x < f y)\""}
{"gold_output": "theorem map_natCast [RingHomClass F R S] (f : F) : \u2200 n : \u2115, f (n : R) = n :=", "model_response": "lemma map_multiset_prod [simp]: \"f (prod m) = prod (image f m)\""}
{"gold_output": "theorem MeasurableSet.prod {s : Set \u03b1} {t : Set \u03b2} (hs : MeasurableSet s)\n(ht : MeasurableSet t) : MeasurableSet (s \u00d7\u02e2 t) :=", "model_response": "lemma continuous_on_iff_continuous_within:\n\"continuous_on s f \\<longleftrightarrow> (\\<forall>x\\<in>s. continuous (at x within s) f)\""}
{"gold_output": "theorem exp_inl (x : R) : exp \ud835\udd5c (inl x : tsze R M) = inl (exp \ud835\udd5c x) :=", "model_response": "lemma exp_add : \"exp \ud835\udd5c (x + y) = exp \ud835\udd5c x * exp \ud835\udd5c y\""}
{"gold_output": "theorem lift_unique [Nonempty \u03b9] [IsDirected \u03b9 (\u00b7 \u2264 \u00b7)] (F : DirectLimit G f \u2192+* P) (x) :\nF x = lift G f P (fun i => F.comp <| of G f i) (fun i j hij x => by simp [of_f]) x :=", "model_response": "lemma lift_comp_of [simp]: \"lift G f P F \u2218 of f = F\""}
{"gold_output": "theorem HasStrictDerivAt.sub (hf : HasStrictDerivAt f f' x) (hg : HasStrictDerivAt g g' x) :\nHasStrictDerivAt (fun x => f x - g x) (f' - g') x :=", "model_response": "lemma has_strict_deriv_at_sub [derivative_intros]:\n\"HasStrictDerivAt f f' x \\<Longrightarrow> HasStrictDerivAt g g' x \\<Longrightarrow> HasStrictDerivAt (\\<lambda>x. f x - g x) (f' - g') x\""}
{"gold_output": "theorem not_injective_of_ordinal_of_small {\u03b1 : Type v} [Small.{u} \u03b1] (f : Ordinal.{u} \u2192 \u03b1) :\n\u00acInjective f :=", "model_response": "theorem ordinal_eqpoll_continuum (\u03b1 : Type u) [Small.{u} \u03b1] :\n(#{ o : Ordinal | \u2203 a, o = ordinal_of_nat a }) = \ud835\udd20 :="}
{"gold_output": "theorem prod_ite {s : Finset \u03b1} {p : \u03b1 \u2192 Prop} {hp : DecidablePred p} (f g : \u03b1 \u2192 \u03b2) :\n(\u220f x in s, if p x then f x else g x) =\n(\u220f x in s.filter p, f x) * \u220f x in s.filter fun x => \u00acp x, g x :=", "model_response": "lemma continuous_iff'_right:\n\"continuous (f x) \\<longleftrightarrow> ((\\<lambda>y. (f y, f x)) \\<longlongrightarrow> uniformity (\u03b1 := C(\u03b1, \u03b2))) (\ud835\udcdd x)\""}
{"gold_output": "theorem comp_apply (f : TopHom \u03b2 \u03b3) (g : TopHom \u03b1 \u03b2) (a : \u03b1) : (f.comp g) a = f (g a) :=", "model_response": "lemma id_comp [simp]: \"TopHom.id \\<gamma> \\<circ> f = f\""}
{"gold_output": "theorem blsub_zero (f : \u2200 a < (0 : Ordinal), Ordinal) : blsub 0 f = 0 :=", "model_response": "lemma blsub_zero [simp]: \"blsub 0 f = 0\""}
{"gold_output": "theorem zeroProdIso_hom (X : C) : (zeroProdIso X).hom = prod.snd :=", "model_response": "lemma zeroProdIso_hom_fst (X : C) : fst \u226b (zeroProdIso X).hom = (zeroIso X).hom :="}
{"gold_output": "theorem ker_isPrime {F : Type _} [Ring R] [Ring S] [IsDomain S] [RingHomClass F R S] (f : F) :\n(ker f).IsPrime :=", "model_response": "lemma (in ring_hom_ring) prime_ideal_ker: \"prime_ideal { x \\<in> carrier R. f x = \\<zero> }\""}
{"gold_output": "theorem coe_bit0 : ((bit0 x : \u03b1) : WithTop \u03b1) = (bit0 x : WithTop \u03b1) :=", "model_response": "lemma ofAdd_injective [simp]:\n\"injective (ofAdd :: 'a::group_add \\<Rightarrow> 'a::group_mult)\""}
{"gold_output": "theorem Measurable.const_mul [MeasurableMul M] (hf : Measurable f) (c : M) :\nMeasurable fun x => c * f x :=", "model_response": "lemma Measurable.const_mul' [measurable (raw)]:\n\"Measurable (\\<lambda>x. c * f x)\" if [measurable_dest]: \"Measurable f\" \"c \\<in> M\""}
{"gold_output": "theorem Wcovby.le_of_lt (hab : a \u2a7f b) (hcb : c < b) : c \u2264 a :=", "model_response": "lemma is_lower_set_Ici [simp]: \"is_lower_set (Ici a)\""}
{"gold_output": "theorem Additive.isAddMonoidHom [MulOneClass \u03b1] [MulOneClass \u03b2] {f : \u03b1 \u2192 \u03b2}\n(hf : IsMonoidHom f) : @IsAddMonoidHom (Additive \u03b1) (Additive \u03b2) _ _ f :=", "model_response": "lemma isAddMonoidHom: \"isAddMonoidHom f\""}
{"gold_output": "theorem prod_eq {f : Filter \u03b1} {g : Filter \u03b2} : f \u00d7\u02e2 g = (f.map Prod.mk).seq g :=", "model_response": "lemma prod_bot_bot [simp]: \"prod (\u22a5 : Filter \u03b1) (\u22a5 : Filter \u03b2) = \u22a5\""}
{"gold_output": "theorem isHenstock_single (h : x \u2208 Box.Icc I) : IsHenstock (single I I le_rfl x h) :=", "model_response": "lemma measurable_spaced_UNIV [simp]: \"MeasurableSpace (UNIV::real set)\""}
{"gold_output": "theorem eraseLead_ne_zero (f0 : 2 \u2264 f.support.card) : eraseLead f \u2260 0 :=", "model_response": "lemma eraseLead_degree_lt : f.eraseLead.degree < f.degree :="}
{"gold_output": "theorem hasFDerivWithinAt_aeval (x : \ud835\udd5c) :\nHasFDerivWithinAt (fun x => aeval x q) (smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c)\n(aeval x (derivative q))) s x :=", "model_response": "lemma hasFDerivWithinAt_aeval_derivative:\n\"((\\<lambda>x. aeval x q) hasFDerivWithinAt (smulRight (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c) (aeval x (derivative q))) s) x\""}
{"gold_output": "theorem exp_smul {G} [Monoid G] [MulSemiringAction G \ud835\udd38] [ContinuousConstSMul G \ud835\udd38] (g : G) (x : \ud835\udd38) :\nexp \ud835\udd42 (g \u2022 x) = g \u2022 exp \ud835\udd42 x :=", "model_response": "lemma exp_multiset_sum [simp]: \"exp \ud835\udd42 (sum (s :: 'a multiset) ((\u00b7 \u2022 \u00b7) g)) = prod (s |-> fun x => exp \ud835\udd42 (g \u2022 x)) s\""}
{"gold_output": "theorem toFun_eq_coe_aux {f : CompleteLatticeHom \u03b1 \u03b2} : \u2191f.tosInfHom = \u21d1f :=", "model_response": "lemma sInfHom_id_comp: \"(sInfHom.id (range f)).comp f = f\""}
{"gold_output": "theorem uniqueDiffWithinAt_of_mem_nhds (h : s \u2208 \ud835\udcdd x) : UniqueDiffWithinAt \ud835\udd5c s x :=", "model_response": "lemma has_deriv_exp_scaleR_self (x : \ud835\udd38) (h : s \u2208 \ud835\udcdd x) :\nHasDerivWithinAt (fun x => exp \ud835\udd42 (x *\\<^sub>R x)) (exp \ud835\udd42 (x *\\<^sub>R x)) s x :="}
{"gold_output": "theorem set_integral_mono_on_ae (hs : MeasurableSet s) (h : \u2200\u1d50 x \u2202\u03bc, x \u2208 s \u2192 f x \u2264 g x) :\n(\u222b a in s, f a \u2202\u03bc) \u2264 \u222b a in s, g a \u2202\u03bc :=", "model_response": "lemma set_integral_eq_restrict:\nfixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\nshows \"(\\<integral>x\\<in>s. f x \\<partial>\\<mu>) = (\\<integral>x. f x \\<partial>\\<mu> \\<restriction> s)\""}
{"gold_output": "theorem apply_lineMap (e : P\u2081 \u2243\u1d43[k] P\u2082) (a b : P\u2081) (c : k) :\ne (AffineMap.lineMap a b c) = AffineMap.lineMap (e a) (e b) c :=", "model_response": "lemma affineEquiv_symm (p\u2081 p\u2082 : P) : (affineEquiv p\u2081 p\u2082).symm = affineEquiv p\u2082 p\u2081 :="}
{"gold_output": "theorem const_le_const : const \u03b2 a \u2264 const \u03b2 b \u2194 a \u2264 b :=", "model_response": "lemma monotone_const [simp]: \"monotone (const \u03b1 a)\""}
{"gold_output": "theorem succ_ne_bot (a : \u03b1) : succ a \u2260 \u22a5 :=", "model_response": "lemma succ_bot [simp]: \"succ \u22a5 = \u22a5\""}
{"gold_output": "theorem seq_of_forall_finite_exists {\u03b3 : Type _} {P : \u03b3 \u2192 Set \u03b3 \u2192 Prop}\n(h : \u2200 t : Set \u03b3, t.Finite \u2192 \u2203 c, P c t) : \u2203 u : \u2115 \u2192 \u03b3, \u2200 n, P (u n) (u '' Iio n) :=", "model_response": "lemma card_le_pow_card_finset:\nassumes \"finite A\"\nshows \"card A \\<le> card {f : {0..<n} \u2192 A // \u2200 i, f i \u2208 A}\""}
{"gold_output": "theorem leftMoves_add_cases {x y : PGame} (k) {P : (x + y).LeftMoves \u2192 Prop}\n(hl : \u2200 i, P <| toLeftMovesAdd (Sum.inl i)) (hr : \u2200 i, P <| toLeftMovesAdd (Sum.inr i)) :\nP k :=", "model_response": "lemma toLeftMoves_add_cases [consumes 1, case_names Right Left]:\nfixes x y :: PGame\nassumes \"\\<And>j. j \\<in> y.RightMoves \\<Longrightarrow> P (toLeftMovesAdd (Sum.inr j))\"\nand \"\\<And>i. i \\<in> x.LeftMoves \\<Longrightarrow> P (toLeftMovesAdd (Sum.inl i))\"\nshows \"j \\<in> (x + y).LeftMoves \\<Longrightarrow> P j\""}
{"gold_output": "theorem Ioc_eq_finset_subtype : Ioc a b = (Ioc (a : \u2115) b).fin n :=", "model_response": "lemma toNat_strictMono: \"StrictMono toNat\""}
{"gold_output": "theorem div_conj_eq_sub_one : p / q = p - 1 :=", "model_response": "lemma pdiv_conj: \"p / q = p - 1\""}
{"gold_output": "theorem cl_cl {X : Compactum} (A : Set X) : cl (cl A) \u2286 cl A :=", "model_response": "theorem cl_idem: \"cl (cl A) \u2286 cl A\""}
{"gold_output": "theorem integrable_comp_div_iff (g : \u211d \u2192 F) {R : \u211d} (hR : R \u2260 0) :\n(Integrable fun x => g (x / R)) \u2194 Integrable g :=", "model_response": "lemma integrableOn_norm_iff [simp]:\n\"(\\<lambda>x. norm (f x)) integrableOn {a..b} \\<longleftrightarrow> f integrableOn {a..b}\""}
{"gold_output": "theorem exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to (hf : \u2200 a \u2208 s, f a \u2208 t)\n(ht : t.card \u2022 b < s.card) : \u2203 y \u2208 t, b < (s.filter fun x => f x = y).card :=", "model_response": "lemma card_of_inj_on_functions_eq:\n\"card {f \\<in> s \\<rightarrow>\\<^sub>E t. inj_on f s} = fact (card s) * (card t) ^ card s\""}
{"gold_output": "theorem pred_eq_iff_not_succ {o} : pred o = o \u2194 \u00ac\u2203 a, o = succ a :=", "model_response": "lemma pred_le_iff_not_is_succ [simp]: \"pred a \u2264 a \u2194 a \u2260 0\""}
{"gold_output": "theorem degree_lt_card_verts [DecidableRel G.Adj] (v : V) : G.degree v < Fintype.card V :=", "model_response": "lemma degree_le_card_verts [simp]: \"G.degree v \\<le> Fintype.card V\""}
{"gold_output": "theorem derivative_X_sub_C (c : R) : derivative (X - C c) = 1 :=", "model_response": "lemma derivative_X_sub_C [simp]: \"derivative (X - C c) = 1\""}
{"gold_output": "theorem support_zipWith {f : \u2200 i, \u03b2\u2081 i \u2192 \u03b2\u2082 i \u2192 \u03b2 i} {hf : \u2200 i, f i 0 0 = 0} {g\u2081 : \u03a0\u2080 i, \u03b2\u2081 i}\n{g\u2082 : \u03a0\u2080 i, \u03b2\u2082 i} : (zipWith f hf g\u2081 g\u2082).support \u2286 g\u2081.support \u222a g\u2082.support :=", "model_response": "lemma support_zipWith_subset : \"support (zipWith f hf g\u2081 g\u2082) \\<subseteq> g\u2081.support \\<union> g\u2082.support\""}
{"gold_output": "theorem fst_re_dualNumberEquiv_symm (d : DualNumber (Quaternion R)) :\n(dualNumberEquiv.symm d).re.fst = d.fst.re :=", "model_response": "lemma fst_re_dualNumberEquiv_symm_one [simp]:\n\"(dualNumberEquiv.symm (1, 0, 0, 0)).re.fst = 1\""}
{"gold_output": "theorem image_iso_iff [LE \u03b1] [LE \u03b2] {\u03c6 : \u03b1 \u2243o \u03b2} :\nIsAntichain (\u00b7 \u2264 \u00b7) (\u03c6 '' s) \u2194 IsAntichain (\u00b7 \u2264 \u00b7) s :=", "model_response": "lemma image_Iic_eq [simp]: \"\u03c6 ` Iic a = Iic (\u03c6 a)\""}
{"gold_output": "theorem lt_iff_ssubset : s < t \u2194 s \u2282 t :=", "model_response": "lemma toIcoMod_eq_self_iff: \"toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)\""}
{"gold_output": "theorem smul {U : Set M} (hU : U \u2208 B) : \u2203 V \u2208 \ud835\udcdd (0 : R), \u2203 W \u2208 B, V \u2022 W \u2286 U :=", "model_response": "lemma continuous_at_iff:\n\"continuous (at x) f \u2194 \u2200 \u03b5 > 0, \u2203 \u03b4 > 0, \u2200 y, dist y x < \u03b4 \u2192 dist (f y) (f x) < \u03b5\""}
{"gold_output": "theorem rightOrdContinuous : RightOrdContinuous e :=", "model_response": "lemma continuous_e: \"continuous e\""}
{"gold_output": "theorem set_lintegral_withDensity_eq_set_lintegral_mul_non_measurable (\u03bc : Measure \u03b1) {f : \u03b1 \u2192 \u211d\u22650\u221e}\n(f_meas : Measurable f) (g : \u03b1 \u2192 \u211d\u22650\u221e) {s : Set \u03b1} (hs : MeasurableSet s)\n(hf : \u2200\u1d50 x \u2202\u03bc.restrict s, f x < \u221e) :\n(\u222b\u207b a in s, g a \u2202\u03bc.withDensity f) = \u222b\u207b a in s, (f * g) a \u2202\u03bc :=", "model_response": "lemma emeasure_ne_eq_lintegral_indicator:\n\"emeasure \u03bc {x \\<in> space M. f x \\<noteq> g x} =\n(\\<integral>\\<^sup>+x \\<in> {x \\<in> space M. f x \\<noteq> g x}. ennreal (indicator {x \\<in> space M. f x \\<noteq> g x} x) \\<partial>\u03bc)\""}
{"gold_output": "theorem normalize_eq_normalize_iff {x y : \u03b1} : normalize x = normalize y \u2194 x \u2223 y \u2227 y \u2223 x :=", "model_response": "lemma normalize_gcd_eq_gcd: \"normalize (gcd x y) = gcd x y\""}
{"gold_output": "theorem norm_sub_sq_eq_norm_sq_add_norm_sq_real {x y : F} (h : \u27eax, y\u27eb_\u211d = 0) :\n\u2016x - y\u2016 * \u2016x - y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 :=", "model_response": "lemma norm_add_le: \"norm (x + y) \\<le> norm x + norm y\""}
{"gold_output": "theorem factor_mk_eq {\u03b1 : Type _} (r s : \u03b1 \u2192 \u03b1 \u2192 Prop) (h : \u2200 x y, r x y \u2192 s x y) :\nfactor r s h \u2218 Quot.mk _ = Quot.mk _ :=", "model_response": "theorem factor_comp_mk [simp]: \"factor r s h \u2218 Quot.mk _ = Quot.mk _\""}
{"gold_output": "theorem left_unitality_app (n : M) (X : C) :\n(F.obj n).map (F.\u03b5.app X) \u226b (F.\u03bc (\ud835\udfd9_ M) n).app X \u226b (F.map (\u03bb_ n).hom).app X = \ud835\udfd9 _ :=", "model_response": "theorem left_unitality (n : M) (X : C) :\n(F.obj n).map (F.\u03b5.app X) \u226b (F.\u03bc (\ud835\udfd9_ M) n).app X \u226b (F.map (\u03bb_ n).hom).app X = \ud835\udfd9 _ :="}
{"gold_output": "theorem periodic_circleMap (c : \u2102) (R : \u211d) : Periodic (circleMap c R) (2 * \u03c0) :=", "model_response": "lemma continuous_circleMap (c : \u2102) (R : \u211d) : Continuous (circleMap c R) :="}
{"gold_output": "theorem abs_neg_one_pow (n : \u2115) : |(-1 : R) ^ n| = 1 :=", "model_response": "lemma abs_nat_mul (n : \u2115) (a : R) : |(n * a)| = n * (abs a) :="}
{"gold_output": "theorem Orthonormal.codRestrict {\u03b9 : Type _} {v : \u03b9 \u2192 E} (hv : Orthonormal \ud835\udd5c v) (s : Submodule \ud835\udd5c E)\n(hvs : \u2200 i, v i \u2208 s) : @Orthonormal \ud835\udd5c s _ _ _ \u03b9 (Set.codRestrict v s hvs) :=", "model_response": "lemma toSpanSingleton_injective : Injective 'toSpanSingleton' :="}
{"gold_output": "theorem plusMap_id (P : C\u1d52\u1d56 \u2964 D) : J.plusMap (\ud835\udfd9 P) = \ud835\udfd9 _ :=", "model_response": "lemma plusMap_comp (j\u2081 j\u2082 : C) (f g : j\u2081 \u27f6 j\u2082) :\nJ.plusMap f \u226b J.plusMap g = J.plusMap (f \u226b g) :="}
{"gold_output": "theorem length_lt_card_boundaries : c.length < c.boundaries.card :=", "model_response": "lemma length_eq_length_blocks: \"c.length = c.blocks.length\""}
{"gold_output": "theorem angle_sub_eq_arccos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\nangle x (x - y) = Real.arccos (\u2016x\u2016 / \u2016x - y\u2016) :=", "model_response": "lemma angle_sub_eq_arccos: \"angle x (x - y) = Real.arccos (\u2016x\u2016 / \u2016x - y\u2016)\""}
{"gold_output": "theorem coe_nnreal_eq (r : \u211d\u22650) : (r : \u211d\u22650\u221e) = ENNReal.ofReal r :=", "model_response": "lemma continuous_on_ofReal {s : Set \u211d} : ContinuousOn ofReal s :="}
{"gold_output": "theorem setToL1_congr_left' (T T' : Set \u03b1 \u2192 E \u2192L[\u211d] F) {C C' : \u211d}\n(hT : DominatedFinMeasAdditive \u03bc T C) (hT' : DominatedFinMeasAdditive \u03bc T' C')\n(h : \u2200 s, MeasurableSet s \u2192 \u03bc s < \u221e \u2192 T s = T' s) (f : \u03b1 \u2192\u2081[\u03bc] E) :\nsetToL1 hT f = setToL1 hT' f :=", "model_response": "lemma setToL1_meas [measurable]:\n\"setToL1 hT \\<in> measurable lborel (lborel \\<Otimes>\\<^sub>M borel)\""}
{"gold_output": "theorem exists_seq_mono_tendsto (I : Box \u03b9) :\n\u2203 J : \u2115 \u2192o Box \u03b9,\n(\u2200 n, Box.Icc (J n) \u2286 Box.Ioo I) \u2227\nTendsto (lower \u2218 J) atTop (\ud835\udcdd I.lower) \u2227 Tendsto (upper \u2218 J) atTop (\ud835\udcdd I.upper) :=", "model_response": "lemma isPiSystem_of_mem_Ioo (I : Box \u03b9) :\nIsPiSystem { J | Box.Icc J \u2286 Box.Ioo I \u2227 (lower \u2218 J) \u2192 atTop = atBot \u2227 (upper \u2218 J) \u2192 atTop = atBot } :="}
{"gold_output": "theorem Filter.Tendsto.zpow {\u03b1} {l : Filter \u03b1} {f : \u03b1 \u2192 G} {x : G} (hf : Tendsto f l (\ud835\udcdd x))\n(z : \u2124) : Tendsto (fun x => f x ^ z) l (\ud835\udcdd (x ^ z)) :=", "model_response": "lemma continuous_at_zpow_iff_nat {f : \u03b1 \u2192 G} {x : \u03b1} :\nContinuousAt f x \u2194 \u2200 n : \u2115, ContinuousAt (fun x => f x ^ n) x :="}
{"gold_output": "theorem mass_nonzero_iff (\u03bc : FiniteMeasure \u03a9) : \u03bc.mass \u2260 0 \u2194 \u03bc \u2260 0 :=", "model_response": "lemma to_measure_apply_eq_sum_indicator (p : \u03a9 \u2192pmf \u211d\u22650) (A : Set \u03a9) :\np.toMeasure A = \u2211' x, (indicator A p x : \u211d\u22650) :="}
{"gold_output": "theorem range_comp (f : M \u2192[L] N) (g : N \u2192[L] P) : range (g.comp f : M \u2192[L] P) = map g (range f) :=", "model_response": "lemma range_comp (g : N \u2192\u2097[R] P) (f : M \u2192\u2097[R] N) : range (g.comp f : M \u2192\u2097[R] P) = map g (range f) :="}
{"gold_output": "theorem inf_eq_mul_of_coprime {I J : Ideal A} (coprime : I \u2294 J = \u22a4) : I \u2293 J = I * J :=", "model_response": "lemma inf_mul_mul_self_eq_mul {I J : Ideal A} (coprime : I \u2294 J = \u22a4) : I * J \u2293 J * I = I * J :="}
{"gold_output": "theorem IsSymmOp.flip_eq {\u03b1 \u03b2} (op) [IsSymmOp \u03b1 \u03b2 op] : flip op = op :=", "model_response": "lemma flip_eq [simp]:\nassumes \"IsSymmOp \u03b1 \u03b2 op\"\nshows \"flip (flip op) = op\""}
{"gold_output": "theorem eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two {s : AffineSubspace \u211d P}\n[FiniteDimensional \u211d s.direction] (hd : finrank \u211d s.direction = 2) {s\u2081 s\u2082 : Sphere P}\n{p\u2081 p\u2082 p : P} (hs\u2081 : s\u2081.center \u2208 s) (hs\u2082 : s\u2082.center \u2208 s) (hp\u2081s : p\u2081 \u2208 s) (hp\u2082s : p\u2082 \u2208 s)\n(hps : p \u2208 s) (hs : s\u2081 \u2260 s\u2082) (hp : p\u2081 \u2260 p\u2082) (hp\u2081s\u2081 : p\u2081 \u2208 s\u2081) (hp\u2082s\u2081 : p\u2082 \u2208 s\u2081) (hps\u2081 : p \u2208 s\u2081)\n(hp\u2081s\u2082 : p\u2081 \u2208 s\u2082) (hp\u2082s\u2082 : p\u2082 \u2208 s\u2082) (hps\u2082 : p \u2208 s\u2082) : p = p\u2081 \u2228 p = p\u2082 :=", "model_response": "lemma infdist_eq_subset_inter:\n\"{p. infdist p s\\<^sub>1 = infdist p s\\<^sub>2} \\<subseteq> s\\<^sub>1 \\<inter> s\\<^sub>2\""}
{"gold_output": "theorem Right.sign_neg [CovariantClass \u03b1 \u03b1 (Function.swap (\u00b7 + \u00b7)) (\u00b7 < \u00b7)] (a : \u03b1) :\nsign (-a) = -sign a :=", "model_response": "lemma sign_neg [simp]: \"sign (- a) = - sign a\""}
{"gold_output": "theorem mul_snd (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a * b).snd = b.snd * a.snd :=", "model_response": "lemma mul_snd (a b : \ud835\udcdc(\ud835\udd5c, A)) : (a * b).snd = b.snd * a.snd :="}
{"gold_output": "theorem wbtw_self_right (x y : P) : Wbtw R x y y :=", "model_response": "lemma wbtw_self_left_iff [simp]: \"wbtw R x x y \u2194 x = y\""}
{"gold_output": "theorem compFormalMultilinearSeries_apply (f : F \u2192L[\ud835\udd5c] G) (p : FormalMultilinearSeries \ud835\udd5c E F)\n(n : \u2115) : (f.compFormalMultilinearSeries p) n = f.compContinuousMultilinearMap (p n) :=", "model_response": "lemma compFormalMultilinearSeries_apply (f : F \u2192L[\ud835\udd5c] G) (p : FormalMultilinearSeries \ud835\udd5c E F)\n(n : \u2115) : (f.compFormalMultilinearSeries p) n = f.compContinuousMultilinearMap (p n) :="}
{"gold_output": "theorem comap_mono {S\u2081 S\u2082 : StarSubalgebra R B} {f : A \u2192\u22c6\u2090[R] B} :\nS\u2081 \u2264 S\u2082 \u2192 S\u2081.comap f \u2264 S\u2082.comap f :=", "model_response": "lemma comap_inf: \"comap f (S\u2081 \u2293 S\u2082) = comap f S\u2081 \u2293 comap f S\u2082\""}
{"gold_output": "theorem MeasurableSet.iInter [Countable \u03b9] {f : \u03b9 \u2192 Set \u03b1} (h : \u2200 b, MeasurableSet (f b)) :\nMeasurableSet (\u22c2 b, f b) :=", "model_response": "lemma measurableSet_biUnion_finset [simp]:\n\"MeasurableSet {x. \\<exists>i\\<in>I. x \\<in> f i}\""}
{"gold_output": "theorem bddBelow_bddAbove_iff_subset_Icc : BddBelow s \u2227 BddAbove s \u2194 \u2203 a b, s \u2286 Icc a b :=", "model_response": "lemma bdd_below_bdd_above_iff_inter_le:\n\"{x \\<in> s. (INF i\\<in>I. f i x) \\<le> a} = s \\<inter> (\\<Inter>i\\<in>I. {x \\<in> s. f i x \\<le> a})\""}
{"gold_output": "theorem map_nhdsWithin_preimage_eq (e : LocalHomeomorph \u03b1 \u03b2) {x} (hx : x \u2208 e.source) (s : Set \u03b2) :\nmap e (\ud835\udcdd[e \u207b\u00b9' s] x) = \ud835\udcdd[s] e x :=", "model_response": "lemma image_source_eq:\n\"e '' e.source = e.target \\<inter> e.symm \u207b\u00b9' e.source\""}
{"gold_output": "theorem coe_subset {s\u2081 s\u2082 : Finset \u03b1} : (s\u2081 : Set \u03b1) \u2286 s\u2082 \u2194 s\u2081 \u2286 s\u2082 :=", "model_response": "lemma sep_set_of_mem {s\u2081 s\u2082 : Finset \u03b1} : {a. a \u2208 s\u2081 \u2227 p a} = s\u2081 \u2229 {a | p a} :="}
{"gold_output": "theorem _root_.Filter.EventuallyEq.trans_isTheta {f\u2081 f\u2082 : \u03b1 \u2192 E} {g : \u03b1 \u2192 F} (hf : f\u2081 =\u1da0[l] f\u2082)\n(h : f\u2082 =\u0398[l] g) : f\u2081 =\u0398[l] g :=", "model_response": "lemma isTheta_norm_norm_iff [simp]:\n\"(\\<lambda>x. norm (f x)) =\u0398[l] (\\<lambda>x. norm (g x)) \\<longleftrightarrow> f =\u0398[l] g\""}
{"gold_output": "theorem ContDiff.inner (hf : ContDiff \u211d n f) (hg : ContDiff \u211d n g) :\nContDiff \u211d n fun x => \u27eaf x, g x\u27eb :=", "model_response": "lemma contDiff_inner [simp, contDiff_intros]: \"contDiff \u211d n (\\<lambda>x : (real * real). inner (x.1) (x.2))\""}
{"gold_output": "theorem singleton_pi' (i : \u03b9) (t : \u2200 i, Set (\u03b1 i)) : pi {i} t = { x | x i \u2208 t i } :=", "model_response": "lemma pi_singleton_eq (i : \u03b9) (t : \u2200 i, Set (\u03b1 i)) : pi {i} t = { x | x i \u2208 t i } :="}
{"gold_output": "theorem bot_sub : \u22a5 - t = \u22a5 :=", "model_response": "lemma sub_assoc:\nassumes \"z - x \\<le> y - x\"\nshows \"z - (x + y) \\<le> z - x\""}
{"gold_output": "theorem tsum_mul_left : (\u2211' i, a * f i) = a * \u2211' i, f i :=", "model_response": "lemma tsum_const_mul_left : \"(\\<Sum>i. a * f i) = a * (\\<Sum>i. f i)\""}
{"gold_output": "theorem csInf_union (hs : BddBelow s) (sne : s.Nonempty) (ht : BddBelow t) (tne : t.Nonempty) :\nsInf (s \u222a t) = sInf s \u2293 sInf t :=", "model_response": "lemma csInf_union: \"sInf (s \\<union> t) = sInf s \\<sqinter> sInf t\""}
{"gold_output": "theorem one_subset : (1 : Finset \u03b1) \u2286 s \u2194 (1 : \u03b1) \u2208 s :=", "model_response": "lemma card_powerset_size_eq : \"card {t. t \\<subseteq> s \\<and> card t = n} = 2 ^ card s\""}
{"gold_output": "theorem cardinal_mk_le_finrank_of_linearIndependent [FiniteDimensional K V] {\u03b9 : Type w} {b : \u03b9 \u2192 V}\n(h : LinearIndependent K b) : (#\u03b9) \u2264 finrank K V :=", "model_response": "theorem card_finsum_eq_finrank [FiniteDimensional K V] {\u03b9 : Type w} (b : \u03b9 \u2192 V)\n(h : LinearIndependent K b) : (#\u03b9 \u2192 K) = finrank K V :="}
{"gold_output": "theorem preimage_Icc {a b : \u03b1} : (Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Icc a b = Set.Icc \u2308a\u2309 \u230ab\u230b :=", "model_response": "lemma preimage_Iio : \"((Int.cast : \u2124 \u2192 \u03b1) \u207b\u00b9' Set.Iio b) = Set.Iio \u230ab\u230b\""}
{"gold_output": "theorem nhds_basis_ball {x : E} : (\ud835\udcdd x).HasBasis (fun r : \u211d => 0 < r) (ball x) :=", "model_response": "lemma uniformContinuous_coe [continuous_intros]: \"uniformContinuous ((\u2191) : \u03b1 \u2192 Completion \u03b1)\""}
{"gold_output": "theorem closure_closure {s : Set \u03b1} : closure (closure s) = closure s :=", "model_response": "lemma closure_Ici' [simp]: \"closure (Ici a) = Ici a\""}
{"gold_output": "theorem tsum_nonneg (h : \u2200 i, 0 \u2264 g i) : 0 \u2264 \u2211' i, g i :=", "model_response": "lemma isCont_of_nat : \"isCont of_nat x\""}
{"gold_output": "theorem not_imp : \u00ac(a \u2192 b) \u2194 a \u2227 \u00acb :=", "model_response": "lemma set_compr_mem_inf : {x | x \u2208 s \u2227 x \u2208 t} = s \u2229 t :="}
{"gold_output": "theorem single_eq_zero_iff {a : \u0393} {r : R} : single a r = 0 \u2194 r = 0 :=", "model_response": "lemma support_single_subset : \"support (single a r) \\<subseteq> {a}\""}
{"gold_output": "theorem natDegree_multiset_prod' (h : (t.map fun f => leadingCoeff f).prod \u2260 0) :\nt.prod.natDegree = (t.map fun f => natDegree f).sum :=", "model_response": "lemma natDegree_multiset_prod (t : Multiset R[X]) :\nt.prod.natDegree = (t.map fun f => natDegree f).sum :="}
{"gold_output": "theorem Continuous.rpow (hf : Continuous f) (hg : Continuous g) (h : \u2200 x, f x \u2260 0 \u2228 0 < g x) :\nContinuous fun x => f x ^ g x :=", "model_response": "lemma continuous_norm_rpow (hf : Continuous f) (hg : Continuous g) (h : \u2200 x, f x \u2260 0 \u2228 0 < g x) :\nContinuous fun x => \u2016f x\u2016 ^ p * g x :="}
{"gold_output": "theorem finiteDimensional_iff_of_rank_eq_nsmul {W} [AddCommGroup W] [Module K W] {n : \u2115}\n(hn : n \u2260 0) (hVW : Module.rank K V = n \u2022 Module.rank K W) :\nFiniteDimensional K V \u2194 FiniteDimensional K W :=", "model_response": "lemma rank_span [simp]: \"Module.rank K (span K s) = card s\""}
{"gold_output": "theorem support_single_ne_bot (i : \u03b1) (h : b \u2260 0) : (single i b).support \u2260 \u22a5 :=", "model_response": "lemma support_single (i : \u03b1) (h : b \u2260 0) : (single i b).support = {i} :="}
{"gold_output": "theorem eq_one_of_map_eq_one {S : Type _} [Semiring S] [Nontrivial S] (f : R \u2192+* S) (hp : p.Monic)\n(map_eq : p.map f = 1) : p = 1 :=", "model_response": "lemma degree_sub_C_le:\n\"degree (p - C a) \\<le> degree p\""}
{"gold_output": "theorem not_even_bit1 (n : \u2115) : \u00acEven (bit1 n) :=", "model_response": "lemma of_to [simp]:\n\"ofNat (toNat n) = n\""}
{"gold_output": "theorem neLocus_self_sub_left : neLocus (f - g) f = g.support :=", "model_response": "lemma neLocus_self_sub_right : \"neLocus (f - g) g = f.support\""}
{"gold_output": "theorem fderiv_mul_const' (ha : DifferentiableAt \ud835\udd5c a x) (b : \ud835\udd38) :\nfderiv \ud835\udd5c (fun y => a y * b) x = (fderiv \ud835\udd5c a x).smulRight b :=", "model_response": "lemma fderiv_const_mul [simp]: \"fderiv \ud835\udd5c (fun y => a y * b) x = (fderiv \ud835\udd5c a x).smulRight b\""}
{"gold_output": "theorem map_coprod_prod (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) (p : Submodule R M)\n(q : Submodule R M\u2082) : map (coprod f g) (p.prod q) = map f p \u2294 map g q :=", "model_response": "lemma map_coprod_coprod (f : M \u2192\u2097[R] M\u2083) (g : M\u2082 \u2192\u2097[R] M\u2083) (p : Submodule R M)\n(q : Submodule R M\u2082) : map (coprod f g) (coprod p q) = coprod (map f p) (map g q) :="}
{"gold_output": "theorem ExtensionOfMaxAdjoin.extendIdealTo_eq (h : Module.Baer R Q) {y : N} (r : R)\n(hr : r \u2022 y \u2208 (extensionOfMax i f).domain) : ExtensionOfMaxAdjoin.extendIdealTo i f h y r =\n(extensionOfMax i f).toLinearPMap \u27e8r \u2022 y, hr\u27e9 :=", "model_response": "lemma extend_inj_on:\n\"inj_on f {x. x \\<in> (extensionOfMax i f).domain}\""}
{"gold_output": "theorem dlookup_isSome {a : \u03b1} : \u2200 {l : List (Sigma \u03b2)}, (dlookup a l).isSome \u2194 a \u2208 l.keys", "model_response": "lemma dlookup_eq_none [simp]:\nassumes \"a \\<notin> l.keys\"\nshows \"dlookup a l = None\""}
{"gold_output": "theorem map_spec (z u) : f.map hy k z = u \u2194 k.toMap (g (f.sec z).1) = k.toMap (g (f.sec z).2) * u :=", "model_response": "lemma map_injective: \"Function.Injective (f.map hy k)\""}
{"gold_output": "theorem Primrec.to_comp {\u03b1 \u03c3} [Primcodable \u03b1] [Primcodable \u03c3] {f : \u03b1 \u2192 \u03c3} (hf : Primrec f) :\nComputable f :=", "model_response": "theorem prim_encode [simp]: \"prim_rec encode\""}
{"gold_output": "theorem conjugate' {x : R} (hx : x \u2208 skewAdjoint R) (z : R) : star z * x * z \u2208 skewAdjoint R :=", "model_response": "lemma star_mul_comm: \"star (x * y) = star y * star x\""}
{"gold_output": "theorem MetricSpace.replaceTopology_eq {\u03b3} [U : TopologicalSpace \u03b3] (m : MetricSpace \u03b3)\n(H : U = m.toPseudoMetricSpace.toUniformSpace.toTopologicalSpace) :\nm.replaceTopology H = m :=", "model_response": "lemma toProdMulOpp_injective:\n\"injective toProdMulOpp\""}
{"gold_output": "theorem prod_Ioi_succ {M : Type _} [CommMonoid M] {n : \u2115} (i : Fin n) (v : Fin n.succ \u2192 M) :\n(\u220f j in Ioi i.succ, v j) = \u220f j in Ioi i, v j.succ :=", "model_response": "lemma prod_Ioi_succ' [simp]:\n\"(\u220f j in Ioi i.succ, v j) = \u220f j in Ioi i, v (j.succ)\""}
{"gold_output": "theorem LinearEquiv.rank_map_eq (f : M \u2243\u2097[R] M\u2081) (p : Submodule R M) :\nModule.rank R (p.map (f : M \u2192\u2097[R] M\u2081)) = Module.rank R p :=", "model_response": "theorem rank_eq (f : M \u2243\u2097[R] M\u2081) : Module.rank R M = Module.rank R M\u2081 :="}
{"gold_output": "theorem foldr_singleton (f : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (H b a) : foldr f H b ({a} : Multiset \u03b1) = f a b :=", "model_response": "lemma foldr_singleton [simp]: \"foldr f H b {a} = f a b\""}
{"gold_output": "theorem isUnit_iff_abs_eq {x : \u2124} : IsUnit x \u2194 abs x = 1 :=", "model_response": "lemma abs_mult [simp]: \"abs (a * b) = (abs a) * (abs b)\""}
{"gold_output": "theorem iUnion_Iic_eq_Iio_iSup {R : Type _} [CompleteLinearOrder R] {f : \u03b9 \u2192 R}\n(no_greatest_elem : (\u2a06 i, f i) \u2209 range f) : (\u22c3 i : \u03b9, Iic (f i)) = Iio (\u2a06 i, f i) :=", "model_response": "lemma iUnion_Iic_eq_Iio_sInf_sSup:\n\"(\\<Union> (a, b) \\<in> z. Iic b) = Iio (sInf (fst ` z))\"\n\"(\\<Union> (a, b) \\<in> z. Iic b) = Iio (sInf (snd ` z))\""}
{"gold_output": "theorem homOfLe_injective {I\u2081 I\u2082 : LieIdeal R L} (h : I\u2081 \u2264 I\u2082) : Function.Injective (homOfLe h) :=", "model_response": "lemma homOfLe_injective_of_lieIso :\n\"Function.Injective (homOfLe h : L \\<Rightarrow> L')\""}
{"gold_output": "theorem zpow_bit1_neg_iff : a ^ bit1 n < 0 \u2194 a < 0 :=", "model_response": "lemma ofReal_mul_I [simp]: \"ofReal (x * \\<I>) = ofReal x * \\<I>\""}
{"gold_output": "theorem induction {p : (\u03a0\u2080 i, \u03b2 i) \u2192 Prop} (f : \u03a0\u2080 i, \u03b2 i) (h0 : p 0)\n(ha : \u2200 (i b) (f : \u03a0\u2080 i, \u03b2 i), f i = 0 \u2192 b \u2260 0 \u2192 p f \u2192 p (single i b + f)) : p f :=", "model_response": "lemma single_injective [simp]: \"single i b = single i' b' \\<longleftrightarrow> i = i' \\<and> b = b'\""}
{"gold_output": "theorem chain_iff_nthLe {R} {a : \u03b1} {l : List \u03b1} : Chain R a l \u2194\n(\u2200 h : 0 < length l, R a (nthLe l 0 h)) \u2227\n\u2200 (i) (h : i < length l - 1),\nR (nthLe l i (lt_of_lt_pred h)) (nthLe l (i + 1) (lt_pred_iff.mp h)) :=", "model_response": "lemma chain_append_iff:\nshows \"chain R (l @ l') \\<longleftrightarrow> chain R l \\<and> chain R l' \\<and> (\\<forall>a b. a \\<in> last_option l \\<and> b \\<in> hd_option l' \\<longrightarrow> R a b)\""}
{"gold_output": "theorem toFinset_image [DecidableEq \u03b2] (f : \u03b1 \u2192 \u03b2) (hs : s.Finite) (h : (f '' s).Finite) :\nh.toFinset = hs.toFinset.image f :=", "model_response": "lemma sep_image_eq: \"{ x \\<in> s | p x } = (%x. x.p) '' { x \\<in> s | q x }\""}
{"gold_output": "theorem incidence_other_neighbor_edge {v w : V} (h : w \u2208 G.neighborSet v) :\nG.otherVertexOfIncident (G.mem_incidence_iff_neighbor.mpr h) = w :=", "model_response": "lemma edgeSet_deleteEdge[simp]:\n\"edgeSet (G.deleteEdge v w) = edgeSet G - {(v,w)}\""}
{"gold_output": "theorem tsum_mul_tsum (hf : Summable f) (hg : Summable g)\n(hfg : Summable fun x : \u03b9 \u00d7 \u03ba => f x.1 * g x.2) :\n((\u2211' x, f x) * \u2211' y, g y) = \u2211' z : \u03b9 \u00d7 \u03ba, f z.1 * g z.2 :=", "model_response": "lemma tsum_mul_tsum_prod_eq_tsum_mul_tsum :\n\"(\\<Sum>x. f x * g x) = (\\<Sum>x. f x) * (\\<Sum>y. g y)\""}
{"gold_output": "theorem isOpenMap_im : IsOpenMap im :=", "model_response": "lemma continuous_im : Continuous im :="}
{"gold_output": "theorem torsion_eq_torsion_submonoid : CommMonoid.torsion G = (torsion G).toSubmonoid :=", "model_response": "lemma (in Module) torsion_eq_torsion_submonoid:\"torsion R M = (torsion R M).toSubmonoid\""}
{"gold_output": "theorem strongInductionOn_eq {p : Multiset \u03b1 \u2192 Sort _} (s : Multiset \u03b1) (H) :\n@strongInductionOn _ p s H = H s fun t _h => @strongInductionOn _ p t H :=", "model_response": "lemma strongInductionOn_cons [case_names empty single cons]:\nassumes empty: \"p [] 0\"\nand     single: \"\\<And>x s. p s 0 \\<Longrightarrow> p (x :: s) (f x s)\"\nand     cons:   \"\\<And>s x H. p s 0 \\<Longrightarrow> (\\<And>y s'. y \\<in> s \\<Longrightarrow> p s' 0 \\<Longrightarrow> p s' (f y s')) \\<Longrightarrow> p (x :: s) (f x s)\"\nshows \"p s (f s)\""}
{"gold_output": "theorem inv_def' {a b : \u2124} : (a /. b)\u207b\u00b9 = b /. a :=", "model_response": "lemma inv_def': \"a /. b\u207b\u00b9 = b /. a\""}
{"gold_output": "theorem withDensity_zero : \u03bc.withDensity 0 = 0 :=", "model_response": "lemma withDensity_univ_eq_zero_iff : \u03bc.withDensity 1 univ = 0 \u2194 \u03bc = 0 :="}
{"gold_output": "theorem Finset.hasSum_iff_compl (s : Finset \u03b2) :\nHasSum f a \u2194 HasSum (fun x : { x // x \u2209 s } => f x) (a - \u2211 i in s, f i) :=", "model_response": "lemma hasSum_compl_add:\nfixes f :: \"'a \\<Rightarrow> 'b :: {t2_space, topological_add_zero}\"\nshows \"hasSum f a s \\<longleftrightarrow> HasSum (fun x : { x // x \\<notin> s } => f x) (a - \u2211 i in s, f i) + hasSum f 0 s\""}
{"gold_output": "theorem isDomain_of_le_nonZeroDivisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n(hM : M \u2264 nonZeroDivisors A) : IsDomain S :=", "model_response": "lemma toFun_inj : Function.Injective (toFun::(monoid_algebra R M) \u2192 M \u2192 R) :="}
{"gold_output": "theorem symm_dual_id : InfTopHom.dual.symm (SupBotHom.id _) = InfTopHom.id \u03b1 :=", "model_response": "lemma dual_id : InfTopHom.dual.symm (SupBotHom.id _) = SupBotHom.id \u03b1 :="}
{"gold_output": "theorem integral_congr {a b : \u211d} (h : EqOn f g [[a, b]]) :\n(\u222b x in a..b, f x \u2202\u03bc) = \u222b x in a..b, g x \u2202\u03bc :=", "model_response": "lemma integral_eq_iff_eq_on_Ioo:\nfixes f g :: \"real \\<Rightarrow> 'a::euclidean_space\"\nshows \"(integral {a..b} f \u2202\u03bc = integral {a..b} g \u2202\u03bc) \\<longleftrightarrow> (\\<forall>x\\<in>{a<..<b}. f x = g x)\""}
{"gold_output": "theorem mk.inj_right {\u03b1 \u03b2 : Type _} (b : \u03b2) :\nFunction.Injective (fun a \u21a6 Prod.mk a b : \u03b1 \u2192 \u03b1 \u00d7 \u03b2) :=", "model_response": "lemma prod_inj_right [simp]:\n\"Function.Injective (\\<lambda>(a, b). a * b)\""}
{"gold_output": "theorem lift_comp_of (f : \u03b1 \u2192 M) : lift f \u2218 of = f :=", "model_response": "lemma lift_comp_of [simp]: \"lift f \u2218 of = f\""}
{"gold_output": "theorem cycleType_def (\u03c3 : Perm \u03b1) :\n\u03c3.cycleType = \u03c3.cycleFactorsFinset.1.map (Finset.card \u2218 support) :=", "model_response": "lemma support_cycleType : \u03c3.cycleType.support = \u03c3.support :="}
{"gold_output": "theorem nnnorm_equiv_symm_one {\u03b2} [SeminormedAddCommGroup \u03b2] (hp : p \u2260 \u221e) [One \u03b2] :\n\u2016(PiLp.equiv p fun _ : \u03b9 => \u03b2).symm 1\u2016\u208a =\n(Fintype.card \u03b9 : \u211d\u22650) ^ (1 / p).toReal * \u2016(1 : \u03b2)\u2016\u208a :=", "model_response": "lemma nnnorm_equiv_symm_one [simp]:\n\"\u2016(PiLp.equiv p fun _ : \u03b9 => \u03b2).symm 1\u2016\u208a =\n(Fintype.card \u03b9 : \u211d\u22650) ^ (1 / p).toReal * \u2016(1 : \u03b2)\u2016\u208a\""}
{"gold_output": "theorem lift_succ (a : Ordinal.{v}) : lift.{u} (succ a) = succ (lift.{u} a) :=", "model_response": "lemma lift_succ [simp]: \"lift.{u} (succ a) = succ (lift.{u} a)\""}
{"gold_output": "theorem mk_Prop : (#Prop) = 2 :=", "model_response": "theorem mk_Prop : (#Prop) = 2 :="}
{"gold_output": "theorem isDiag_one [DecidableEq n] [Zero \u03b1] [One \u03b1] : (1 : Matrix n n \u03b1).IsDiag :=", "model_response": "lemma isDiag_one [simp]: \"isDiag (1 : Matrix n n \u03b1)\""}
{"gold_output": "theorem TransGen.closed {p : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n(\u2200 a b, r a b \u2192 TransGen p a b) \u2192 TransGen r a b \u2192 TransGen p a b :=", "model_response": "lemma trancl_idem_idem {p : \u03b1 \u2192 \u03b1 \u2192 Prop} :\n(\u2200 a b, r a b \u2192 TransGen p a b) \u2192 TransGen (TransGen r) a b = TransGen r a b :="}
{"gold_output": "theorem aevalTower_id :\naevalTower (AlgHom.id S S) = (aeval : (\u03c3 \u2192 S) \u2192 MvPolynomial \u03c3 S \u2192\u2090[S] S) :=", "model_response": "lemma polynomial_function: \"polynomial_function f\""}
{"gold_output": "theorem domain_mono : StrictMono (@domain R _ E _ _ F _ _) :=", "model_response": "lemma domain_eq: \"domain f = {x. f x \\<noteq> 0}\""}
{"gold_output": "theorem integral_deriv_comp_mul_deriv {f f' g g' : \u211d \u2192 \u211d}\n(hf : \u2200 x \u2208 uIcc a b, HasDerivAt f (f' x) x)\n(hg : \u2200 x \u2208 uIcc a b, HasDerivAt g (g' (f x)) (f x)) (hf' : ContinuousOn f' (uIcc a b))\n(hg' : Continuous g') : (\u222b x in a..b, (g' \u2218 f) x * f' x) = (g \u2218 f) b - (g \u2218 f) a :=", "model_response": "lemma integral_mul_deriv:\nassumes f': \"\\<And>x. x \\<in> uIcc a b \\<Longrightarrow> HasDerivAt f (f' x) x\"\nassumes g': \"\\<And>x. x \\<in> uIcc a b \\<Longrightarrow> HasDerivAt g (g' (f x)) (f x)\"\nassumes cont_f': \"ContinuousOn f' (uIcc a b)\"\nassumes cont_g': \"Continuous g'\"\nshows \"(\u222b x in a..b, f x * f' x) = f b - f a\""}
{"gold_output": "theorem isLeast_bot_iff [OrderBot \u03b1] : IsLeast s \u22a5 \u2194 \u22a5 \u2208 s :=", "model_response": "lemma Iic_bot [simp]: \"{..\\<le>\\<^sub>abot} = {bot}\""}
{"gold_output": "theorem Stable.exists_forall_le (h : F.Stable) (e : F.N 0 \u2264 F'.N 0) :\n\u2203 n\u2080, \u2200 n, F.N (n + n\u2080) \u2264 F'.N n :=", "model_response": "lemma stable_imp_eventually_stable:\nassumes \"F.Stable\"\nshows \"\\<exists> n\\<^sub>0. \\<forall> n. F.N (n + n\\<^sub>0) \\<le> F'.N n\""}
{"gold_output": "theorem cutExpand_le_invImage_lex [IsIrrefl \u03b1 r] :\nCutExpand r \u2264 InvImage (Finsupp.Lex (r\u1d9c \u2293 (\u00b7 \u2260 \u00b7)) (\u00b7 < \u00b7)) toFinsupp :=", "model_response": "lemma card_bijections_domain_and_range_permutation_eq_zero:\nassumes \"card A \\<noteq> card B\"\nshows \"card ({f \\<in> A \\<rightarrow>\\<^sub>E B. bij_betw f A B} // domain_and_range_permutation A B) = 0\""}
{"gold_output": "theorem abs_pow (z : \u2102) (n : \u2115) : Complex.abs (z ^ n) = Complex.abs z ^ n :=", "model_response": "lemma abs_exp (z : \u2102) : abs (exp z) = exp z.re :="}
{"gold_output": "theorem nonMemberSubfamily_union (a : \u03b1) (\ud835\udc9c \u212c : Finset (Finset \u03b1)) :\n(\ud835\udc9c \u222a \u212c).nonMemberSubfamily a = \ud835\udc9c.nonMemberSubfamily a \u222a \u212c.nonMemberSubfamily a :=", "model_response": "lemma nonMemberSubfamily_union:\n\"(\ud835\udc9c \u222a \u212c).nonMemberSubfamily a = \ud835\udc9c.nonMemberSubfamily a \u222a \u212c.nonMemberSubfamily a\""}
{"gold_output": "theorem Preperfect.perfect_closure (hC : Preperfect C) : Perfect (closure C) :=", "model_response": "lemma perfect_closure_iff [simp]: \"Perfect (closure S) \\<longleftrightarrow> Perfect S\""}
{"gold_output": "theorem map_sum {\u03b9 : Type _} (f : M\u2081 \u2192SL[\u03c3\u2081\u2082] M\u2082) (s : Finset \u03b9) (g : \u03b9 \u2192 M\u2081) :\nf (\u2211 i in s, g i) = \u2211 i in s, f (g i) :=", "model_response": "lemma continuousAt_iff_tendsto_zero:\n\"ContinuousAt f x \\<longleftrightarrow> ((\\<lambda>y. f (x + y)) \\<longlongrightarrow> f x) (\ud835\udcdd 0)\""}
{"gold_output": "theorem null_of_totalVariation_zero (s : SignedMeasure \u03b1) {i : Set \u03b1}\n(hs : s.totalVariation i = 0) : s i = 0 :=", "model_response": "lemma nonpos_meas_of_totalVariation_zero : \"s i \\<le> 0\""}
{"gold_output": "theorem ext {f g : SpectralMap \u03b1 \u03b2} (h : \u2200 a, f a = g a) : f = g :=", "model_response": "lemma id_comp [simp]: \"SpectralMap.id \u03b1 \\<circ> f = f\""}
{"gold_output": "theorem inf_principal_eq_bot {f : Filter \u03b1} {s : Set \u03b1} : f \u2293 \ud835\udcdf s = \u22a5 \u2194 s\u1d9c \u2208 f :=", "model_response": "lemma inf_principal_eq_bot_iff {f : Filter \u03b1} {s : Set \u03b1} : f \u2293 \ud835\udcdf s = \u22a5 \u2194 s\u1d9c \u2208 f :="}
{"gold_output": "theorem map_inv (a : A\u02e3) : (\u03c3 (a : A))\u207b\u00b9 = \u03c3 (\u2191a\u207b\u00b9 : A) :=", "model_response": "lemma injective_sigma [simp]:\n\"injective \\<sigma>\""}
{"gold_output": "theorem monotone_preimage {f : \u03b1 \u2192 \u03b2} (h : Injective f) :\nMonotone fun s => preimage s f (h.injOn _) :=", "model_response": "lemma monotoneOn: \"monotoneOn (\u00b7 \u2264 \u00b7) s (preimage f (h.injOn _))\""}
{"gold_output": "theorem mk_top [OrderTop \u03b1] [OrderTop (Subtype p)] (htop : p \u22a4) : mk \u22a4 htop = \u22a4 :=", "model_response": "lemma mk_eq_top_iff [simp]:\nassumes hp: \"\\<exists>!x. p x\"\nshows \"mk p h = \u22a4 \u2194 p \u22a4\""}
{"gold_output": "theorem image_fst_divisorsAntidiagonal : (divisorsAntidiagonal n).image Prod.fst = divisors n :=", "model_response": "lemma divisors_eq_divisorsAntidiagonal :\n\"divisors n = {d. d |\\<in>| divisorsAntidiagonal n \\<and> d \\<noteq> 1}\""}
{"gold_output": "theorem nhds_basis_closedBall_pow {r : \u211d} (h0 : 0 < r) (h1 : r < 1) :\n(\ud835\udcdd x).HasBasis (fun _ => True) fun n : \u2115 => closedBall x (r ^ n) :=", "model_response": "lemma continuous_at_iff_pos_ball:\n\"continuous (at x) f \\<longleftrightarrow> (\\<forall>\u03b5>0. \\<exists>\u03b4>0. \\<forall>y. dist y x < \u03b4 \\<longrightarrow> dist (f y) (f x) < \u03b5)\""}
{"gold_output": "theorem mul_assoc' (mul : A \u2297[R] B \u2192\u2097[R] A \u2297[R] B \u2192\u2097[R] A \u2297[R] B)\n(h :\n\u2200 (a\u2081 a\u2082 a\u2083 : A) (b\u2081 b\u2082 b\u2083 : B),\nmul (mul (a\u2081 \u2297\u209c[R] b\u2081) (a\u2082 \u2297\u209c[R] b\u2082)) (a\u2083 \u2297\u209c[R] b\u2083) =\nmul (a\u2081 \u2297\u209c[R] b\u2081) (mul (a\u2082 \u2297\u209c[R] b\u2082) (a\u2083 \u2297\u209c[R] b\u2083))) :\n\u2200 x y z : A \u2297[R] B, mul (mul x y) z = mul x (mul y z) :=", "model_response": "lemma mul_tensor_mul:\n\"mul (a \\<otimes>\\<^sub>u b) (c \\<otimes>\\<^sub>u d) = (a * c) \\<otimes>\\<^sub>u (b * d)\""}
{"gold_output": "theorem trans [Algebra A B] [IsScalarTower R A B] (hfpA : FinitePresentation R A)\n(hfpB : FinitePresentation A B) : FinitePresentation R B :=", "model_response": "lemma of_one [simp]:\n\"of (1 : A) = (1 : FractionRing K[X])\""}
{"gold_output": "theorem isPrimary_inf {I J : Ideal R} (hi : IsPrimary I) (hj : IsPrimary J)\n(hij : radical I = radical J) : IsPrimary (I \u2293 J) :=", "model_response": "lemma radical_inf_eq (I J : Ideal R) (hi : IsPrimary I) (hj : IsPrimary J)\n(hij : radical I = radical J) : radical (I \u2293 J) = radical I \u2293 radical J :="}
{"gold_output": "theorem sigma_univ_range_eq {f : \u2200 i, \u03b1 i \u2192 \u03b2 i} :\n((univ : Set \u03b9).Sigma fun i \u21a6 range (f i)) = range fun x : \u03a3i, \u03b1 i \u21a6 \u27e8x.1, f _ x.2\u27e9 :=", "model_response": "lemma sigma_mk_injective [simp]:\n\"Injective Sigma.mk\""}
{"gold_output": "theorem one_div_pos_of_nat {n : \u2115} : 0 < 1 / ((n : \u03b1) + 1) :=", "model_response": "lemma toIcoMod_eq_self_iff:\n'toIcoMod hp a b = b  \\<longleftrightarrow> b \u2208 Set.Ico a (a + p)'"}
{"gold_output": "theorem symm_symm : e.symm.symm = e :=", "model_response": "lemma toAddMonoidHom_coe: (toAddMonoidHom : Multiplicative R \u2192+ R) = toAdd :="}
{"gold_output": "theorem induction_on_mul_T {Q : R[T;T\u207b\u00b9] \u2192 Prop} (f : R[T;T\u207b\u00b9])\n(Qf : \u2200 {f : R[X]} {n : \u2115}, Q (toLaurent f * T (-n))) : Q f :=", "model_response": "lemma degree_C_mul_T_le : \"degree (C a * T v) \\<le> degree (T v)\""}
{"gold_output": "theorem mulVec\u1d63_eq [NonUnitalNonAssocSemiring \u03b1] (A : Matrix (Fin l) (Fin m) \u03b1) (v : Fin m \u2192 \u03b1) :\nmulVec\u1d63 A v = A.mulVec v :=", "model_response": "lemma mulVec_eq_mulVec_assoc:\nassumes \"dim_col A = dim_vec v\"\nshows \"mulVec A v = mulVec_assoc (A :: 'a :: semiring_1 ^ 'm ^ 'n) v\""}
{"gold_output": "theorem toOrderMonoidHom_eq_coe (f : \u03b1 \u2192*\u2080o \u03b2) : f.toOrderMonoidHom = f :=", "model_response": "lemma strictMonoOn_iff_lt:\n\"StrictMonoOn f s \\<longleftrightarrow> (\\<forall>x\\<in>s. \\<forall>y\\<in>s. x < y \\<longrightarrow> f x < f y)\""}
{"gold_output": "theorem length_sublistsLen {\u03b1 : Type _} :\n\u2200 (n) (l : List \u03b1), length (sublistsLen n l) = Nat.choose (length l) n", "model_response": "lemma length_sublists_eq_choose :\n\"\\<forall> n l. length (sublists l n) = (length l) choose n\""}
{"gold_output": "theorem smul (c : \ud835\udd5c) (hf : IsBoundedLinearMap \ud835\udd5c f) : IsBoundedLinearMap \ud835\udd5c (c \u2022 f) :=", "model_response": "lemma differentiableAt_const_smul_iff (c : \ud835\udd5c) :\nDifferentiableAt \ud835\udd5c (fun y => c \u2022 f y) x \u2194 DifferentiableAt \ud835\udd5c f x :="}
{"gold_output": "theorem parallelFamily_obj_one : (parallelFamily f).obj one = Y :=", "model_response": "lemma parallelFamily_left_right_eq: \"(parallelFamily f).obj one \u226b I.left = (parallelFamily f).obj one \u226b I.right.op\""}
{"gold_output": "theorem ext {f g : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082} (h : \u2200 x, f x = g x) : f = g :=", "model_response": "lemma to_fun_inj {f g : P \u2192\u1d43\u2071[\ud835\udd5c] P\u2082} : to_fun f = to_fun g \u2194 f = g :="}
{"gold_output": "theorem bot_def : (\u22a5 : Setoid \u03b1).Rel = (\u00b7 = \u00b7) :=", "model_response": "lemma top_def: \"(\\<top> : Setoid \u03b1).Rel = Eqv.refl \u03b1\""}
{"gold_output": "theorem eventually_pow_one_div_le (x : \u211d\u22650) {y : \u211d\u22650} (hy : 1 < y) :\n\u2200\u1da0 n : \u2115 in atTop, x ^ (1 / n : \u211d) \u2264 y :=", "model_response": "lemma inverse_tendsto_zero_atTop_nat :\n\"((\\<lambda>n::nat. inverse (real n)) \\<longlongrightarrow> (0::real)) atTop\""}
{"gold_output": "theorem preimage_symm_preimage (e : \u03b1 \u2243o \u03b2) (s : Set \u03b1) : e \u207b\u00b9' (e.symm \u207b\u00b9' s) = s :=", "model_response": "lemma preimage_symm_preimage (e : \u03b1 \u2243o \u03b2) (s : Set \u03b1) : e \u207b\u00b9' (e.symm \u207b\u00b9' s) = s :="}
{"gold_output": "theorem restrict_apply {i : Set \u03b1} (hi : MeasurableSet i) {j : Set \u03b1} (hj : MeasurableSet j) :\nv.restrict i j = v (j \u2229 i) :=", "model_response": "lemma restrictScalars_injective : Injective (restrictScalars K K' V) :="}
{"gold_output": "theorem colimit.\u03b9_desc_app (H : J \u2964 K \u2964 C) [HasColimit H] (c : Cocone H) (j : J) (k : K) :\n(colimit.\u03b9 H j).app k \u226b (colimit.desc H c).app k = (c.\u03b9.app j).app k :=", "model_response": "lemma colimit_comp_desc (H : J \u2964 K \u2964 C) [HasColimit H] (c : Cocone H) (j : J) (k : K) :\ncolimit.\u03c0 H j k \u226b (colimit.desc H c).app k = (c.\u03b9.app j).app k :="}
{"gold_output": "theorem nat_cast_succ (n : \u2115) : \u2191n.succ = succ (n : Ordinal) :=", "model_response": "lemma card_fintypeIic : \"card (Set.Iic n) = n\"\nfor n :: nat"}
{"gold_output": "theorem self : FiniteType R R :=", "model_response": "lemma (in domain) fin_eq_top : \"finiteType (\u22a4 : Subring R) R = finiteType R R\""}
{"gold_output": "theorem unbounded_lt_of_forall_exists_le [Preorder \u03b1] (h : \u2200 a, \u2203 b \u2208 s, a \u2264 b) :\nUnbounded (\u00b7 < \u00b7) s :=", "model_response": "lemma Iic_eq' [simp]: \"{a | a \\<le> b} = {a | a \\<le> c}\""}
{"gold_output": "theorem toFinset_sum_count_eq (s : Multiset \u03b1) : (\u2211 a in s.toFinset, s.count a) = card s :=", "model_response": "lemma card_filter_compl (s : Multiset \u03b1) :\ncard {a \u2208 s.toFinset.val. filter p | a \u2208 s} + card {a \u2208 s.toFinset.val. filter (Not \u2218 p) | a \u2208 s} =\ncard s :="}
{"gold_output": "theorem succ_neg_nat_succ (n : \u2115) : succ (-Nat.succ n) = -n :=", "model_response": "lemma succ_neg_nat_succ (n : \u2115) : succ (-Nat.succ n) = -n :="}
{"gold_output": "theorem over_product_of_widePullback [HasLimitsOfShape (WidePullbackShape J) C] {B : C} :\nHasLimitsOfShape (Discrete J) (Over B) :=", "model_response": "lemma over_product_map_commutes:\n\"pre \\<cdot> map (op (J.prod (op J))) = map (op (J.prod (op J))) \\<cdot> post\""}
{"gold_output": "theorem add_apply (f g : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) (x : M) : (f + g) x = f x + g x :=", "model_response": "lemma differentiable_add_iff:\n\"(\\<lambda>x. f x + g x) differentiable at x \\<longleftrightarrow> f differentiable at x \\<and> g differentiable at x\""}
{"gold_output": "theorem map'_mk [t : Setoid \u03b2] (f : \u03b1 \u2192 \u03b2) (h) (x : \u03b1) :\n(Quotient.mk s x).map' f h = (Quotient.mk t (f x)) :=", "model_response": "lemma continuousWithinAt_iff_continuousAt_inter:\n\"continuousWithinAt f s x \\<longleftrightarrow> continuousAt f (s \\<inter> f -` {b. Quotient.mk s b = Quotient.mk s x}) x\""}
{"gold_output": "theorem cos_sub_two_pi (x : \u211d) : cos (x - 2 * \u03c0) = cos x :=", "model_response": "lemma cos_sub_two_pi [simp]: \"cos (x - 2 * \u03c0) = cos x\"\nfor x :: real"}
{"gold_output": "theorem expSeries_summable (x : \ud835\udd38) : Summable fun n => expSeries \ud835\udd42 \ud835\udd38 n fun _ => x :=", "model_response": "lemma exp_ofReal (x : \u211d) : exp \ud835\udd42 (x : \ud835\udd38) = exp \ud835\udd42 x :="}
{"gold_output": "theorem toBoolAlg_inj {a b : \u03b1} : toBoolAlg a = toBoolAlg b \u2194 a = b :=", "model_response": "lemma of_bool_alg_inj [simp]: \"ofBoolAlg a = ofBoolAlg b \\<longleftrightarrow> a = b\""}
{"gold_output": "theorem neg_mul (M : Matrix m n \u03b1) (N : Matrix n o \u03b1) : (-M) \u2b1d N = -M \u2b1d N :=", "model_response": "lemma neg_mul [simp]: \"- (A * B) = - A * B\" for A B :: \"('a::ring_1)^'n^'m\""}
{"gold_output": "theorem toOuterMeasure_uniformOfFinset_apply :\n(uniformOfFinset s hs).toOuterMeasure t = (s.filter (\u00b7 \u2208 t)).card / s.card :=", "model_response": "lemma toOuterMeasure_uniformOfFinset_apply [simp]:\n\"(uniformOfFinset s hs).toOuterMeasure t = (s.filter (\u00b7 \u2208 t)).card / s.card\""}
{"gold_output": "theorem lineMap_strict_mono_right (hb : b < b') (hr : 0 < r) : lineMap a b r < lineMap a b' r :=", "model_response": "lemma lineMap_le_right : \"lineMap a b r \\<le> b'\""}
{"gold_output": "theorem nonempty_completion_iff : Nonempty (Completion \u03b1) \u2194 Nonempty \u03b1 :=", "model_response": "lemma toCompl_injective:\n\"inj toCompl\""}
{"gold_output": "theorem perm_replace {a : \u03b1} {b : \u03b2 a} {s\u2081 s\u2082 : AList \u03b2} :\ns\u2081.entries ~ s\u2082.entries \u2192 (replace a b s\u2081).entries ~ (replace a b s\u2082).entries :=", "model_response": "theorem perm_replace {a : \u03b1} {b : \u03b2 a} {s\u2081 s\u2082 : AList \u03b2} :\n(replace a b s\u2081).entries ~ (replace a b s\u2082).entries \u2194 s\u2081.entries ~ s\u2082.entries :="}
{"gold_output": "theorem commonNeighbors_symm (v w : V) : G.commonNeighbors v w = G.commonNeighbors w v :=", "model_response": "lemma commonNeighbors_symm: \"G.commonNeighbors v w = G.commonNeighbors w v\""}
{"gold_output": "theorem mem_toFinset {a : \u03b1} {o : Option \u03b1} : a \u2208 o.toFinset \u2194 a \u2208 o :=", "model_response": "lemma toFinset_injective:\n\"o\u2081.toFinset = o\u2082.toFinset \\<longleftrightarrow> o\u2081 = o\u2082\""}
{"gold_output": "theorem log_div_mul_self (b n : \u2115) : log b (n / b * b) = log b n :=", "model_response": "lemma log_le_clog (b n : \u2115) : log b n \u2264 clog b n :="}
{"gold_output": "theorem bind_zero_right (m : Measure \u03b1) : bind m (0 : \u03b1 \u2192 Measure \u03b2) = 0 :=", "model_response": "lemma integrable_iff_integrable_coeFn [simp]:\n\"Integrable.integrable (\u03bc : Measure \u03b1) f \u2194 Integrable f \u03bc\""}
{"gold_output": "theorem LinearIndependent.eq_of_smul_apply_eq_smul_apply {M : Type _} [AddCommGroup M] [Module R M]\n{v : \u03b9 \u2192 M} (li : LinearIndependent R v) (c d : R) (i j : \u03b9) (hc : c \u2260 0)\n(h : c \u2022 v i = d \u2022 v j) : i = j :=", "model_response": "lemma card_le_dim_span :\nassumes \"set vs \\<subseteq> span R (range v)\"\nshows \"card (set vs) \\<le> dim R M\""}
{"gold_output": "theorem IsMaxOn.comp_mono (hf : IsMaxOn f s a) {g : \u03b2 \u2192 \u03b3} (hg : Monotone g) :\nIsMaxOn (g \u2218 f) s a :=", "model_response": "lemma continuous_leftLim_eq: \"continuous (at x) f \\<longleftrightarrow> leftLim f x = f x\""}
{"gold_output": "theorem inf_sup_inf (s : Finset \u03b9) (t : Finset \u03ba) (f : \u03b9 \u2192 \u03b1) (g : \u03ba \u2192 \u03b1) :\ns.inf f \u2294 t.inf g = (s \u00d7\u02e2 t).inf fun i => f i.1 \u2294 g i.2 :=", "model_response": "lemma inf_insert [simp]:\n\"(insert a s).inf f = f a \u2294 s.inf f\""}
{"gold_output": "theorem continuousOn_exp : ContinuousOn (exp \ud835\udd42 : \ud835\udd38 \u2192 \ud835\udd38) (EMetric.ball 0 (expSeries \ud835\udd42 \ud835\udd38).radius) :=", "model_response": "lemma contDiffOn_exp : ContDiffOn \ud835\udd42 univ (exp \ud835\udd42) :="}
{"gold_output": "theorem bddBelow_union [SemilatticeInf \u03b3] {s t : Set \u03b3} :\nBddBelow (s \u222a t) \u2194 BddBelow s \u2227 BddBelow t :=", "model_response": "lemma bddBelow_Iic : \"bddBelow {x. x \\<le> a}\""}
{"gold_output": "theorem prod_Ico_succ_div_top (hmn : m \u2264 n) :\n(\u220f i in Ico m (n + 1), f i) / f n = \u220f i in Ico m n, f i :=", "model_response": "lemma prod_Ico_div_last:\n\"(\u220f i in Ico m (n + 1), f i) / f n = \u220f i in Ico m n, f i\""}
{"gold_output": "theorem UniformCauchySeqOnFilter.one_smulRight {l' : Filter \ud835\udd5c}\n(hf' : UniformCauchySeqOnFilter f' l l') :\nUniformCauchySeqOnFilter (fun n => fun z => (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c).smulRight (f' n z)) l l' :=", "model_response": "lemma uniformContinuous_one_smulRight:\n\"uniformContinuous (\\<lambda>x. (1 : \ud835\udd5c \u2192L[\ud835\udd5c] \ud835\udd5c).smulRight x)\""}
{"gold_output": "theorem removeLeftOp_id : NatTrans.removeLeftOp (\ud835\udfd9 F.leftOp) = \ud835\udfd9 F :=", "model_response": "lemma leftUnitor_inv_naturality :\n\"(LUNIT F).inv \u226b (\u03b1_ (\ud835\udfd9_ C) F F).hom = \ud835\udfd9 F\""}
{"gold_output": "theorem isArtinian_iff_wellFounded :\nIsArtinian R M \u2194 WellFounded ((\u00b7 < \u00b7) : Submodule R M \u2192 Submodule R M \u2192 Prop) :=", "model_response": "theorem Submodule.directed_on_submodule :\nDirectedOn (fun m m' => m \u2264 m') (Submodule.submodule R M) :="}
{"gold_output": "theorem lt_pred {a b} : a < pred b \u2194 succ a < b :=", "model_response": "lemma card_fset_lt_ord[simp]:\nshows \"card_fset xs < ord b \\<longleftrightarrow> card xs < b\""}
{"gold_output": "theorem Matrix.toBilin'_toMatrix' (B : BilinForm R\u2082 (n \u2192 R\u2082)) :\nMatrix.toBilin' (BilinForm.toMatrix' B) = B :=", "model_response": "lemma BilinForm.toMatrix'_eq_toMatrix: \"Matrix.toBilin' (BilinForm.toMatrix' B) = B\""}
{"gold_output": "theorem SMulCommClass.of_mul_smul_one {M N} [Monoid N] [SMul M N]\n(H : \u2200 (x : M) (y : N), y * x \u2022 (1 : N) = x \u2022 y) : SMulCommClass M N N :=", "model_response": "lemma smul_monomial {a : \u03b1} {b : R} {n : \u2115} : a \u2022 monomial n b = monomial n (a \u2022 b) :="}
{"gold_output": "theorem HasAntitoneBasis.mem_iff [Preorder \u03b9] {l : Filter \u03b1} {s : \u03b9 \u2192 Set \u03b1}\n(hs : l.HasAntitoneBasis s) {t : Set \u03b1} : t \u2208 l \u2194 \u2203 i, s i \u2286 t :=", "model_response": "lemma monotone_of_nat [simp]: \"monotone of_nat\""}
{"gold_output": "theorem _root_.LinearMap.IsSymmetric.isSelfAdjoint {A : E \u2192L[\ud835\udd5c] E}\n(hA : (A : E \u2192\u2097[\ud835\udd5c] E).IsSymmetric) : IsSelfAdjoint A :=", "model_response": "lemma toFun_eq_coe: \"toFun A = A\""}
{"gold_output": "theorem inr.inj_iff {a b} : (inr a : Sum \u03b1 \u03b2) = inr b \u2194 a = b :=", "model_response": "lemma inr.inj [simp]: \"inr a = inr b \\<longleftrightarrow> a = b\""}
{"gold_output": "theorem untrop_trop (x : R) : untrop (trop x) = x :=", "model_response": "lemma surj_untrop: \"surj untrop\""}
{"gold_output": "theorem isMinFilter_dual_iff : IsMinFilter (toDual \u2218 f) l a \u2194 IsMaxFilter f l a :=", "model_response": "lemma IsMinFilter_dual_iff:\n\"IsMinFilter (toDual \\<circ> f) l a  \\<longleftrightarrow> IsMaxFilter f l (ofDual a)\""}
{"gold_output": "theorem mem_insert {a a'} {b' : \u03b2 a'} (s : AList \u03b2) : a \u2208 insert a' b' s \u2194 a = a' \u2228 a \u2208 s :=", "model_response": "lemma set_compr_filter_eq [simp]:\n\"{x. x \\<in> s \\<and> P x} = {x \\<in> s. P x}\""}
{"gold_output": "theorem case_strongInductionOn {p : Multiset \u03b1 \u2192 Prop} (s : Multiset \u03b1) (h\u2080 : p 0)\n(h\u2081 : \u2200 a s, (\u2200 t \u2264 s, p t) \u2192 p (a ::\u2098 s)) : p s :=", "model_response": "lemma multiset_strong_induction_on_cons:\nassumes \"p 0\" and \"\\<And>a s. (\\<And>t. t \u2264 s \\<Longrightarrow> p t) \\<Longrightarrow> p (a ::\u2098 s)\" and \"s \u2260 {#}\"\nshows \"p s\""}
{"gold_output": "theorem ppred_to_nat : \u2200 n : Num, (\u2191) <$> ppred n = Nat.ppred n", "model_response": "lemma to_nat_ppred[simp]:\nshows \"to_nat (ppred n) = Nat.ppred n\""}
{"gold_output": "theorem ceil_add_nat (ha : 0 \u2264 a) (n : \u2115) : \u2308a + n\u2309\u208a = \u2308a\u2309\u208a + n :=", "model_response": "lemma ceil_add_nat (ha : 0 \u2264 a) (n : \u2115) : \u2308a + n\u2309\u208a = \u2308a\u2309\u208a + n :="}
{"gold_output": "theorem _root_.Polynomial.coeff_eq_esymm_roots_of_card [IsDomain R] {p : R[X]}\n(hroots : Multiset.card p.roots = p.natDegree) {k : \u2115} (h : k \u2264 p.natDegree) :\np.coeff k = p.leadingCoeff * (-1) ^ (p.natDegree - k) * p.roots.esymm (p.natDegree - k) :=", "model_response": "lemma degree_erase_eq_degree [simp]: \"degree (p.erase a) = degree p\""}
{"gold_output": "theorem coe_id : \u21d1(AlgHom.id R A) = id :=", "model_response": "lemma coe_algHom_id [simp]: \"\u21d1(AlgHom.id R A) = id\""}
{"gold_output": "theorem mem_of_mem_filter {a : \u03b1} {l} (h : a \u2208 filter p l) : a \u2208 l :=", "model_response": "lemma filter_append_right :\nassumes \"a \\<in> (filter p l\u2081) ++ (filter p l\u2082)\"\nshows \"a \\<in> filter p l\u2081\""}
{"gold_output": "theorem expand_bind\u2081 (p : \u2115) (f : \u03c3 \u2192 MvPolynomial \u03c4 R) (\u03c6 : MvPolynomial \u03c3 R) :\nexpand p (bind\u2081 f \u03c6) = bind\u2081 (fun i \u21a6 expand p (f i)) \u03c6 :=", "model_response": "lemma expand_injective: \"injective (expand p)\""}
{"gold_output": "theorem prod_Ico_eq_prod_range (f : \u2115 \u2192 \u03b2) (m n : \u2115) :\n(\u220f k in Ico m n, f k) = \u220f k in range (n - m), f (m + k) :=", "model_response": "lemma inj_on_of_nat_Ico: \"inj_on of_nat (Ico n)\""}
{"gold_output": "theorem range_incl : N.incl.range = N :=", "model_response": "lemma incl_range : \"range (incl R N) = N\""}
{"gold_output": "theorem single_ne_zero (h : r \u2260 0) : single a r \u2260 0 :=", "model_response": "lemma single_ne_zero [simp]: \"single a r \u2260 0\" (is \"?f \u2260 0\") if \"r \u2260 0\""}
{"gold_output": "theorem mono_of_stalk_mono {F G : Sheaf C X} (f : F \u27f6 G) [\u2200 x, Mono <| (stalkFunctor C x).map f.1] :\nMono f :=", "model_response": "lemma stalkFunctor_comp_stalkFunctor:\n\"stalkFunctor C x \u22d9 stalkFunctor C y = stalkFunctor C (x + y)\""}
{"gold_output": "theorem hom_coe_pow {F : Type _} [Monoid F] (c : F \u2192 M \u2192 M) (h1 : c 1 = id)\n(hmul : \u2200 f g, c (f * g) = c f \u2218 c g) (f : F) : \u2200 n, c (f ^ n) = c f^[n]", "model_response": "lemma injective_c_iff: \"injective (c f) = injective c\""}
{"gold_output": "theorem le_comap_of_map_le {T : L.Substructure N} {f : M \u2192[L] N} : S.map f \u2264 T \u2192 S \u2264 T.comap f :=", "model_response": "lemma injOn_iff_ker_restrict_eq_bot :\n\"injOn f S \\<longleftrightarrow> ker (restrict f S) = bot\""}
{"gold_output": "theorem det_zero (_ : Nonempty n) : det (0 : Matrix n n R) = 0 :=", "model_response": "lemma det_zero [simp]: \"det (0 : Matrix n n R) = 0\""}
{"gold_output": "theorem map_eq_range_iff {f : G \u2192* N} {H : Subgroup G} : H.map f = f.range \u2194 Codisjoint H f.ker :=", "model_response": "theorem map_inf (f : G \u2192* N) (H\u2081 H\u2082 : Subgroup G) : (H\u2081 \u2293 H\u2082).map f = H\u2081.map f \u2293 H\u2082.map f :="}
{"gold_output": "theorem mul_div_assoc (x : R) {y z : R} (h : z \u2223 y) : x * y / z = x * (y / z) :=", "model_response": "lemma to_fract_of_fract (x : R) : to_fract (of_fract x) = x :="}
{"gold_output": "theorem natPred_eq_pred {n : \u2115} (h : 0 < n) : natPred (\u27e8n, h\u27e9 : \u2115+) = n.pred :=", "model_response": "theorem pred_coe (n : \u2115) (h : 0 < n) : (natPred \u27e8n, h\u27e9 : \u2115) = n.pred :="}
{"gold_output": "theorem loop_eq {v : V} (p : G.Path v v) : p = Path.nil :=", "model_response": "lemma edges_subset : \"edges_of_walk p \\<subseteq> edges G\""}
{"gold_output": "theorem tendsto_congr' {f\u2081 f\u2082 : \u03b1 \u2192 \u03b2} {l\u2081 : Filter \u03b1} {l\u2082 : Filter \u03b2} (hl : f\u2081 =\u1da0[l\u2081] f\u2082) :\nTendsto f\u2081 l\u2081 l\u2082 \u2194 Tendsto f\u2082 l\u2081 l\u2082 :=", "model_response": "lemma of_nat_eventually_eq_atTop: \"of_nat =\u1da0[atTop] of_nat\""}
{"gold_output": "theorem Coprime.pow {m n : \u2115+} (k l : \u2115) (h : m.Coprime n) : (m ^ k).coprime (n ^ l) :=", "model_response": "lemma coprime_pow_pow:\nfixes a b :: nat\nassumes \"coprime a b\"\nshows \"coprime (a * a ^ k) (b * b ^ l)\""}
{"gold_output": "theorem pow_le_pow_iff (h : 1 < a) : a ^ n \u2264 a ^ m \u2194 n \u2264 m :=", "model_response": "lemma toNat_strictMono[simp, intro]: \"StrictMono toNat\""}
{"gold_output": "theorem le_himp_comm : a \u2264 b \u21e8 c \u2194 b \u2264 a \u21e8 c :=", "model_response": "lemma le_himp_comm:\nassumes \"a \\<le> b\"\nshows \"b \\<le> a \\<longrightarrow>\\<^sub>A c \\<longleftrightarrow> a \\<le> b \\<longrightarrow>\\<^sub>A c\""}
{"gold_output": "theorem zero_of_source_iso_zero {X Y : C} (f : X \u27f6 Y) (i : X \u2245 0) : f = 0 :=", "model_response": "lemma zeroIso_inv_comp (f : X \u27f6 Y) : (0 : X \u2245 0).inv \u226b f = 0 :="}
{"gold_output": "theorem isOpen_lt_prod : IsOpen { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 } :=", "model_response": "lemma open_lt_prod : \"IsOpen { p : \u03b1 \u00d7 \u03b1 | p.1 < p.2 }\""}
{"gold_output": "theorem minimum_not_lt_of_mem : a \u2208 l \u2192 (minimum l : WithTop \u03b1) = m \u2192 \u00aca < m :=", "model_response": "lemma minimum_cons : \"minimum (x#l) = min x (minimum l)\""}
{"gold_output": "theorem homCongr_comp {X Y Z X\u2081 Y\u2081 Z\u2081 : C} (\u03b1 : X \u2245 X\u2081) (\u03b2 : Y \u2245 Y\u2081) (\u03b3 : Z \u2245 Z\u2081) (f : X \u27f6 Y)\n(g : Y \u27f6 Z) : \u03b1.homCongr \u03b3 (f \u226b g) = \u03b1.homCongr \u03b2 f \u226b \u03b2.homCongr \u03b3 g :=", "model_response": "lemma homCongr_inv_comp_iff:\n\"\u03b1.inv \u226b \u03b2.hom = \u03b2.inv \u226b \u03b3.hom \u2194 \u03b1.hom \u226b \u03b2.inv = \u03b3.hom \u226b \u03b3.inv\""}
{"gold_output": "theorem cycleOf_formPerm (hl : Nodup l) (hn : 2 \u2264 l.length) (x) :\ncycleOf l.attach.formPerm x = l.attach.formPerm :=", "model_response": "lemma support_formPerm (hl : Nodup l) (hn : 2 \u2264 l.length) :\nsupport (formPerm l) = set l :="}
{"gold_output": "theorem IsOfFinOrder.of_mem_zpowers (h : IsOfFinOrder x) (h' : y \u2208 Subgroup.zpowers x) :\nIsOfFinOrder y :=", "model_response": "lemma finite_order_subgroup [simp]:\n\"finite {g \\<in> Subgroup.zpowers x. g ^ n = 1}\""}
{"gold_output": "theorem map_map\u2082_antidistrib_right {n : \u03b3 \u2192 \u03b4} {m' : \u03b2 \u2192 \u03b1' \u2192 \u03b4} {n' : \u03b1 \u2192 \u03b1'}\n(h_antidistrib : \u2200 a b, n (m a b) = m' b (n' a)) : (map\u2082 m f g).map n = map\u2082 m' g (f.map n') :=", "model_response": "lemma map\u2082_map_dual_comm: \"map_dual \\<circ> map\u2082 m = map\u2082 m' \\<circ> map_dual\""}
{"gold_output": "theorem image_sigmaMk_subset_sigma_left {a : \u2200 i, \u03b1 i} (ha : \u2200 i, a i \u2208 t i) :\n(fun i \u21a6 Sigma.mk i (a i)) '' s \u2286 s.Sigma t :=", "model_response": "lemma image_sigmaMk_subset_sigma_left: \"(\\<lambda>i. Sigma.mk i (a i)) ` s \u2286 s.Sigma t\""}
{"gold_output": "theorem isBigOWith_id (l : Filter E) : IsBigOWith \u2016f\u2016 l f fun x => x :=", "model_response": "lemma isBigOWith_norm1: \"isBigOWith \u2016f\u2016 l f (\\<lambda>x. 1)\""}
{"gold_output": "theorem reindexAlgEquiv_symm (e : m \u2243 n) : (reindexAlgEquiv R e).symm = reindexAlgEquiv R e.symm :=", "model_response": "lemma reindexAlgEquiv_symm_apply (A : Matrix m n R) :\n(reindexAlgEquiv R e).symm A = reindexAlgEquiv R e.symm A :="}
{"gold_output": "theorem aemeasurable_of_subsingleton_codomain [Subsingleton \u03b2] : AEMeasurable f \u03bc :=", "model_response": "lemma aemeasurable_one [simp, intro!]: \"AEMeasurable (1 : \u03b1 \u2192 \u03b2) \u03bc\""}
{"gold_output": "theorem Filter.Tendsto.subseq_mem_entourage {V : \u2115 \u2192 Set (\u03b1 \u00d7 \u03b1)} (hV : \u2200 n, V n \u2208 \ud835\udce4 \u03b1) {u : \u2115 \u2192 \u03b1}\n{a : \u03b1} (hu : Tendsto u atTop (\ud835\udcdd a)) : \u2203 \u03c6 : \u2115 \u2192 \u2115, StrictMono \u03c6 \u2227 (u (\u03c6 0), a) \u2208 V 0 \u2227\n\u2200 n, (u <| \u03c6 (n + 1), u <| \u03c6 n) \u2208 V (n + 1) :=", "model_response": "lemma uniformContinuous_of_nat: \"uniformContinuous of_nat\""}
{"gold_output": "theorem R.sound (m n : \u2115) (x y : K) (H : (frobenius K p^[m]) x = y) :\nmk K p (n, x) = mk K p (m + n, y) :=", "model_response": "lemma mk_surj : \"surj (mk K p)\""}
{"gold_output": "theorem ODE_solution_unique {v : \u211d \u2192 E \u2192 E} {K : \u211d\u22650} (hv : \u2200 t, LipschitzWith K (v t))\n{f g : \u211d \u2192 E} {a b : \u211d} (hf : ContinuousOn f (Icc a b))\n(hf' : \u2200 t \u2208 Ico a b, HasDerivWithinAt f (v t (f t)) (Ici t) t) (hg : ContinuousOn g (Icc a b))\n(hg' : \u2200 t \u2208 Ico a b, HasDerivWithinAt g (v t (g t)) (Ici t) t) (ha : f a = g a) :\n\u2200 t \u2208 Icc a b, f t = g t :=", "model_response": "lemma continuous_on_Icc_iff_Ioo:\n\"continuous_on (Icc a b) f \\<longleftrightarrow> continuous_on (Ioo a b) f\""}
{"gold_output": "theorem IsGLB.exists_between_self_add (h : IsGLB s a) (h\u03b5 : 0 < \u03b5) : \u2203 b \u2208 s, a \u2264 b \u2227 b < a + \u03b5 :=", "model_response": "lemma Iio_eq_Iic' (h : IsGLB s a) (h\u03b5 : 0 < \u03b5) : { x \u2208 s | x < a + \u03b5 } = { x \u2208 s | x \u2264 a } :="}
{"gold_output": "theorem ofDual_himp (a b : \u03b1\u1d52\u1d48) : ofDual (a \u21e8 b) = ofDual b \\ ofDual a :=", "model_response": "lemma ofDual_inf [simp]:\n\"ofDual (a \u2293 b) = ofDual a \u2294 ofDual b\""}
{"gold_output": "theorem orderOf_r_one : orderOf (r 1 : DihedralGroup n) = n :=", "model_response": "theorem orderOf_r_one [simp]: \"orderOf (r 1 : DihedralGroup n) = n\""}
{"gold_output": "theorem le_of_add_le_add_left [ContravariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (ha : a \u2260 \u22a5)\n(h : a + b \u2264 a + c) : b \u2264 c :=", "model_response": "lemma toDual_strictMono:\n\"StrictMono toDual\""}
{"gold_output": "theorem mem_closedBall_comm : x \u2208 closedBall y \u03b5 \u2194 y \u2208 closedBall x \u03b5 :=", "model_response": "lemma isometry_to_conjugate_space[simp]: \\<open>isometry to_conjugate_space\\<close>"}
{"gold_output": "theorem norm_integral_lt_of_norm_le_const_of_lt {f : \u2102 \u2192 E} {c : \u2102} {R C : \u211d} (hR : 0 < R)\n(hc : ContinuousOn f (sphere c R)) (hf : \u2200 z \u2208 sphere c R, \u2016f z\u2016 \u2264 C)\n(hlt : \u2203 z \u2208 sphere c R, \u2016f z\u2016 < C) : \u2016\u222e z in C(c, R), f z\u2016 < 2 * \u03c0 * R * C :=", "model_response": "lemma norm_integral_le_of_norm_le_const {f : \u2102 \u2192 E} {c : \u2102} {R C : \u211d} (hR : 0 < R)\n(hc : ContinuousOn f (sphere c R)) (hf : \u2200 z \u2208 sphere c R, \u2016f z\u2016 \u2264 C)\n(hlt : \u2203 z \u2208 sphere c R, \u2016f z\u2016 < C) : \u2016\u222e z in C(c, R), f z\u2016 \u2264 2 * \u03c0 * R * C :="}
{"gold_output": "theorem sInf_isPrime_of_isChain {s : Set (Ideal \u03b1)} (hs : s.Nonempty) (hs' : IsChain (\u00b7 \u2264 \u00b7) s)\n(H : \u2200 p \u2208 s, Ideal.IsPrime p) : (sInf s).IsPrime :=", "model_response": "lemma isPrime_sInf_iff:\n\"IsPrime (sInf s) \\<longleftrightarrow> s = {bot} \\<or> s = {top}\""}
{"gold_output": "theorem cardinal_mk_le_mul : (#{ x : A // IsAlgebraic R x }) \u2264 (#R[X]) * \u2135\u2080 :=", "model_response": "lemma cardinal_mk_le_max :\n\"(#{ x : A // IsAlgebraic R x }) \\<le> max (#R[X]) \u2135\u2080\""}
{"gold_output": "theorem comp_assoc (f : sSupHom \u03b3 \u03b4) (g : sSupHom \u03b2 \u03b3) (h : sSupHom \u03b1 \u03b2) :\n(f.comp g).comp h = f.comp (g.comp h) :=", "model_response": "lemma comp_id_assoc (f : sSupHom \u03b3 \u03b4) (g : sSupHom \u03b2 \u03b3) (h : sSupHom \u03b1 \u03b2) :\n(sSupHom.id \u03b4).comp f . comp (sSupHom.id \u03b3).comp g . comp (sSupHom.id \u03b2).comp h =\n(sSupHom.id \u03b1).comp (f.comp (g.comp h)) :="}
{"gold_output": "theorem add_apply {s t : SummableFamily \u0393 R \u03b1} {a : \u03b1} : (s + t) a = s a + t a :=", "model_response": "lemma sum_eq_sum_iff : \"s.sum f = t.sum f \\<longleftrightarrow> s = t\""}
{"gold_output": "theorem map_id (S : L.Substructure M) : S.map (Hom.id L M) = S :=", "model_response": "lemma comp_id_left : \"Hom.id M N \\<circ> S = Hom.id (M.comp N) S\""}
{"gold_output": "theorem inv_mul (\u03c7 : MulChar R R') : \u03c7\u207b\u00b9 * \u03c7 = 1 :=", "model_response": "lemma inv_char_principal (a : R) : (char_principal R' a)\u207b\u00b9 = char_principal R a :="}
{"gold_output": "theorem finset_sum_eq_sup_iff_disjoint {\u03b2 : Type _} {i : Finset \u03b2} {f : \u03b2 \u2192 Multiset \u03b1} :\ni.sum f = i.sup f \u2194\n\u2200 (x) (_ : x \u2208 i) (y) (_ : y \u2208 i), x \u2260 y \u2192 Multiset.Disjoint (f x) (f y) :=", "model_response": "lemma sum_eq_sup_iff_disjoint :\n\"s.sum f = s.sup f\" if \"\\<And>x _ y _. x \\<in> s \\<Longrightarrow> y \\<in> s \\<Longrightarrow> x \\<noteq> y \\<Longrightarrow> Multiset.Disjoint (f x) (f y)\""}
{"gold_output": "theorem Ico_ae_eq_Ioc' (ha : \u03bc {a} = 0) (hb : \u03bc {b} = 0) : Ico a b =\u1d50[\u03bc] Ioc a b :=", "model_response": "lemma measure_Icc_eq_measure_Ioo' (ha : \u03bc {a} = 0) (hb : \u03bc {b} = 0) :\nIcc a b =\u1d50[\u03bc] Ioo a b :="}
{"gold_output": "theorem prod_mapDomain_index_inj [CommMonoid N] {f : \u03b1 \u2192 \u03b2} {s : \u03b1 \u2192\u2080 M} {h : \u03b2 \u2192 M \u2192 N}\n(hf : Function.Injective f) : (s.mapDomain f).prod h = s.prod fun a b => h (f a) b :=", "model_response": "lemma mapDomain_eq_prod_map_index :\n\"mapDomain f s = Finsupp.prod s (\\<lambda>a b. h (f a) b)\""}
{"gold_output": "theorem frontier_setOf_le_re (a : \u211d) : frontier { z : \u2102 | a \u2264 z.re } = { z | z.re = a } :=", "model_response": "lemma frontier_setOf_le_re (a : \u211d) :\n\"frontier { z : \u2102 | a \\<le> z.re } = {Complex.mk a (-sqrt (a * a - 1))}\""}
{"gold_output": "theorem toList_comp (p : Path a b) : \u2200 {c} (q : Path b c), (p.comp q).toList = q.toList ++ p.toList", "model_response": "lemma toList_append (p : Path a b) : \u2200 {c} (q : Path b c), (p @ q).toList = q.toList ++ p.toList"}
{"gold_output": "theorem div_pf {R} [DivisionRing R] {a b c d : R}\n(_ : b\u207b\u00b9 = c) (_ : a * c = d) : a / b = d :=", "model_response": "lemma div_eq_of_inv_mul_eq:\nfixes a b c d :: R\nassumes eq: \"b\u207b\u00b9 = c\" and amc: \"a * c = d\"\nshows \"a / b = d\""}
{"gold_output": "theorem norm_fourierIntegral_le_integral_norm (e : Multiplicative \ud835\udd5c \u2192* \ud835\udd4a) (\u03bc : Measure V)\n(L : V \u2192\u2097[\ud835\udd5c] W \u2192\u2097[\ud835\udd5c] \ud835\udd5c) (f : V \u2192 E) (w : W) :\n\u2016fourierIntegral e \u03bc L f w\u2016 \u2264 \u222b v : V, \u2016f v\u2016 \u2202\u03bc :=", "model_response": "lemma norm_fourierIntegral_le_integral_norm :\n\"norm (fourierIntegral e \u03bc L f w) \\<le> (\u222b v : V, norm (f v) \u2202\u03bc)\""}
{"gold_output": "theorem StrictMono.imp (hf : StrictMono f) (h : a < b) : f a < f b :=", "model_response": "lemma strict_mono: \"strict_mono f\""}
{"gold_output": "theorem Subpresheaf.family_of_elements_compatible {U : C\u1d52\u1d56} (s : F.obj U) :\n(G.familyOfElementsOfSection s).Compatible :=", "model_response": "lemma yoneda_map_comp_yoneda_embedding (A : C) (f : A \u27f6 A) :\n(yoneda.map f).op \u226b yoneda.embedding A = (yoneda.map f.op).op :="}
{"gold_output": "theorem iInf_sup_iInf {\u03b9 \u03b9' : Type _} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} :\n((\u2a05 i, f i) \u2294 \u2a05 i, g i) = \u2a05 i : \u03b9 \u00d7 \u03b9', f i.1 \u2294 g i.2 :=", "model_response": "lemma Sup_le_eq [simp]:\n\"(SUP a | a \\<le> b. a) = b\""}
{"gold_output": "theorem iterate_pos_eq_iff_map_eq (h : Commute f g) (hf : Monotone f) (hg : StrictMono g) {x n}\n(hn : 0 < n) : (f^[n]) x = (g^[n]) x \u2194 f x = g x :=", "model_response": "lemma of_nat_eq:\n\"of_nat n = (if 0 < n then f ((of_nat (n - 1)) else 0))\""}
{"gold_output": "theorem mk_inj (A B : T) {f g : A \u27f6 B} : Arrow.mk f = Arrow.mk g \u2194 f = g :=", "model_response": "lemma to_from_structured_arrow:\n\"toStructuredArrow \\<circ> fromStructuredArrow P = P\""}
{"gold_output": "theorem iSup_inf_iSup {\u03b9 \u03b9' : Type _} {f : \u03b9 \u2192 \u03b1} {g : \u03b9' \u2192 \u03b1} :\n((\u2a06 i, f i) \u2293 \u2a06 j, g j) = \u2a06 i : \u03b9 \u00d7 \u03b9', f i.1 \u2293 g i.2 :=", "model_response": "lemma iSup_inf_iSup_prod_eq {\u03b9 \u03b9' : Type _} (f : \u03b9 \u2192 \u03b1) (g : \u03b9' \u2192 \u03b1) :\n(\u2a06 i, f i) \u2293 \u2a06 j, g j = \u2a06 x : \u03b9 \u00d7 \u03b9', f x.1 \u2293 g x.2 :="}
{"gold_output": "theorem bot_eq_zero : (\u22a5 : \u211d\u22650\u221e) = 0 :=", "model_response": "lemma bot_ne_coe : \u22a5 \u2260 (r : \u211d\u22650\u221e) :="}
{"gold_output": "theorem N_one (B : GroupFilterBasis G) : B.N 1 = B.toFilterBasis.filter :=", "model_response": "lemma nhds_one_eq_toFilterBasis (B : GroupFilterBasis G) :\n@nhds G B.topology (1 : G) = B.toFilterBasis.filter :="}
{"gold_output": "theorem map_map\u2082_antidistrib {n : \u03b3 \u2192 \u03b4} {m' : \u03b2' \u2192 \u03b1' \u2192 \u03b4} {n\u2081 : \u03b2 \u2192 \u03b2'} {n\u2082 : \u03b1 \u2192 \u03b1'}\n(h_antidistrib : \u2200 a b, n (m a b) = m' (n\u2081 b) (n\u2082 a)) :\n(map\u2082 m f g).map n = map\u2082 m' (g.map n\u2081) (f.map n\u2082) :=", "model_response": "lemma map_dual_map\u2082_comm: \"map_dual \\<circ> map\u2082 m f g = map\u2082 m (toDual \\<circ> f) (toDual \\<circ> g)\""}
{"gold_output": "theorem symm_trans_source_eq (e e' : Trivialization F proj) :\n(e.toLocalEquiv.symm.trans e'.toLocalEquiv).source = (e.baseSet \u2229 e'.baseSet) \u00d7\u02e2 univ :=", "model_response": "lemma symm_trans_source_eq:\n\"(e.toLocalEquiv.symm.trans e'.toLocalEquiv).source = (e.baseSet \\<inter> e'.baseSet) \\<times> univ\""}
{"gold_output": "theorem nthLe_take (L : List \u03b1) {i j : \u2115} (hi : i < L.length) (hj : i < j) :\nnthLe L i hi = nthLe (L.take j) i (length_take .. \u25b8 lt_min hj hi) :=", "model_response": "lemma nthLe_take_eq_nthLe:\nassumes \"i < L.length\" and \"i < j\"\nshows \"nthLe (L.take j) i (length_take .. \u25b8 lt_min hj hi) = nthLe L i hi\""}
{"gold_output": "theorem directedOn_univ_iff : DirectedOn r Set.univ \u2194 IsDirected \u03b1 r :=", "model_response": "lemma toIcoMod_eventually_eq: \"toIcoMod hp a =\u1da0[\ud835\udcdd a] toIcoMod hp b\""}
{"gold_output": "theorem hasSum_div_const_iff (h : a\u2082 \u2260 0) : HasSum (fun i => f i / a\u2082) (a\u2081 / a\u2082) \u2194 HasSum f a\u2081 :=", "model_response": "lemma tendsto_inverse_zero_atTop_iff_inverse_tendsto_infinity :\n\"filterlim (\\<lambda>x. inverse (f x)) (\ud835\udcdd 0) atTop  \\<longleftrightarrow> filterlim (\\<lambda>x. inverse (f x)) atTop atTop\""}
{"gold_output": "theorem complex_d_succ_comp {Z : C} (P : ProjectiveResolution Z) (n : \u2115) :\nP.complex.d (n + 2) (n + 1) \u226b P.complex.d (n + 1) n = 0 :=", "model_response": "lemma complex_d_comp (n : \u2115) :\nP.complex.d (n + 2) (n + 1) \u226b P.complex.d (n + 1) n = 0 :="}
{"gold_output": "theorem xgcd_aux_val (x y) : xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y) :=", "model_response": "lemma xgcd_aux_val: \"xgcdAux x 1 0 y 0 1 = (gcd x y, xgcd x y)\""}
{"gold_output": "theorem symm_trans_target_eq (e e' : Trivialization F proj) :\n(e.toLocalEquiv.symm.trans e'.toLocalEquiv).target = (e.baseSet \u2229 e'.baseSet) \u00d7\u02e2 univ :=", "model_response": "lemma symm_toLocalEquiv: \"e.toLocalEquiv.symm = e.symm.toLocalEquiv\""}
{"gold_output": "theorem to_localInverse (hf : HasStrictFDerivAt f (f' : E \u2192L[\ud835\udd5c] F) a) :\nHasStrictFDerivAt (hf.localInverse f f' a) (f'.symm : F \u2192L[\ud835\udd5c] E) (f a) :=", "model_response": "lemma differentiableWithinAt_iff_hasStrictFDerivAt:\n\"DifferentiableWithinAt \ud835\udd5c f s a \u2194 HasStrictFDerivAt f (f' : E \u2192L[\ud835\udd5c] F) a\""}
{"gold_output": "theorem iSup_le (h : \u2200 i, f i \u2264 a) : iSup f \u2264 a :=", "model_response": "lemma of_nat_eq: \"of_nat n = of n 1\""}
{"gold_output": "theorem mul_cpow_ofReal_nonneg {a b : \u211d} (ha : 0 \u2264 a) (hb : 0 \u2264 b) (r : \u2102) :\n((a : \u2102) * (b : \u2102)) ^ r = (a : \u2102) ^ r * (b : \u2102) ^ r :=", "model_response": "lemma cnj_divide [simp]: \"cnj (a / b) = cnj a / cnj b\"\nif \"0 \\<le> a\" \"0 \\<le> b\""}
{"gold_output": "theorem compl\u2081\u2082_apply (f : M\u2097 \u2192\u2097[R] N\u2097 \u2192\u2097[R] P\u2097) (g : Q\u2097 \u2192\u2097[R] M\u2097) (g' : Q\u2097' \u2192\u2097[R] N\u2097) (x : Q\u2097)\n(y : Q\u2097') : f.compl\u2081\u2082 g g' x y = f (g x) (g' y) :=", "model_response": "lemma compl\u2081\u2082_linear_linear_linear_map :\n\"(f.linear.compl\u2081\u2082 g g').linear = (f.linear.compl\u2081 g).compl\u2082 (f.linear.compl\u2081 g')\""}
{"gold_output": "theorem mem_toCotangent_ker {x : I} : x \u2208 LinearMap.ker I.toCotangent \u2194 (x : R) \u2208 I ^ 2 :=", "model_response": "lemma ideal_sq_eq_bot_iff : \"I ^ 2 = \u22a5  \\<longleftrightarrow> I = \u22a5 \\<or> I = \u22a4\""}
{"gold_output": "theorem Multiset.map_toEnumFinset_fst (m : Multiset \u03b1) : m.toEnumFinset.val.map Prod.fst = m :=", "model_response": "lemma inj_on_iff_subsingleton_image: \"inj_on f s \\<longleftrightarrow> (subsingleton (f '' s))\""}
{"gold_output": "theorem ext {v\u2081 v\u2082 : AddValuation R \u0393\u2080} (h : \u2200 r, v\u2081 r = v\u2082 r) : v\u2081 = v\u2082 :=", "model_response": "lemma valuate_zero [simp]: \"v 0 = 0\""}
{"gold_output": "theorem inv_mem_iff {S G} [InvolutiveInv G] {_ : SetLike S G} [InvMemClass S G] {H : S}\n{x : G} : x\u207b\u00b9 \u2208 H \u2194 x \u2208 H :=", "model_response": "lemma coe_inv [simp]: \"((H : Set G)\u207b\u00b9 : Set G) = H\u207b\u00b9\""}
{"gold_output": "theorem DifferentiableAt.fst (h : DifferentiableAt \ud835\udd5c f\u2082 x) :\nDifferentiableAt \ud835\udd5c (fun x => (f\u2082 x).1) x :=", "model_response": "lemma fst_differentiableAt : \"DifferentiableAt \ud835\udd5c (fun x => (f\u2082 x).1) x\""}
{"gold_output": "theorem coeFn_pair (f : \u03b1 \u2192\u2098[\u03bc] \u03b2) (g : \u03b1 \u2192\u2098[\u03bc] \u03b3) : f.pair g =\u1d50[\u03bc] fun x => (f x, g x) :=", "model_response": "lemma measurable_pair' [measurable]: \"pair f g \\<in> measurable (\u03bc.prod \u03bd) (\u03bc.prod \u03bd')\""}
{"gold_output": "theorem Mem\u2112p.snorm_lt_top {f : \u03b1 \u2192 E} (hfp : Mem\u2112p f p \u03bc) : snorm f p \u03bc < \u221e :=", "model_response": "lemma norm_indicator_le_measure_smul {f : \u03b1 \u2192 E} (hfp : Mem\u2112p f p \u03bc) (x : \u03b1) :\n\u2016indicator s f x\u2016 \u2264 \u03bc s * \u2016f x\u2016 :="}
{"gold_output": "theorem complete_univ {\u03b1 : Type u} [UniformSpace \u03b1] [CompleteSpace \u03b1] :\nIsComplete (univ : Set \u03b1) :=", "model_response": "lemma atMost_self : {a..a} = {a} :="}
{"gold_output": "theorem le_iterate_comp_of_le (hf : Monotone f) (H : h \u2218 g \u2264 f \u2218 h) (n : \u2115) :\nh \u2218 g^[n] \u2264 f^[n] \u2218 h :=", "model_response": "theorem le_iterate_comp_of_le (hf : Monotone f) (H : h \u2218 g \u2264 f \u2218 h) (n : \u2115) :\nh \u2218 g^[n] \u2264 f^[n] \u2218 h :="}
{"gold_output": "theorem isOrtho_def {B : BilinForm R M} {x y : M} : B.IsOrtho x y \u2194 B x y = 0 :=", "model_response": "lemma ofRealAm_apply[simp]: \"ofRealAm = (\\<lambda>x. ofReal x)\""}
{"gold_output": "theorem Prime.dvd_factorial : \u2200 {n p : \u2115} (_ : Prime p), p \u2223 n ! \u2194 p \u2264 n", "model_response": "lemma factorial_eq_prod_range' :\n\"n ! = (\u220f x in range (n + 1), f x)\""}
{"gold_output": "theorem iSup_option (f : Option \u03b2 \u2192 \u03b1) : (\u2a06 o, f o) = f none \u2294 \u2a06 b, f (Option.some b) :=", "model_response": "lemma iSup_set_option [simp]:\n\"(\u2a06 x \u2208 s, f x) = f none \u2294 \u2a06 b \u2208 s, f (some b)\""}
{"gold_output": "theorem span_singleton_mul_left_inj [IsDomain R] {x : R} (hx : x \u2260 0) :\nI * span {x} = J * span {x} \u2194 I = J :=", "model_response": "lemma span_singleton_mul_left_eq_span_insert_mul_span_singleton [simp]:\n\"ideal S * span {x} = ideal (insert x S) * span {x}\""}
{"gold_output": "theorem smul_div' (r : M) (x y : A) : r \u2022 (x / y) = r \u2022 x / r \u2022 y :=", "model_response": "lemma smul_sub' : \"r \u2022 (x - y) = r \u2022 x - r \u2022 y\""}
{"gold_output": "theorem Dart.edge_mk {p : V \u00d7 V} (h : G.Adj p.1 p.2) : (Dart.mk p h).edge = \u27e6p\u27e7 :=", "model_response": "lemma Dart.edge_mk'_symm (p : V \u00d7 V) (h : G.Adj p.1 p.2) :\n(Dart.mk' p h).edge = \u27e6p\u27e7 :="}
{"gold_output": "theorem Blunt.salient {S : ConvexCone \ud835\udd5c E} : S.Blunt \u2192 S.Salient :=", "model_response": "lemma extreme_points_of_subset: \"extreme_points_of \ud835\udd5c A \\<subseteq> A\""}
{"gold_output": "theorem eqLocus_same (f : R \u2192+* S) : f.eqLocus f = \u22a4 :=", "model_response": "lemma injOn_source_iff : \"injOn f (source f) = inj f\""}
{"gold_output": "theorem sdiff_insert_of_not_mem {x : \u03b1} (h : x \u2209 s) (t : Finset \u03b1) : s \\ insert x t = s \\ t :=", "model_response": "lemma set_comprehension_split:\n\"{a : \u03b1 | P a} = {a \u2208 s | P a} \u222a {a : \u03b1 | a \u2209 s \u2227 P a}\""}
{"gold_output": "theorem IsBot.prod_mk (ha : IsBot a) (hb : IsBot b) : IsBot (a, b) :=", "model_response": "lemma is_bot_prod [simp]:\nassumes \"is_bot a\"\nand \"is_bot b\"\nshows \"is_bot (a, b)\""}
{"gold_output": "theorem Ideal.IsHomogeneous.mul {I J : Ideal A} (HI : I.IsHomogeneous \ud835\udc9c) (HJ : J.IsHomogeneous \ud835\udc9c) :\n(I * J).IsHomogeneous \ud835\udc9c :=", "model_response": "lemma Ideal.homogeneousCore_eq_ideal_span_homogeneousCore (I : Ideal A) :\nIdeal.Quotient.mk I.homogeneousCore \ud835\udc9c = I.homogeneousCore \ud835\udc9c :="}
{"gold_output": "theorem isSimpleModule_iff_isCoatom : IsSimpleModule R (M \u29f8 m) \u2194 IsCoatom m :=", "model_response": "lemma quotient_eq_coatom_set: \"{ x \\<in> carrier M. x \\<in> m } = m\""}
{"gold_output": "theorem matrix_eq_sum_std_basis [Fintype m] [Fintype n] (x : Matrix m n \u03b1) :\nx = \u2211 i : m, \u2211 j : n, stdBasisMatrix i j (x i j) :=", "model_response": "lemma sum_std_basis_matrix_eq_diagonal_matrix:\n\"(sum i (sum j (std_basis_matrix i j (x i j)))) = diagonal_matrix (\\<lambda>i. x i i)\""}
{"gold_output": "theorem total_equivMapDomain (f : \u03b1 \u2243 \u03b1') (l : \u03b1 \u2192\u2080 R) :\n(Finsupp.total \u03b1' M' R v') (equivMapDomain f l) = (Finsupp.total \u03b1 M' R (v' \u2218 f)) l :=", "model_response": "lemma support_equivMapDomain [simp]:\n\"support (equivMapDomain f l) = f ` (support l)\""}
{"gold_output": "theorem mem_getLast?_cons {x y : \u03b1} : \u2200 {l : List \u03b1}, x \u2208 l.getLast? \u2192 x \u2208 (y :: l).getLast?", "model_response": "lemma getLast?_cons_of_mem :\nassumes \"x \\<in> l.getLast?\"\nshows \"x \\<in> (y :: l).getLast?\""}
{"gold_output": "theorem encode_list_cons (a : \u03b1) (l : List \u03b1) :\nencode (a :: l) = succ (pair (encode a) (encode l)) :=", "model_response": "lemma encode_cons' [simp]: \"encode (a :: b # list) = succ (pair (encode a) (encode (b # list)))\""}
{"gold_output": "theorem convexOn_univ_norm : ConvexOn \u211d univ (norm : E \u2192 \u211d) :=", "model_response": "lemma convexOn_norm_univ [simp]: \"convexOn \u211d univ norm\""}
{"gold_output": "theorem mkSol_eq_init (init : Fin E.order \u2192 \u03b1) : \u2200 n : Fin E.order, E.mkSol init n = init n :=", "model_response": "lemma mk_eq_init [simp]:\nassumes \"n < E.order\"\nshows \"E.mk n = init n\""}
{"gold_output": "theorem toFinsupp_monomial (n : \u2115) (r : R) : (monomial n r).toFinsupp = Finsupp.single n r :=", "model_response": "lemma toFinsupp_injective:\n\"Function.Injective toFinsupp\""}
{"gold_output": "theorem zpow_eq_zero_iff {a : G\u2080} {n : \u2124} (hn : n \u2260 0) : a ^ n = 0 \u2194 a = 0 :=", "model_response": "lemma continuousAt_ofReal: \"continuousAt ofReal x\""}
{"gold_output": "theorem AffineBasis.centroid_mem_interior_convexHull {\u03b9} [Fintype \u03b9] (b : AffineBasis \u03b9 \u211d V) :\nFinset.univ.centroid \u211d b \u2208 interior (convexHull \u211d (range b)) :=", "model_response": "lemma centroid_univ_eq_centroid_range [simp]:\n\"centroid k univ p = centroid k (range p) p\""}
{"gold_output": "theorem coeFn_injective : @Function.Injective (Homotopy p\u2080 p\u2081) (I \u00d7 I \u2192 X) (\u21d1) :=", "model_response": "lemma coeFn_injective:\n\"Function.Injective (coeFn : (Homotopy p\u2080 p\u2081 : I \u2192 X) \u2192 I \u2192 X)\""}
{"gold_output": "theorem abs_cpow_eq_rpow_re_of_nonneg {x : \u211d} (hx : 0 \u2264 x) {y : \u2102} (hy : re y \u2260 0) :\nabs (x ^ y) = x ^ re y :=", "model_response": "lemma abs_cpow_eq_rpow (z : \u2102) (r : \u211d) : abs (z ^ r) = abs z ^ r :="}
{"gold_output": "theorem linearIndependent_equiv' (e : \u03b9 \u2243 \u03b9') {f : \u03b9' \u2192 M} {g : \u03b9 \u2192 M} (h : f \u2218 e = g) :\nLinearIndependent R g \u2194 LinearIndependent R f :=", "model_response": "lemma linearIndependent_equiv :\n\"linearIndependent R f = linearIndependent R (\\<lambda>i. f (e i))\""}
{"gold_output": "theorem Units.isUnit_units_mul {M : Type _} [Monoid M] (u : M\u02e3) (a : M) :\nIsUnit (\u2191u * a) \u2194 IsUnit a :=", "model_response": "lemma is_unit_inv_iff:\nassumes \"is_unit a\"\nshows \"is_unit (a\u207b\u00b9) \u2194 is_unit a\""}
{"gold_output": "theorem iterate_add_minimalPeriod_eq : (f^[n + minimalPeriod f x]) x = (f^[n]) x :=", "model_response": "lemma minimalPeriod_pos : \"0 < minimalPeriod f x\""}
{"gold_output": "theorem gcdA_zero_left {s : \u2115} : gcdA 0 s = 0 :=", "model_response": "lemma gcdA_0_left [simp]: \"gcdA 0 s = 0\""}
{"gold_output": "theorem exponent_eq_iSup_orderOf' :\nexponent G = if \u2203 g : G, orderOf g = 0 then 0 else \u2a06 g : G, orderOf g :=", "model_response": "theorem exponent_eq_iSup_orderOf:\n\"exponent G = (if \\<exists>g. orderOf g = 0 then 0 else \u2a06 g : G, orderOf g)\""}
{"gold_output": "theorem coe_sub : ((f - g : RatFunc F) : LaurentSeries F) = f - g :=", "model_response": "lemma coeff_sub [simp]: \"coeff (f - g : LaurentSeries F) n = coeff f n - coeff g n\""}
{"gold_output": "theorem length_splitWrtCompositionAux (l : List \u03b1) (ns) :\nlength (l.splitWrtCompositionAux ns) = ns.length :=", "model_response": "lemma length_splitWrtCompositionAux_eq_length_tails:\nassumes \"l \\<noteq> []\"\nshows \"length (l.splitWrtCompositionAux ns) = length (tails l)\""}
{"gold_output": "theorem IsTorsion.quotient_iff {f : G \u2192* H} (hf : Function.Surjective f) (hN : N = f.ker)\n(tN : IsTorsion N) : IsTorsion H \u2194 IsTorsion G :=", "model_response": "lemma subset_ker_one_lift : \"{a. a \\<in> A \\<and> f a = 1} \\<subseteq> {a. a \\<in> A \\<and> f a = 1}\""}
{"gold_output": "theorem IsGreatest.mem_maximals (h : IsGreatest s a) : a \u2208 maximals (\u00b7 \u2264 \u00b7) s :=", "model_response": "lemma maximals_eq: \"maximals (\u00b7 \u2264 \u00b7) s = {a}\""}
{"gold_output": "theorem dense_closure {s : Set \u03b1} : Dense (closure s) \u2194 Dense s :=", "model_response": "theorem closure_subset_iff_isClosed {s : Set \u03b1} : closure s \u2286 s \u2194 IsClosed s :="}
{"gold_output": "theorem mapEvalEquiv_symm_apply [FiniteDimensional K V] (W'' : Subspace K (Dual K (Dual K V))) :\n(mapEvalEquiv K V).symm W'' = W''.comap (eval K V) :=", "model_response": "lemma dualDual_eq [simp]: \"dualDual W = W\""}
{"gold_output": "theorem bounded_ge_inter_not_ge [SemilatticeInf \u03b1] (a : \u03b1) :\nBounded (\u00b7 \u2265 \u00b7) (s \u2229 { b | \u00aca \u2264 b }) \u2194 Bounded (\u00b7 \u2265 \u00b7) s :=", "model_response": "lemma bounded_ge_empty_iff [simp]:\n\"{ x \\<in> s . False } = {}\""}
{"gold_output": "theorem Int.Prime.dvd_pow' {n : \u2124} {k p : \u2115} (hp : Nat.Prime p) (h : (p : \u2124) \u2223 n ^ k) :\n(p : \u2124) \u2223 n :=", "model_response": "lemma ofNat_natAbs (n : \u2124) : ofNat (natAbs n) = n :="}
{"gold_output": "theorem ball_subset_thickening {x : X} {E : Set X} (hx : x \u2208 E) (\u03b4 : \u211d) :\nball x \u03b4 \u2286 thickening \u03b4 E :=", "model_response": "lemma thickening_subset_InfDist:\n\"{x \\<in> E. infdist x E \\<le> \\<delta>} \\<subseteq> thickening \\<delta> E\""}
{"gold_output": "theorem lt_add_of_tsub_lt_right (hc : AddLECancellable c) (h : a - c < b) :\na < b + c :=", "model_response": "lemma toIcoMod_eq_self_iff: \"toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)\""}
{"gold_output": "theorem isUpperSet_iUnion {f : \u03b9 \u2192 Set \u03b1} (hf : \u2200 i, IsUpperSet (f i)) : IsUpperSet (\u22c3 i, f i) :=", "model_response": "lemma isUpperSet_Iic [simp]: \"IsUpperSet {x. x \u2264 a}\""}
{"gold_output": "theorem one_rpow (x : \u211d) : (1 : \u211d\u22650\u221e) ^ x = 1 :=", "model_response": "lemma one_rpow_of_real [simp]:\nfixes x :: real\nshows \"(1 : \u211d\u22650\u221e) ^ x = 1\""}
{"gold_output": "theorem totallyBounded_Ico (a b : \u03b1) : TotallyBounded (Ico a b) :=", "model_response": "lemma totallyBounded_Ici : TotallyBounded (Ici a) :="}
{"gold_output": "theorem nondegenerate_iff_det_ne_zero {B : BilinForm A M\u2083} (b : Basis \u03b9 A M\u2083) :\nB.Nondegenerate \u2194 (toMatrix b B).det \u2260 0 :=", "model_response": "lemma det_flip_eq_det: \"det (toMatrix b B) = det (toMatrix b (flip B))\""}
{"gold_output": "theorem cons_val_fin_one (x : \u03b1) (u : Fin 0 \u2192 \u03b1) : \u2200 (i : Fin 1), vecCons x u i = x :=", "model_response": "lemma vecCons_injective_left [simp]: \"inj (vecCons x u)\""}
{"gold_output": "theorem natCast_le {m n : \u2115} : (m : Cardinal) \u2264 n \u2194 m \u2264 n :=", "model_response": "lemma card_fintypeIic : \"card (Set.Iic n) = n\""}
{"gold_output": "theorem continuous_prod_mk {f : \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b3} :\n(Continuous fun x => (f x, g x)) \u2194 Continuous f \u2227 Continuous g :=", "model_response": "lemma continuous_bivar_fst_iff:\n\"continuous ((\\<lambda>x. (f x, g x)) \\<circ> h) x \\<longleftrightarrow> continuous f x \\<and> continuous g x\""}
{"gold_output": "theorem cast_coe_nat (n : \u2115) : ((n : \u211a) : \u03b1) = n :=", "model_response": "lemma of_rat_to_rat (n : \u2115) : of_rat (to_rat n) = n :="}
{"gold_output": "theorem hasBasis_nhds_zero_of_basis [TopologicalSpace F] [TopologicalAddGroup F]\n{\u03b9 : Type _} {p : \u03b9 \u2192 Prop} {b : \u03b9 \u2192 Set F} (h : (\ud835\udcdd 0 : Filter F).HasBasis p b) :\n(\ud835\udcdd (0 : E \u2192SL[\u03c3] F)).HasBasis (fun Si : Set E \u00d7 \u03b9 => Bornology.IsVonNBounded \ud835\udd5c\u2081 Si.1 \u2227 p Si.2)\nfun Si => { f : E \u2192SL[\u03c3] F | \u2200 x \u2208 Si.1, f x \u2208 b Si.2 } :=", "model_response": "lemma isBoundedLinearMap_image [simp]:\n\"isBoundedLinearMap \ud835\udd5c (\\<lambda>x. f x)\""}
{"gold_output": "theorem bliminf_or_le_inf_aux_right : (bliminf u f fun x => p x \u2228 q x) \u2264 bliminf u f q :=", "model_response": "lemma bliminf_or_le_left: \"bliminf u f (\\<lambda>x. p x \\<or> q x) \\<le> bliminf u f p\""}
{"gold_output": "theorem IsChain.exists3 (hchain : IsChain r s) [IsTrans \u03b1 r] {a b c} (mem1 : a \u2208 s) (mem2 : b \u2208 s)\n(mem3 : c \u2208 s) : \u2203 (z : _) (_ : z \u2208 s), r a z \u2227 r b z \u2227 r c z :=", "model_response": "lemma chain_least_least:\nassumes \"transp_on A r\" and \"A = s \\<union> t\" and \"chain r s\" and \"t \\<noteq> {}\"\nshows \"least A = least s\""}
{"gold_output": "theorem toMatrix_apply [DecidableEq n] [Zero \u03b1] [One \u03b1] (f : m \u2243. n) (i j) :\ntoMatrix f i j = if j \u2208 f i then (1 : \u03b1) else 0 :=", "model_response": "lemma toMatrix_inj [simp]:\n\"(f : m \u2243. n) = (g : m \u2243. n) \\<Longrightarrow> toMatrix f = toMatrix g\""}
{"gold_output": "theorem conjugate {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (z * x * star z) :=", "model_response": "lemma star_mul: \"star (x * y) = star x * star y\""}
{"gold_output": "theorem zero_inv : (0 : PowerSeries k)\u207b\u00b9 = 0 :=", "model_response": "lemma X_inv : (X : PowerSeries k)\u207b\u00b9 = X\u207b\u00b9 :="}
{"gold_output": "theorem degree_C (ha : a \u2260 0) : degree (C a) = (0 : WithBot \u2115) :=", "model_response": "lemma degree_one [simp]:\n\"degree 1 = (0 : WithBot \u2115)\""}
{"gold_output": "theorem isLittleO_exp_cpow (hl : IsExpCmpFilter l) (a : \u2102) {b : \u211d} (hb : b < 0) :\n(fun z => exp (b * z)) =o[l] fun z => z ^ a :=", "model_response": "lemma isLittleO_exp_cpow (hl : IsExpCmpFilter l) (a : \u2102) {b : \u211d} (hb : b < 0) :\n(fun z => exp (b * z)) =o[l] fun z => z ^ a :="}
{"gold_output": "theorem comap_mono {f : P\u2081 \u2192\u1d43[k] P\u2082} {s t : AffineSubspace k P\u2082} : s \u2264 t \u2192 s.comap f \u2264 t.comap f :=", "model_response": "lemma comap_inf (f : P\u2081 \u2192\u1d43[k] P\u2082) (s t : AffineSubspace k P\u2082) :\n(s \u2293 t).comap f = s.comap f \u2293 t.comap f :="}
{"gold_output": "theorem llcomp_apply (f : N\u2097 \u2192\u2097[R] P\u2097) (g : M \u2192\u2097[R] N\u2097) (x : M) :\nllcomp R M N\u2097 P\u2097 f g x = f (g x) :=", "model_response": "lemma inl_comp_inj (f g : N\u2097 \u2192\u2097[R] P\u2097) : (inl R M N\u2097 P\u2097 \u2218 f = inl R M N\u2097 P\u2097 \u2218 g) = (f = g) :="}
{"gold_output": "theorem rank_eq (h : Acc r a) :\nh.rank = Ordinal.sup.{u, u} fun b : { b // r b a } => Order.succ (h.inv b.2).rank :=", "model_response": "lemma rank_eq_sup_succ_rank (a) :\n\"rank a = Ordinal.sup.{u, u} fun b : { b // r b a } => Order.succ (rank b)\""}
{"gold_output": "theorem card_shadow_compression_le (u v : Finset \u03b1)\n(huv : \u2200 x \u2208 u, \u2203 y \u2208 v, IsCompressed (u.erase x) (v.erase y) \ud835\udc9c) :\n((\u2202 ) (\ud835\udcd2 u v \ud835\udc9c)).card \u2264 ((\u2202 ) \ud835\udc9c).card :=", "model_response": "lemma card_shadow_compression_le:\n\"(\u2202 ) (\ud835\udcd2 u v \ud835\udc9c) \u2264 (\u2202 ) \ud835\udc9c\""}
{"gold_output": "theorem lists_coe (l : List \u03b1) : lists (l : Cycle \u03b1) = \u2191l.cyclicPermutations :=", "model_response": "lemma coe_lists_of_cycle : (lists_of_cycle l = (l.cyclicPermutations : List (Cycle \u03b1))) :="}
{"gold_output": "theorem comp_inv_app {Y Z : TopCat.{w}} (f : X \u27f6 Y) (g : Y \u27f6 Z) (U) :\n(comp \u2131 f g).inv.app U = \ud835\udfd9 _ :=", "model_response": "theorem naturality: \"\u2131 \u22d9 F.map f g = \u2131 \u22d9 f \u226b \u2131 \u22d9 g\""}
{"gold_output": "theorem exists_continuous_zero_one_of_closed {s t : Set X} (hs : IsClosed s) (ht : IsClosed t)\n(hd : Disjoint s t) : \u2203 f : C(X, \u211d), EqOn f 0 s \u2227 EqOn f 1 t \u2227 \u2200 x, f x \u2208 Icc (0 : \u211d) 1 :=", "model_response": "lemma continuous_on_iff_pairwise_continuous_on_left {f : X \u2192 \u211d} {s : Set X} :\nContinuousOn f s \u2194\nPairwise (ContinuousOn fun y => (f x, f x - f y)) (s \u00d7\u02e2 univ) :="}
{"gold_output": "theorem mem_pure_self (a : \u03b1) : a \u2208 pure a :=", "model_response": "lemma continuous_at_iff_continuous_left_right:\n\"continuous (at x) f \\<longleftrightarrow> continuous (at_left x) f \\<and> continuous (at_right x) f\""}
{"gold_output": "theorem succ_to_nat : \u2200 n, (succ n : \u2115) = n + 1", "model_response": "lemma card_fset_succ [simp]:\nshows \"card_fset (succ |`| S) = card_fset S + 1\""}
{"gold_output": "theorem findGreatest_mono_left [DecidablePred Q] (hPQ : P \u2264 Q) :\nNat.findGreatest P \u2264 Nat.findGreatest Q :=", "model_response": "theorem findGreatest_mono_left_iff :\nNat.findGreatest P \u2264 Nat.findGreatest Q \u2194 \u2200 n, P n \u2192 Q n :="}
{"gold_output": "theorem psigmaCongrRight_symm {\u03b1} {\u03b2\u2081 \u03b2\u2082 : \u03b1 \u2192 Sort _} (F : \u2200 a, \u03b2\u2081 a \u2243 \u03b2\u2082 a) :\n(psigmaCongrRight F).symm = psigmaCongrRight fun a => (F a).symm :=", "model_response": "lemma psigmaCongrRight_bij: \"bij (psigmaCongrRight F)\""}
{"gold_output": "theorem conjTranspose_mul [Fintype n] [NonUnitalSemiring \u03b1] [StarRing \u03b1] (M : Matrix m n \u03b1)\n(N : Matrix n l \u03b1) : (M \u2b1d N)\u1d34 = N\u1d34 \u2b1d M\u1d34 :=", "model_response": "lemma mul_conjTranspose_comm:\nfixes A B :: \"('a::conjurable_ring) mat\"\nshows \"A * B\u1d34 = B\u1d34 * A\u1d34\""}
{"gold_output": "theorem integral_pos_iff_support_of_nonneg_ae (hf : 0 \u2264\u1d50[\u03bc] f) (hfi : IntervalIntegrable f \u03bc a b) :\n(0 < \u222b x in a..b, f x \u2202\u03bc) \u2194 a < b \u2227 0 < \u03bc (support f \u2229 Ioc a b) :=", "model_response": "lemma integral_eq_integral_Ioc [simp]: \"integral a b f = \u222b x in a..b, f x \u2202\u03bc\""}
{"gold_output": "theorem IsHilbertSum.hasSum_linearIsometryEquiv_symm (hV : IsHilbertSum \ud835\udd5c G V)\n(w : lp G 2) : HasSum (fun i => V i (w i)) (hV.linearIsometryEquiv.symm w) :=", "model_response": "lemma summable_V [simp]: \"Summable V\""}
{"gold_output": "theorem epi_of_cokernel_\u03c0_eq_zero (h : cokernel.\u03c0 f = 0) : Epi f :=", "model_response": "theorem cokernel.\u03c0_desc [simp]: \"cokernel.\u03c0 f \u226b cokernel.desc f c sq = c\""}
{"gold_output": "theorem abs_norm_sub_norm_le' (a b : E) : |\u2016a\u2016 - \u2016b\u2016| \u2264 \u2016a / b\u2016 :=", "model_response": "lemma norm_inv_le: \"norm a\u207b\u00b9 \u2264 norm a\""}
{"gold_output": "theorem lt_of_smul_lt_smul_of_nonneg (h : c \u2022 a < c \u2022 b) (hc : 0 \u2264 c) : a < b :=", "model_response": "lemma toIcoMod_eq_self_iff:\n'toIcoMod hp a b = b  \\<longleftrightarrow> b \u2208 Set.Ico a (a + p)'"}
{"gold_output": "theorem antitoneOn_toDual_comp_iff : AntitoneOn (toDual \u2218 f : \u03b1 \u2192 \u03b2\u1d52\u1d48) s \u2194 MonotoneOn f s :=", "model_response": "lemma toDual_sSup_eq [simp]:\n\"toDual (sSup s) = sInf (toDual ` s)\""}
{"gold_output": "theorem eq_whisker {f g : X \u27f6 Y} (w : f = g) (h : Y \u27f6 Z) : f \u226b h = g \u226b h :=", "model_response": "theorem comp_right_eq (f g : X \u27f6 Y) (w : f = g) (h : Y \u27f6 Z) : f \u226b h = g \u226b h :="}
{"gold_output": "theorem trans_assoc_reparam {x\u2080 x\u2081 x\u2082 x\u2083 : X} (p : Path x\u2080 x\u2081) (q : Path x\u2081 x\u2082) (r : Path x\u2082 x\u2083) :\n(p.trans q).trans r =\n(p.trans (q.trans r)).reparam\n(fun t => \u27e8transAssocReparamAux t, transAssocReparamAux_mem_I t\u27e9) (by continuity)\n(Subtype.ext transAssocReparamAux_zero) (Subtype.ext transAssocReparamAux_one) :=", "model_response": "lemma assoc_comp_assoc' [simp]: \"assoc \\<circ> assoc' = id\""}
{"gold_output": "theorem sameRay_or_sameRay_neg_iff_not_linearIndependent {x y : M} :\nSameRay R x y \u2228 SameRay R x (-y) \u2194 \u00acLinearIndependent R ![x, y] :=", "model_response": "lemma mk_linear_orders_eq_mk_linear_orders':\n\"mk_linear_orders s = mk_linear_orders' s\""}
{"gold_output": "theorem take_succ_cons (n : Nat) (s : Stream' \u03b1) : take (n+1) (a::s) = a :: take n s :=", "model_response": "lemma inj_on_f_le_nat : \"inj_on f {i. i \\<le> (n::nat)}\""}
{"gold_output": "theorem Nodup.ndinter {s : Multiset \u03b1} (t : Multiset \u03b1) : Nodup s \u2192 Nodup (ndinter s t) :=", "model_response": "lemma toNat_inj[intro]: \"inj toNat\""}
{"gold_output": "theorem mem_range_le {n x : \u2115} (hx : x \u2208 range n) : x \u2264 n :=", "model_response": "lemma card_range_le:\nassumes \"card (range f) \\<le> n\"\nshows \"surj f\""}
{"gold_output": "theorem Algebra.pushoutDesc_right [H : Algebra.IsPushout R S R' S'] {A : Type _} [Semiring A]\n[Algebra R A] (f : S \u2192\u2090[R] A) (g : R' \u2192\u2090[R] A) (H) (x : R') :\nAlgebra.pushoutDesc S' f g H (algebraMap R' S' x) = g x :=", "model_response": "lemma algebraMap_comp_algebraMap [simp]:\n\"algebraMap R' S' \\<circ> algebraMap S S' = algebraMap R S'\""}
{"gold_output": "theorem denseRange_iff_closure_range : DenseRange f \u2194 closure (range f) = univ :=", "model_response": "lemma continuous_f: \"continuous f\""}
{"gold_output": "theorem _root_.Set.Infinite.not_bddAbove {s : Set \u03b1} : s.Infinite \u2192 \u00acBddAbove s :=", "model_response": "lemma bddAbove_Ici[simp, intro]: \"BddAbove (Ici a)\""}
{"gold_output": "theorem IsOrtho.comap_iff (f : E \u2243\u2097\u1d62[\ud835\udd5c] F) {U V : Submodule \ud835\udd5c F} : U.comap f \u27c2 V.comap f \u2194 U \u27c2 V :=", "model_response": "lemma comap_inf [simp]:\n\"(U \u2293 V).comap f = U.comap f \u2293 V.comap f\""}
{"gold_output": "theorem abs_im_div_abs_le_one (z : \u2102) : |z.im / Complex.abs z| \u2264 1 :=", "model_response": "lemma abs_im_le_abs: \"abs (im z) \\<le> abs z\""}
{"gold_output": "theorem disjSups_inter_subset_right : s \u25cb (t\u2081 \u2229 t\u2082) \u2286 s \u25cb t\u2081 \u2229 s \u25cb t\u2082 :=", "model_response": "lemma disjSups_inter_subset_right : s \u25cb (t\u2081 \u2229 t\u2082) \u2286 s \u25cb t\u2081 \u2229 s \u25cb t\u2082 :="}
{"gold_output": "theorem countable_iff_lt_aleph_one {\u03b1 : Type _} (s : Set \u03b1) : s.Countable \u2194 (#s) < aleph 1 :=", "model_response": "theorem beth_number_le_continuum:\n\"|{f : \u2115 \u2192 \u2115 | \u2200 i, f i \u2264 i}| \u2264 \ud835\udd20\""}
{"gold_output": "theorem IsMaxOn.add (hf : IsMaxOn f s a) (hg : IsMaxOn g s a) : IsMaxOn (fun x => f x + g x) s a :=", "model_response": "lemma continuousWithinAt_prod_self_iff [simp]:\n\"continuousWithinAt (\\<lambda>x. (f x, f x)) s x \\<longleftrightarrow> continuousWithinAt f s x\""}
{"gold_output": "theorem nfpBFamily_monotone (hf : \u2200 i hi, Monotone (f i hi)) : Monotone (nfpBFamily.{u, v} o f) :=", "model_response": "lemma nfpBFamily_monotone: \"Monotone (nfpBFamily.{u, v} o f)\""}
{"gold_output": "theorem toEquiv_inj {e e' : P\u2081 \u2243\u1d43[k] P\u2082} : e.toEquiv = e'.toEquiv \u2194 e = e' :=", "model_response": "lemma symm_trans_self (e : P\u2081 \u2243\u1d43[k] P\u2082) : e.symm.trans e = refl k P\u2082 :="}
{"gold_output": "theorem and_or_imp : a \u2227 b \u2228 (a \u2192 c) \u2194 a \u2192 b \u2228 c :=", "model_response": "lemma to_nat_of_nat[simp] : \"to_nat (of_nat n) = n\""}
{"gold_output": "theorem Quotient.secondCountableTopology [SecondCountableTopology X]\n(h : IsOpenMap (Quotient.mk' : X \u2192 Quotient S)) : SecondCountableTopology (Quotient S) :=", "model_response": "lemma open_map_quotient_mk' [continuous_intros]: \"open_map (mk' : X \u2192 Quotient S)\""}
{"gold_output": "theorem mk_inv (a : G) : ((a\u207b\u00b9 : G) : Q ) = (a : Q)\u207b\u00b9 :=", "model_response": "theorem inv_eq [simp]: \"inv (mk a) = mk a\u207b\u00b9\""}
{"gold_output": "theorem iInf_mono' {g : \u03b9' \u2192 \u03b1} (h : \u2200 i', \u2203 i, f i \u2264 g i') : iInf f \u2264 iInf g :=", "model_response": "lemma iInf_mono_set_le {g : \u03b9' \u2192 \u03b1} (h : \u2200 i', \u2203 i, f i \u2264 g i') :\n(\u2a05 (i) (_ : P i), f i) \u2264 \u2a05 (i) (_ : P i), g i :="}
{"gold_output": "theorem union_left_idem (s t : Finset \u03b1) : s \u222a (s \u222a t) = s \u222a t :=", "model_response": "lemma union_left_idem (s t : Finset \u03b1) : s \u222a (s \u222a t) = s \u222a t :="}
{"gold_output": "theorem inter_singleton_of_not_mem {a : \u03b1} {s : Finset \u03b1} (h : a \u2209 s) : s \u2229 {a} = \u2205 :=", "model_response": "lemma sep_eq_inter: \"{ x \u2208 s | p x } = { x \u2208 s | p x } \u2229 s\""}
{"gold_output": "theorem zeroLocus_iSup {\u03b9 : Sort _} (I : \u03b9 \u2192 Ideal R) :\nzeroLocus ((\u2a06 i, I i : Ideal R) : Set R) = \u22c2 i, zeroLocus (I i) :=", "model_response": "lemma zeroLocus_iSup {\u03b9 : Sort _} (I : \u03b9 \u2192 Ideal R) :\nzeroLocus (\u2a06 i, I i : Ideal R) = \u22c2 i, zeroLocus (I i) :="}
{"gold_output": "theorem Convex.sum_mem (hs : Convex R s) (h\u2080 : \u2200 i \u2208 t, 0 \u2264 w i) (h\u2081 : (\u2211 i in t, w i) = 1)\n(hz : \u2200 i \u2208 t, z i \u2208 s) : (\u2211 i in t, w i \u2022 z i) \u2208 s :=", "model_response": "lemma finite_support : \"finite {x \\<in> s. w x \\<noteq> 0}\""}
{"gold_output": "theorem bind_pmap {\u03b1 \u03b2 \u03b3} {p : \u03b1 \u2192 Prop} (f : \u2200 a, p a \u2192 \u03b2) (x : Option \u03b1) (g : \u03b2 \u2192 Option \u03b3) (H) :\npmap f x H >>= g = x.pbind fun a h \u21a6 g (f a (H _ h)) :=", "model_response": "lemma pmap_eq_pbind: \"pmap f x H = (case x of None \\<Rightarrow> None | Some a \\<Rightarrow> f a (H _))\""}
{"gold_output": "theorem image_const_add_Ici : (fun x => a + x) '' Ici b = Ici (a + b) :=", "model_response": "lemma image_const_sub_Iic : (fun x => a - x) '' Iic b = Iic (b - a) :="}
{"gold_output": "theorem eqOn_sclosure {f g : R \u2192+* S} {s : Set R} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=", "model_response": "lemma continuousWithinAt_iff_eq_on:\n\"continuousWithinAt f s x \\<longleftrightarrow> eqOn f g s x\""}
{"gold_output": "theorem factorThruImage_comp_coimageIsoImage'_inv :\nfactorThruImage f \u226b (coimageIsoImage' f).inv = cokernel.\u03c0 _ :=", "model_response": "lemma factorThruImage_comp_coimageIsoImage'_inv :\nfactorThruImage f \u226b (coimageIsoImage' f).inv = cokernel.\u03c0 _ :="}
{"gold_output": "theorem tsub_eq_zero_iff_le : a - b = 0 \u2194 a \u2264 b :=", "model_response": "lemma isCont_iff_leftLim_eq_rightLim :\n\"isCont f x \\<longleftrightarrow> leftLim f x = rightLim f x\""}
{"gold_output": "theorem IsCoseparating.mono {\ud835\udca2 : Set C} (h\ud835\udca2 : IsCoseparating \ud835\udca2) {\u210b : Set C} (h\ud835\udca2\u210b : \ud835\udca2 \u2286 \u210b) :\nIsCoseparating \u210b :=", "model_response": "lemma small_hom (A B : C) : Small (hom A B) :="}
{"gold_output": "theorem ext_iff {s t : Finmap \u03b2} : s.entries = t.entries \u2194 s = t :=", "model_response": "lemma toList_injective [simp]:\n\"toList s = toList t \u2194 s = t\""}
{"gold_output": "theorem isUnit_one_sub_self_of_mem_nonunits (a : R) (h : a \u2208 nonunits R) : IsUnit (1 - a) :=", "model_response": "lemma continuous_at_iff_continuous_within_at:\n\"continuous (at x) f \\<longleftrightarrow> continuous (at x within s) f\""}
{"gold_output": "theorem isConnected_Ioi [NoMaxOrder \u03b1] : IsConnected (Ioi a) :=", "model_response": "lemma isConnected_Iic [simp]: \"IsConnected (Iic a)\"\nfor a :: \"'a::linorder_topology\""}
{"gold_output": "theorem mem_nthRoots {n : \u2115} (hn : 0 < n) {a x : R} : x \u2208 nthRoots n a \u2194 x ^ n = a :=", "model_response": "lemma nthRoots_one [simp]: \"nthRoots n (1 :: R) = {1}\""}
{"gold_output": "theorem coe_eq_zero {x : S} : (x : A) = 0 \u2194 x = 0 :=", "model_response": "lemma continuousWithinAt_iff_continuousAt_restrict [simp]:\n\"ContinuousWithinAt f s x \u2194 ContinuousAt (restrict f s) x\""}
{"gold_output": "theorem LinearIndependent.total_comp_repr :\n(Finsupp.total \u03b9 M R v).comp hv.repr = Submodule.subtype _ :=", "model_response": "lemma Finsupp.total_comp_repr :\n\"(Finsupp.total \u03b9 M R v).comp hv.repr = Submodule.subtype _\""}
{"gold_output": "theorem eval\u2082_zero_apply (f : R \u2192+* S\u2082) (p : MvPolynomial \u03c3 R) :\neval\u2082 f (0 : \u03c3 \u2192 S\u2082) p = f (constantCoeff p) :=", "model_response": "lemma eval\u2082_zero_apply [simp]: \"eval\u2082 f (0 : \u03c3 \u2192 S\u2082) p = f (constantCoeff p)\""}
{"gold_output": "theorem subset_mul_left (s : Set \u03b1) {t : Set \u03b1} (ht : (1 : \u03b1) \u2208 t) : s \u2286 s * t :=", "model_response": "lemma Iic_mul_eq_Iic_mul_right (s : Set \u03b1) (t : Set \u03b1) (ht : (1 : \u03b1) \u2208 t) :\n{ x \u2208 s | \u2203 y \u2208 t, x \u2264 y } = { x \u2208 s | \u2203 y \u2208 t, x \u2264 y } :="}
{"gold_output": "theorem takeI_left (l\u2081 l\u2082 : List \u03b1) : takeI (length l\u2081) (l\u2081 ++ l\u2082) = l\u2081 :=", "model_response": "lemma takeI_append :\nassumes \"i \\<le> length l\u2081\"\nshows \"takeI i (l\u2081 @ l\u2082) = take i l\u2081\""}
{"gold_output": "theorem coe_restrictScalars (f : M \u2192\u2097[S] M\u2082) : ((f : M \u2192\u2097[R] M\u2082) : M \u2192 M\u2082) = f :=", "model_response": "lemma restrictScalars_inj_iff_ker_bot :\n\"Function.Injective f  \\<longleftrightarrow> LinearMap.ker (f.restrictScalars R) = \u22a5\""}
{"gold_output": "theorem isIntegral_of_submodule_noetherian (S : Subalgebra R A)\n(H : IsNoetherian R (Subalgebra.toSubmodule S)) (x : A) (hx : x \u2208 S) : IsIntegral R x :=", "model_response": "lemma toSubmodule_injective :\n\"Function.Injective toSubmodule\""}
{"gold_output": "theorem directedOn_pair (h : Reflexive r) {a b : \u03b1} (hab : a \u227c b) : DirectedOn r ({a, b} : Set \u03b1) :=", "model_response": "lemma card_le_1_imp_eq [simp]:\nassumes \"card s \\<le> 1\"\nshows \"s = {a} \\<longleftrightarrow> s = {} \\<or> s = {a}\""}
{"gold_output": "theorem add_right_cancel' (c : \u03b1) : a + c \u2261 b + c [PMOD p] \u2192 a \u2261 b [PMOD p] :=", "model_response": "lemma toIcoMod_eq_self_iff:\n\"toIcoMod hp a b = b \u2194 b \u2208 Set.Ico a (a + p)\""}
{"gold_output": "theorem map_coe' {a : \u03b1} {f : \u03b1 \u2192 \u03b2} : Option.map f (a : Option \u03b1) = \u2191(f a) :=", "model_response": "lemma continuousWithinAt_insert_self_iff:\n\"continuousWithinAt f (insert x s) x \\<longleftrightarrow> continuousWithinAt f s x\""}
{"gold_output": "theorem primPart_ne_zero (p : R[X]) : p.primPart \u2260 0 :=", "model_response": "lemma primPart_eq_C_content_mul_primPart_div_content:\n\"primPart p = C (content p) * primPart (p / C (content p))\""}
{"gold_output": "theorem _root_.MeasurableSet.isClopenable [PolishSpace \u03b1] [MeasurableSpace \u03b1] [BorelSpace \u03b1]\n{s : Set \u03b1} (hs : MeasurableSet s) : IsClopenable s :=", "model_response": "lemma isPiSystem_measurableSet [simp]: \"IsPiSystem { s | MeasurableSet s }\""}
{"gold_output": "theorem cycle_eq : \u2200 (l : List \u03b1) (h : l \u2260 []), cycle l h = l ++\u209b cycle l h", "model_response": "lemma card_lists_length_le_eq_1_iff :\nassumes \"card A = 1\"\nshows \"{l. length l = card A} = {A}\""}
{"gold_output": "theorem dotProduct_neg : v \u2b1d\u1d65 -w = -(v \u2b1d\u1d65 w) :=", "model_response": "lemma dotProduct_neg_right [simp]: \"v \u2b1d\u1d65 -w = -(v \u2b1d\u1d65 w)\""}
{"gold_output": "theorem mk'_apply (x : G) : mk' N x = x :=", "model_response": "lemma mk'_surj : \"Function.Surjective mk'\""}
{"gold_output": "theorem Icc_diff_Ioo_self (h : a \u2264 b) : Icc a b \\ Ioo a b = {a, b} :=", "model_response": "lemma sep_eq_Icc_iff:\n\"{x \\<in> Icc a b. P x} = Icc a b \\<longleftrightarrow> (\\<forall>x. a \\<le> x \\<and> x \\<le> b \\<longrightarrow> P x)\""}
{"gold_output": "theorem AnalyticSet.image_of_continuous {\u03b2 : Type _} [TopologicalSpace \u03b2] {s : Set \u03b1}\n(hs : AnalyticSet s) {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) : AnalyticSet (f '' s) :=", "model_response": "lemma continuous_on_analytic: \"continuous_on s f\" if \"AnalyticSet s\""}
{"gold_output": "theorem factors_chain' (n) : List.Chain' (\u00b7 \u2264 \u00b7) (factors n) :=", "model_response": "lemma ofNat_eq_ofNat' [simp]:\n\"ofNat n = ofNat' n\""}
{"gold_output": "theorem dvd_of_dvd_mul_right_of_no_prime_factors {a b c : R} (ha : a \u2260 0)\n(no_factors : \u2200 {d}, d \u2223 a \u2192 d \u2223 b \u2192 \u00acPrime d) : a \u2223 b * c \u2192 a \u2223 c :=", "model_response": "lemma dvd_of_dvd_mul_right:\nassumes \"a \\<noteq> 0\"\nshows \"a dvd b * c \\<Longrightarrow> a dvd c\""}
{"gold_output": "theorem toEnd_mul (x y : CentroidHom \u03b1) : (x * y).toEnd = x.toEnd * y.toEnd :=", "model_response": "lemma one_comp [simp]: \"CentroidHom.id \u03b1 \\<circ> f = f\""}
{"gold_output": "theorem Finite.seq' {\u03b1 \u03b2 : Type u} {f : Set (\u03b1 \u2192 \u03b2)} {s : Set \u03b1} (hf : f.Finite) (hs : s.Finite) :\n(f <*> s).Finite :=", "model_response": "theorem finite_eq_on {\u03b1 \u03b2 : Type u} {f g : \u03b1 \u2192 \u03b2} {s : Set \u03b1} (hf : f.Finite) (hs : s.Finite) :\n{f : \u03b1 \u2192 \u03b2 | \u2200 x \u2208 s, f x = g x}.Finite :="}
{"gold_output": "theorem _root_.aestronglyMeasurable_sum_measure_iff [PseudoMetrizableSpace \u03b2]\n{_m : MeasurableSpace \u03b1} {\u03bc : \u03b9 \u2192 Measure \u03b1} :\nAEStronglyMeasurable f (sum \u03bc) \u2194 \u2200 i, AEStronglyMeasurable f (\u03bc i) :=", "model_response": "lemma aestronglyMeasurable_sum_measure_iff:\n\"aestronglyMeasurable f (sum \u03bc) \\<longleftrightarrow> (\\<forall>i, aestronglyMeasurable f (\u03bc i))\""}
{"gold_output": "theorem ofTop_symm_apply {h} (x : M) : (ofTop p h).symm x = \u27e8x, h.symm \u25b8 trivial\u27e9 :=", "model_response": "lemma ofTop_symm_eq [simp]: \"ofTop p h).symm = toTop p\""}
{"gold_output": "theorem semiconj_of_group_action_of_forall_translationNumber_eq {G : Type _} [Group G]\n(f\u2081 f\u2082 : G \u2192* CircleDeg1Lift) (h : \u2200 g, \u03c4 (f\u2081 g) = \u03c4 (f\u2082 g)) :\n\u2203 F : CircleDeg1Lift, \u2200 g, Semiconj F (f\u2081 g) (f\u2082 g) :=", "model_response": "lemma translation_number_pow [simp]:\n\"\u03c4 (f ^ n) = n * \u03c4 f\""}
{"gold_output": "theorem StarConvex.affine_image (f : E \u2192\u1d43[\ud835\udd5c] F) {s : Set E} (hs : StarConvex \ud835\udd5c x s) :\nStarConvex \ud835\udd5c (f x) (f '' s) :=", "model_response": "lemma convex_on_iff_le_segment:\n\"convex_on \ud835\udd5c s f \\<longleftrightarrow>\n(\\<forall>x\\<in>s. \\<forall>y\\<in>s. \\<forall>a b. 0 \\<le> a \\<and> 0 \\<le> b \\<and> a + b = 1 \\<longrightarrow> f (a *\\<^sub>R x + b *\\<^sub>R y) \\<le> a * f x + b * f y)\""}
{"gold_output": "theorem exists_seq_tendsto_sSup {\u03b1 : Type _} [ConditionallyCompleteLinearOrder \u03b1]\n[TopologicalSpace \u03b1] [OrderTopology \u03b1] [FirstCountableTopology \u03b1] {S : Set \u03b1} (hS : S.Nonempty)\n(hS' : BddAbove S) : \u2203 u : \u2115 \u2192 \u03b1, Monotone u \u2227 Tendsto u atTop (\ud835\udcdd (sSup S)) \u2227 \u2200 n, u n \u2208 S :=", "model_response": "lemma cauchy_tendsto_sSup:\nfixes f :: \"nat \\<Rightarrow> 'a::{conditionally_complete_linorder, metric_space}\"\nassumes \"\\<And>\\<epsilon>. 0 < \\<epsilon> \\<Longrightarrow> \\<exists>N. \\<forall>n\\<ge>N. dist (f n) (sSup S) < \\<epsilon>\"\nshows \"f \\<longlonglongrightarrow> sSup S\""}
{"gold_output": "theorem toAlgHom_apply (y : S) : toAlgHom R S A y = algebraMap S A y :=", "model_response": "lemma toAlgHom_inj: \"inj toAlgHom\""}
{"gold_output": "theorem coe_orderEmbeddingOfSet [DecidablePred (\u00b7 \u2208 s)] :\n\u21d1(orderEmbeddingOfSet s) = (\u2191) \u2218 Subtype.ofNat s :=", "model_response": "lemma strictMono_toDual :\n\"StrictMono (toDual : WithBot \u03b1 \\<Rightarrow> WithTop \u03b1\u1d52\u1d48)\""}
{"gold_output": "theorem NatTrans.leftDerived_eq {F G : C \u2964 D} [F.Additive] [G.Additive] (\u03b1 : F \u27f6 G) (n : \u2115) {X : C}\n(P : ProjectiveResolution X) :\n(NatTrans.leftDerived \u03b1 n).app X =\n(F.leftDerivedObjIso n P).hom \u226b\n(homologyFunctor D _ n).map ((NatTrans.mapHomologicalComplex \u03b1 _).app P.complex) \u226b\n(G.leftDerivedObjIso n P).inv :=", "model_response": "lemma homologyFunctor_inv_comp:\n\"(homologyFunctorIso p F).inv \u226b homologyFunctor p D F = homologyFunctor p D (F \u22d9 chainComplexOfFtor F)\""}
{"gold_output": "theorem toAddMonoidHom_eq_coe (f : CentroidHom \u03b1) : f.toAddMonoidHom = f :=", "model_response": "lemma id_comp [simp]: \"CentroidHom.id \u03b1 \\<circ> f = f\""}
{"gold_output": "theorem image_neg_Ici : Neg.neg '' Ici a = Iic (-a) :=", "model_response": "lemma image_neg_Ici[simp]: \"-` (Ici a) = Iic (-a)\""}
{"gold_output": "theorem measurable_toNNReal : Measurable ENNReal.toNNReal :=", "model_response": "lemma measurable_ereal_to_real[measurable]: \"Measurable EReal.toReal\""}
{"gold_output": "theorem Subsingleton.induction_on {p : Set \u03b1 \u2192 Prop} (hs : s.Subsingleton) (he : p \u2205)\n(h\u2081 : \u2200 x, p {x}) : p s :=", "model_response": "lemma subsingleton_insert:\nassumes \"s.Subsingleton\" \"x \\<notin> s\"\nshows \"p (insert x s)\""}
{"gold_output": "theorem DifferentiableWithinAt.sub_const (hf : DifferentiableWithinAt \ud835\udd5c f s x) (c : F) :\nDifferentiableWithinAt \ud835\udd5c (fun y => f y - c) s x :=", "model_response": "lemma fderivWithin_sub_const (hf : DifferentiableWithinAt \ud835\udd5c f s x) (c : F) :\nfderivWithin \ud835\udd5c (fun y => f y - c) s x = fderivWithin \ud835\udd5c f s x :="}
{"gold_output": "theorem disjoint_sum_left {a : Multiset \u03b1} {i : Multiset (Multiset \u03b1)} :\nMultiset.Disjoint i.sum a \u2194 \u2200 b \u2208 i, Multiset.Disjoint b a :=", "model_response": "lemma disjoint_sum_map_singleton_left : \"Multiset.Disjoint (i.map Multiset.singleton).sum a\""}
{"gold_output": "theorem dense_compl_singleton_iff_not_open {x : \u03b1} :\nDense ({x}\u1d9c : Set \u03b1) \u2194 \u00acIsOpen ({x} : Set \u03b1) :=", "model_response": "lemma dense_compl_singleton_iff_not_open: \"dense ({x}\u1d9c) \u2194 \u00acIsOpen ({x} : Set \u03b1)\""}
{"gold_output": "theorem rcomap_compose (r : Rel \u03b1 \u03b2) (s : Rel \u03b2 \u03b3) : rcomap r \u2218 rcomap s = rcomap (r.comp s) :=", "model_response": "lemma rcomap_id : \"rcomap (Id_on \u03b1) r = r\""}
{"gold_output": "theorem isGLB_l {a : \u03b1} : IsGLB { b | a \u2264 u b } (l a) :=", "model_response": "lemma l_continuous:\n\"continuous l\""}
{"gold_output": "theorem diagonal_map [Zero \u03b1] [Zero \u03b2] {f : \u03b1 \u2192 \u03b2} (h : f 0 = 0) {d : n \u2192 \u03b1} :\n(diagonal d).map f = diagonal fun m => f (d m) :=", "model_response": "lemma inj_on_diagonal_iff [simp]:\n\"inj_on f (diagonal M) \u2194 \u2200 i, f (M i i) = 0 \\<longrightarrow> M i i = 0\""}
{"gold_output": "theorem isNoetherianRing : IsNoetherianRing A :=", "model_response": "lemma inj: \"inj f\""}
{"gold_output": "theorem HasAntitoneBasis.prod {\u03b9 : Type _} [LinearOrder \u03b9] {f : Filter \u03b1} {g : Filter \u03b2}\n{s : \u03b9 \u2192 Set \u03b1} {t : \u03b9 \u2192 Set \u03b2} (hf : HasAntitoneBasis f s) (hg : HasAntitoneBasis g t) :\nHasAntitoneBasis (f \u00d7\u02e2 g) fun n => s n \u00d7\u02e2 t n :=", "model_response": "lemma continuous_iff_tendsto: \"continuous f x \\<longleftrightarrow> (f \\<longlongrightarrow> f x) (\ud835\udcdd x)\""}
{"gold_output": "theorem RestrictScalars.addEquiv_map_smul (c : R) (x : RestrictScalars R S M) :\nRestrictScalars.addEquiv R S M (c \u2022 x) = algebraMap R S c \u2022 RestrictScalars.addEquiv R S M x :=", "model_response": "lemma RestrictScalars.addEquiv_apply_tensor_apply (m n) :\nRestrictScalars.addEquiv R S M (m \u2297\u209c n) =\n(RestrictScalars.addEquiv R S M m) \u2297\u209c (RestrictScalars.addEquiv R S M n) :="}
{"gold_output": "theorem smul_set_sdiff\u2080 (ha : a \u2260 0) : a \u2022 (s \\ t) = a \u2022 s \\ a \u2022 t :=", "model_response": "lemma set_smul_diff_eq_iff: \"a \u2022 s = a \u2022 s \\ a \u2022 t \u2194 s \u2229 t \u2286 {0}\""}
{"gold_output": "theorem mulIndicator_compl_mul_self (s : Set \u03b1) (f : \u03b1 \u2192 M) :\nmulIndicator (s\u1d9c) f * mulIndicator s f = f :=", "model_response": "lemma mulIndicator_compl_mul_self [simp]: \"(mulIndicator (s\u1d9c) f) * (mulIndicator s f) = f\""}
{"gold_output": "theorem reindex_apply (e\u2098 : m \u2243 l) (e\u2099 : n \u2243 o) (M : Matrix m n \u03b1) :\nreindex e\u2098 e\u2099 M = M.submatrix e\u2098.symm e\u2099.symm :=", "model_response": "lemma reindex_eq_submatrix:\nassumes \"finite l\" \"equiv m l e\u2098\" \"equiv n o e\u2099\"\nshows \"reindex e\u2098 e\u2099 M = M.submatrix e\u2098.symm e\u2099.symm\""}
{"gold_output": "theorem le_iInf_mul_iInf {a : \u211d\u22650} {g h : \u03b9 \u2192 \u211d\u22650} (H : \u2200 i j, a \u2264 g i * h j) :\na \u2264 iInf g * iInf h :=", "model_response": "lemma iInf_mul_iInf:\nfixes g h :: \"\u03b9 \\<Rightarrow> \u211d\u22650\"\nshows \"((\u2a05 i, g i) * \u2a05 j, h j) = (\u2a05 (i) (j), g i * h j)\""}
{"gold_output": "theorem map_neg (x : R) : v (-x) = v x :=", "model_response": "lemma map_zero : \"v 0 = 0\""}
{"gold_output": "theorem map_comap_incl : map N.incl (comap N.incl N') = N \u2293 N' :=", "model_response": "lemma map_id : \"map N.incl (comap N.incl N) = N\""}
{"gold_output": "theorem lift_le_nat_iff {a : Cardinal.{u}} {n : \u2115} : lift.{v} a \u2264 n \u2194 a \u2264 n :=", "model_response": "theorem lift_le_lift_iff {a : Cardinal.{u}} {n : \u2115} : lift.{v} a \u2264 lift.{v} n \u2194 a \u2264 n :="}
{"gold_output": "theorem top_prod (H : Subgroup N) : (\u22a4 : Subgroup G).prod H = H.comap (MonoidHom.snd G N) :=", "model_response": "lemma top_prod_eq_comap_snd : \"(top : Subgroup G).prod H = H.comap (MonoidHom.snd G N)\""}
{"gold_output": "theorem not_mem_span_of_apply_not_mem_span_image [RingHomSurjective \u03c3\u2081\u2082] (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) {x : M}\n{s : Set M} (h : f x \u2209 Submodule.span R\u2082 (f '' s)) : x \u2209 Submodule.span R s :=", "model_response": "lemma injOn_iff_ker_bot :\n\"injOn f s \\<longleftrightarrow> LinearMap.ker (f : M \u2192\u209b\u2097[\u03c3\u2081\u2082] M\u2082) = \u22a5\""}
{"gold_output": "theorem map_eq_one_iff {M N} [MulOneClass M] [MulOneClass N] (h : M \u2243* N) {x : M} :\nh x = 1 \u2194 x = 1 :=", "model_response": "lemma ofAdd_inj [simp]: \"ofAdd x = ofAdd y \\<longleftrightarrow> x = y\""}
{"gold_output": "theorem image (h : IsGenericPoint x S) {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) :\nIsGenericPoint (f x) (closure (f '' S)) :=", "model_response": "lemma closure_image [simp]: \"closure (f ` s) = f ` closure s\""}
{"gold_output": "theorem IsDetecting.isSeparating [HasEqualizers C] {\ud835\udca2 : Set C} (h\ud835\udca2 : IsDetecting \ud835\udca2) :\nIsSeparating \ud835\udca2 :=", "model_response": "theorem isSeparating_setOf_isZero :\nIsSeparating { a | IsZero a } :="}
{"gold_output": "theorem liftHom_root : liftHom f a hfx (root f) = a :=", "model_response": "lemma liftHom_comp:\nassumes \"g \\<in> ringHom R S\" and \"f \\<in> Pring_set R (S \\<lparr> carrier := (g ` S\\<^bsub>X\\<^esub>) \\<rparr>)\"\nshows \"liftHom g a hfx (f \\<circ>\\<^bsub>R[\\<X>\\<^bsub>S\\<^esub>]\\<^esub> g) = g \\<circ>\\<^bsub>S[\\<X>\\<^bsub>R\\<^esub>]\\<^esub> liftHom g a hfx f\""}
{"gold_output": "theorem nonneg_pi_iff [Fintype \u03b9] {R} [OrderedRing R] [\u2200 i, Module R (M\u1d62 i)]\n{Q : \u2200 i, QuadraticForm R (M\u1d62 i)} : (\u2200 x, 0 \u2264 pi Q x) \u2194 \u2200 i x, 0 \u2264 Q i x :=", "model_response": "lemma nonneg_pi_tensor_iff [simp]:\n\"(\\<forall>x. 0 \\<le> pi (Q \\<otimes>\\<^sub>p Q') x) \\<longleftrightarrow> (\\<forall>x. 0 \\<le> Q x) \\<and> (\\<forall>x. 0 \\<le> Q' x)\""}
{"gold_output": "theorem Disjoint.le_symmDiff_sup_symmDiff_left (h : Disjoint a b) : c \u2264 a \u2206 c \u2294 b \u2206 c :=", "model_response": "lemma set_compr_eq_symmDiff : {x. (x \\<in> a \\<longleftrightarrow> x \\<in> b)} = a \\<Delta> b :="}
{"gold_output": "theorem inf_left_idem : a \u2293 (a \u2293 b) = a \u2293 b :=", "model_response": "lemma inf_distrib_left : a \\<sqinter> (b \\<sqinter> c) = (a \\<sqinter> b) \\<sqinter> (a \\<sqinter> c) :="}
{"gold_output": "theorem le_mul_right (a : Ordinal) {b : Ordinal} (hb : 0 < b) : a \u2264 b * a :=", "model_response": "lemma \\<omega>_le_\\<omega>_exp_\\<omega> [simp]:\nassumes \"Ord \\<alpha>\"\nshows \"\\<omega> \\<alpha> \\<le> \\<omega> (\\<omega> \\<alpha> \\<up> \\<omega> \\<alpha>)\""}
{"gold_output": "theorem mapPair_left : (mapPair f g).app \u27e8left\u27e9 = f :=", "model_response": "lemma mapPair_left_app : (mapPair f g).app left = f :="}
{"gold_output": "theorem borel_eq_generateFrom_of_subbasis {s : Set (Set \u03b1)} [t : TopologicalSpace \u03b1]\n[SecondCountableTopology \u03b1] (hs : t = .generateFrom s) : borel \u03b1 = .generateFrom s :=", "model_response": "lemma toMeasure_injective : Injective (toMeasure : ProbabilityMeasure \u03b1 \u2192 Measure \u03b1) :="}
{"gold_output": "theorem unop_neg [Neg \u03b1] (x : \u03b1\u1d50\u1d52\u1d56) : unop (-x) = -unop x :=", "model_response": "lemma unop_compl [simp]: \"unop (compl x) = compl (unop x)\""}
{"gold_output": "theorem setOf_inter_eq_sep (p : \u03b1 \u2192 Prop) (s : Set \u03b1) : {a | p a} \u2229 s = {a \u2208 s | p a} :=", "model_response": "lemma setOf_eq_sep : \"{x . p x} = {x \\<in> s . p x}\""}
{"gold_output": "theorem cancel_right {g\u2081 g\u2082 : SupHom \u03b2 \u03b3} {f : SupHom \u03b1 \u03b2} (hf : Surjective f) :\ng\u2081.comp f = g\u2082.comp f \u2194 g\u2081 = g\u2082 :=", "model_response": "lemma id_right_cancel [simp]: \"(SupHom.id \u03b3).comp g\u2081 = (SupHom.id \u03b3).comp g\u2082 \\<longleftrightarrow> g\u2081 = g\u2082\""}
{"gold_output": "theorem one_le_iff_ne_zero {c : Cardinal} : 1 \u2264 c \u2194 c \u2260 0 :=", "model_response": "lemma one_le_aleph0 [simp]: \"1 \\<le> \u2135\u2080\""}
{"gold_output": "theorem mem_of_mem_inter_right {a : \u03b1} {s\u2081 s\u2082 : Finset \u03b1} (h : a \u2208 s\u2081 \u2229 s\u2082) : a \u2208 s\u2082 :=", "model_response": "lemma inj_on_iff_subsingleton_image: \"inj_on f s \\<longleftrightarrow> (f '' s).Subsingleton\""}
{"gold_output": "theorem image_const_add_Icc : (fun x => a + x) '' Icc b c = Icc (a + b) (a + c) :=", "model_response": "lemma image_const_sub_Icc: \"(\\<lambda>x. x - a) '' Icc b c = Icc (b - a) (c - a)\""}
{"gold_output": "theorem curry_apply {\u03b1 \u03b2 \u03b3} (f : \u03b1 \u00d7 \u03b2 \u2192 \u03b3) (x : \u03b1) (y : \u03b2) : curry f x y = f (x, y) :=", "model_response": "lemma curry_eq_comp:\nassumes \"f \\<in> A \\<times>\\<^sub>\\<circ> B \\<rightarrow>\\<^sub>\\<circ> C\"\nshows \"curry f = pair \\<circ>\\<^sub>\\<circ> f\""}
{"gold_output": "theorem continuous_coe_ennreal_iff {f : \u03b1 \u2192 \u211d\u22650\u221e} :\n(Continuous fun a => (f a : EReal)) \u2194 Continuous f :=", "model_response": "lemma continuous_enn2ereal: \"continuous enn2ereal\""}
{"gold_output": "theorem coe_fst : \u21d1(fst M N) = Prod.fst :=", "model_response": "lemma coe_snd : \u21d1(snd M N) = Prod.snd :="}
{"gold_output": "theorem sdiff_union_distrib (s t\u2081 t\u2082 : Finset \u03b1) : s \\ (t\u2081 \u222a t\u2082) = s \\ t\u2081 \u2229 (s \\ t\u2082) :=", "model_response": "lemma sep_eq_inter_iff:\n\"{a \\<in> s . P a} = {a \\<in> s . P a \\<and> Q a} \\<longleftrightarrow> (\\<forall>a\\<in>s. P a \\<longrightarrow> Q a)\""}
{"gold_output": "theorem symm_apply_mk_proj (ex : x \u2208 e.source) : e.toLocalHomeomorph.symm (proj x, (e x).2) = x :=", "model_response": "lemma symm_apply_mk_proj: \"e.toLocalHomeomorph.symm (proj x, (e x).2) = x\""}
{"gold_output": "theorem AntitoneOn.sum_le_integral (hf : AntitoneOn f (Icc x\u2080 (x\u2080 + a))) :\n(\u2211 i in Finset.range a, f (x\u2080 + (i + 1 : \u2115))) \u2264 \u222b x in x\u2080..x\u2080 + a, f x :=", "model_response": "lemma integrableOn_comp_add_iff_integrableOn_shift_measure :\n\"IntegrableOn f (Icc x\\<^sub>0 (x\\<^sub>0 + a)) \\<mu> \\<longleftrightarrow> IntegrableOn f (Icc 0 a) (measure_shift x\\<^sub>0 \\<mu>)\""}
{"gold_output": "theorem _root_.MeasurableEmbedding.snorm_map_measure {g : \u03b2 \u2192 F} (hf : MeasurableEmbedding f) :\nsnorm g p (Measure.map f \u03bc) = snorm (g \u2218 f) p \u03bc :=", "model_response": "theorem snorm_def_emeasure {f : \u03b1 \u2192 F} (hf : MeasurableEmbedding f) :\n\u2016f\u2016 = (\u222b\u207b x, (\u2016f x\u2016\u208a : \u211d\u22650\u221e) ^ p \u2202\u03bc) ^ (1 / p) :="}
{"gold_output": "theorem stmts_supportsStmt {M : \u039b \u2192 Stmt\u2081} {S : Finset \u039b} {q : Stmt\u2081} (ss : Supports M S) :\nsome q \u2208 stmts M S \u2192 SupportsStmt S q :=", "model_response": "lemma stmts_supportsStmt:\n\"supp q \\<subseteq>  (\\<Union>a\\<in>S. supp (M a))\" if \"supports M S\""}
{"gold_output": "theorem isMax_ofDual_iff {a : \u03b1\u1d52\u1d48} : IsMax (ofDual a) \u2194 IsMin a :=", "model_response": "theorem ofDual_sSup_eq [simp]: \"ofDual (sSup s) = sInf (ofDual ` s)\""}
{"gold_output": "theorem supportsStmt_move {S : Finset \u039b'\u2081} {d : Dir} {q : Stmt'\u2081} :\nSupportsStmt S (move\u2099 d q) = SupportsStmt S q :=", "model_response": "lemma supportsStmt_move [simp]:\n\"supportsStmt S (move\u2099 d q) = supportsStmt S q\""}
{"gold_output": "theorem coe_pnat_injective : Function.Injective ((\u2191) : Nat.Primes \u2192 \u2115+) :=", "model_response": "lemma coe_pnat_strictMono : StrictMono (\u2191) :="}
{"gold_output": "theorem choose_pos : \u2200 {n k}, k \u2264 n \u2192 0 < choose n k", "model_response": "lemma choose_eq_zero_iff:\nassumes \"k \\<le> n\"\nshows \"n choose k = 0 \\<longleftrightarrow> n < k\""}
{"gold_output": "theorem whiskeringLeftFunctor'_obj (F : D \u2964 E) : (whiskeringLeftFunctor' L W E).obj F = L \u22d9 F :=", "model_response": "theorem whiskeringLeftFunctor'_comp (L' : C \u2964 D) (W' : D \u2964 E) (E' : E \u2964 F) :\nwhiskeringLeftFunctor' L W E \u22d9 whiskeringLeftFunctor' L' W' E' =\nwhiskeringLeftFunctor' (L \u22d9 L') (W \u22d9 W') (E \u22d9 E') :="}
{"gold_output": "theorem unsym_ne_one_iff [One \u03b1] (a : \u03b1\u02e2\u02b8\u1d50) : unsym a \u2260 (1 : \u03b1) \u2194 a \u2260 (1 : \u03b1\u02e2\u02b8\u1d50) :=", "model_response": "lemma toDual_symm_eq [simp]:\n\"(toDual : \u03b1\u1d52\u1d48 \u2243 \u03b1).symm = ofDual\""}
{"gold_output": "theorem corec_def {X} (f : X \u2192 F.Obj X) (x\u2080 : X) : M.corec f x\u2080 = M.mk (M.corec f <$> f x\u2080) :=", "model_response": "lemma corec_fac': \"M.mk \\<circ> corec F = corec F\""}
{"gold_output": "theorem pushforwardToOfIso_app {X Y : TopCat} (H\u2081 : X \u2245 Y) {\u2131 : Y.Presheaf C} {\ud835\udca2 : X.Presheaf C}\n(H\u2082 : \u2131 \u27f6 H\u2081.hom _* \ud835\udca2) (U : (Opens X)\u1d52\u1d56) :\n(pushforwardToOfIso H\u2081 H\u2082).app U =\nH\u2082.app (op ((Opens.map H\u2081.inv).obj (unop U))) \u226b\n\ud835\udca2.map (eqToHom (by simp [Opens.map, Set.preimage_preimage])) :=", "model_response": "lemma pushforwardToOfIso_app_eq [simp]:\n\"(pushforwardToOfIso H\u2081 H\u2082).app U =\nH\u2082.app (op ((Opens.map H\u2081.inv).obj (unop U))) \u226b\n\ud835\udca2.map (eqToHom (by simp [Opens.map, Set.preimage_preimage]))\""}
{"gold_output": "theorem Ico_subset_Ico_iff (h\u2081 : a\u2081 < b\u2081) : Ico a\u2081 b\u2081 \u2286 Ico a\u2082 b\u2082 \u2194 a\u2082 \u2264 a\u2081 \u2227 b\u2081 \u2264 b\u2082 :=", "model_response": "lemma Ico_subset_Ico_iff':\n\"{a\\<^sub>1\\<le>\\<^sub>a..\\<le>\\<^sub>ab\\<^sub>2} \\<subseteq> {a\\<^sub>2\\<le>\\<^sub>a..\\<le>\\<^sub>ab\\<^sub>1} \\<longleftrightarrow> a\\<^sub>2 \\<le>\\<^sub>a a\\<^sub>1 \\<and> b\\<^sub>1 \\<le>\\<^sub>a b\\<^sub>2\""}
{"gold_output": "theorem isNat_natSucc : {a : \u2115} \u2192 {a' c : \u2115} \u2192\nIsNat a a' \u2192 Nat.succ a' = c \u2192 IsNat (a.succ) c", "model_response": "lemma isNat_natAdd:\nassumes \"isNat a a'\" and \"isNat b b'\" and \"a' + b' = c\"\nshows \"isNat (a + b) c\""}
{"gold_output": "theorem isSheafOpensLeCover_iff_isSheafPairwiseIntersections :\nF.IsSheafOpensLeCover \u2194 F.IsSheafPairwiseIntersections :=", "model_response": "lemma sheafify_idempotent :\n\"J.sheafify F \u22d9 J.sheafify F = J.sheafify F\""}
{"gold_output": "theorem measurable_exp : Measurable exp :=", "model_response": "lemma measurable_exp [measurable]: \"Measurable (exp :: \u211d \u2192 \u211d)\""}
{"gold_output": "theorem toBlock_mul_eq_add {m n k : Type _} [Fintype n] (p : m \u2192 Prop) (q : n \u2192 Prop)\n[DecidablePred q] (r : k \u2192 Prop) (A : Matrix m n R) (B : Matrix n k R) : (A \u2b1d B).toBlock p r =\nA.toBlock p q \u2b1d B.toBlock q r + (A.toBlock p fun i => \u00acq i) \u2b1d B.toBlock (fun i => \u00acq i) r :=", "model_response": "lemma toBlock_mul_eq_sum_toBlock:\nassumes \"\\<And>i. \\<not> p i \\<longleftrightarrow> q i\"\nshows \"(A * B).toBlock p r =\nA.toBlock p q * B.toBlock q r + A.toBlock p fun i => \\<not>q i * B.toBlock (fun i => \\<not>q i) r\""}
{"gold_output": "theorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two (x y : V) :\n\u2016x + y\u2016 * \u2016x + y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 \u2194 angle x y = \u03c0 / 2 :=", "model_response": "lemma norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two (x y : V) :\n\u2016x + y\u2016 * \u2016x + y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 \u2194 angle x y = \u03c0 / 2 :="}
{"gold_output": "theorem coe_dualBasis [Fintype \u03b9] : \u21d1h.basis.dualBasis = \u03b5 :=", "model_response": "lemma coe_dualBasis [simp]: \"\u21d1h.dualBasis = \u03b5\""}
{"gold_output": "theorem List.dProdIndex_nil (f\u03b9 : \u03b1 \u2192 \u03b9) : ([] : List \u03b1).dProdIndex f\u03b9 = 0 :=", "model_response": "lemma dProdIndex_cons:\nassumes a: \"a \\<in> s\" and b: \"b \\<in> t a\"\nshows \"dProdIndex (a # p) f = f a b + dProdIndex p (fun a b => f a b)\""}
{"gold_output": "theorem coe_sInf (S : Set (IntermediateField F E)) : (\u2191(sInf S) : Set E) =\nsInf ((fun (x : IntermediateField F E) => (x : Set E)) '' S) :=", "model_response": "lemma coe_sInf' (S : Set (IntermediateField F E)) :\n(\u2191(sInf S) : Set E) = sInf ((fun (x : IntermediateField F E) => (x : Set E)) '' S) :="}
{"gold_output": "theorem ext {f g : P \u2192A[R] Q} (h : \u2200 x, f x = g x) : f = g :=", "model_response": "lemma continuous_on_iff_isOpen_graph: \"continuous_on s f \\<longleftrightarrow> IsOpen (graph s f)\""}
{"gold_output": "theorem LinearMap.toMatrix_mul (f g : M\u2081 \u2192\u2097[R] M\u2081) :\nLinearMap.toMatrix v\u2081 v\u2081 (f * g) = LinearMap.toMatrix v\u2081 v\u2081 f \u2b1d LinearMap.toMatrix v\u2081 v\u2081 g :=", "model_response": "lemma LinearMap.toMatrix_id' [simp]: \"LinearMap.toMatrix v\u2081 v\u2081 (id : M\u2081 \u2192\u2097[R] M\u2081) = 1\""}
{"gold_output": "theorem Fin.preimage_apply_01_prod {\u03b1 : Fin 2 \u2192 Type u} (s : Set (\u03b1 0)) (t : Set (\u03b1 1)) :\n(fun f : \u2200 i, \u03b1 i => (f 0, f 1)) \u207b\u00b9' s \u00d7\u02e2 t =\nSet.pi Set.univ (Fin.cons s <| Fin.cons t finZeroElim) :=", "model_response": "lemma preimage_fst_singleton_one (s : Set \u03b1) :\n(fun f : Fin 2 \u2192 \u03b1 => f 0) \u207b\u00b9' {1} = s :="}
{"gold_output": "theorem ext {h h' : \u03b1 \u2243\u1d64 \u03b2} (H : \u2200 x, h x = h' x) : h = h' :=", "model_response": "lemma toFun_eq_coe [simp]: \"h.toFun = h\""}
{"gold_output": "theorem mem_product {p : \u03b1 \u00d7 \u03b2} : p \u2208 s \u00d7\u02e2 t \u2194 p.1 \u2208 s \u2227 p.2 \u2208 t :=", "model_response": "lemma continuousWithinAt_prod :\n\"continuousWithinAt f s x \\<longleftrightarrow> continuousWithinAt (fst \\<circ> f) s x \\<and> continuousWithinAt (snd \\<circ> f) s x\""}
{"gold_output": "theorem cast_negSucc (n : \u2115) : (-[n+1] : R) = -(n + 1 : \u2115) :=", "model_response": "lemma ofNat_negSucc (n : \u2115) : ofNat (-[n+1]) = -ofNat (n + 1) :="}
{"gold_output": "theorem ofDual_intCast [IntCast \u03b1] (n : \u2124) : (ofDual n : \u03b1) = n :=", "model_response": "lemma ofDual_add [simp]:\n\"ofDual (a + b) = ofDual a + ofDual b\""}
{"gold_output": "theorem IntegrableOn.congr_fun (h : IntegrableOn f s \u03bc) (hst : EqOn f g s) (hs : MeasurableSet s) :\nIntegrableOn g s \u03bc :=", "model_response": "lemma integral_sub (h : IntegrableOn f s \u03bc) (hst : EqOn f g s) (hs : MeasurableSet s) :\n(\u222b x in s, f x - g x \u2202\u03bc) = (\u222b x in s, f x \u2202\u03bc) - \u222b x in s, g x \u2202\u03bc :="}
{"gold_output": "theorem equivRangeOfInjective_apply (h : Function.Injective f) (x : L) :\nf.equivRangeOfInjective h x = \u27e8f x, mem_range_self f x\u27e9 :=", "model_response": "theorem injOn_iff_ker_restrict_eq_bot :\n\"injOn f s \\<longleftrightarrow> ker (f.restrict s) = \u22a5\""}
{"gold_output": "theorem card_Iio_eq_card_Iic_sub_one (a : \u03b1) : (Iio a).card = (Iic a).card - 1 :=", "model_response": "lemma card_Iic_eq_card_Iio_add_one (a : \u03b1) : (Iic a).card = (Iio a).card + 1 :="}
{"gold_output": "theorem mk_dest (x : M F) : M.mk (dest x) = x :=", "model_response": "theorem mk_dest_id: \"M.mk \\<circ> dest = id\""}
{"gold_output": "theorem _root_.IsFractional.sup {I J : Submodule R P} :\nIsFractional S I \u2192 IsFractional S J \u2192 IsFractional S (I \u2294 J)", "model_response": "lemma coe_submodule_sup (I J : Submodule R P) :\n(Ideal.Quotient.mk (I * J : Submodule R P) : FractionalIdeal S P) =\nIdeal.Quotient.mk I \u2294 Ideal.Quotient.mk J :="}
{"gold_output": "theorem EventuallyLE.refl (l : Filter \u03b1) (f : \u03b1 \u2192 \u03b2) : f \u2264\u1da0[l] f :=", "model_response": "lemma eventually_nonneg_bot [simp, intro]: \"eventually_nonneg l f\""}
{"gold_output": "theorem cast_ne_one [AddGroupWithOne \u03b1] [CharZero \u03b1] {n : \u2124} : (n : \u03b1) \u2260 1 \u2194 n \u2260 1 :=", "model_response": "lemma of_int_ne_one_iff [simp]: \"(of_int n : \u03b1) \u2260 1 \u2194 n \u2260 1\""}
{"gold_output": "theorem coe_toBasis_repr (b : OrthonormalBasis \u03b9 \ud835\udd5c E) :\nb.toBasis.equivFun = b.repr.toLinearEquiv :=", "model_response": "lemma equivFun_repr: \"b.toBasis.equivFun = b.repr.toLinearEquiv\""}
{"gold_output": "theorem quot_add (x y) :\nQuot.mk Setoid.r (add x y) = (ColimitType.mk x + ColimitType.mk y : ColimitType F) :=", "model_response": "lemma quot_add_mk:\nassumes \"r x y\"\nshows \"Quot.mk Setoid.r (add x y) = (ColimitType.mk x + ColimitType.mk y : ColimitType F)\""}
{"gold_output": "theorem measurableSet_closedBall : MeasurableSet (Metric.closedBall x \u03b5) :=", "model_response": "lemma measurableSet_eball [measurable]: \"Measurable.{u, v} {x. edist x a \\<le> r}\""}
{"gold_output": "theorem not_neZero {R : Type _} [Zero R] {n : R} : \u00acNeZero n \u2194 n = 0 :=", "model_response": "lemma not_nonzero_iff_eq_zero [simp]:\nshows \"\\<not> NeZero a \\<longleftrightarrow> a = 0\""}
{"gold_output": "theorem OneOneReducible.trans {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3] {p : \u03b1 \u2192 Prop}\n{q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} : p \u2264\u2081 q \u2192 q \u2264\u2081 r \u2192 p \u2264\u2081 r", "model_response": "lemma of_nat_one_one_reducible [simp]: \"of_nat \\<in> 1\\<^sub>C of_nat\""}
{"gold_output": "theorem mul_div_div_cancel (a b c : G) : a * b / (a / c) = b * c :=", "model_response": "lemma div_div_cancel_right :\nassumes \"c \\<noteq> 0\"\nshows \"a / c / c = a / c\""}
{"gold_output": "theorem natAbs_lt_iff_sq_lt {a b : \u2124} : a.natAbs < b.natAbs \u2194 a ^ 2 < b ^ 2 :=", "model_response": "lemma natAbs_le_iff_le_or_ge_neg :\n\"(a::\u2124).natAbs \\<le> (b::\u2124).natAbs \\<longleftrightarrow> a \\<le> b \\<or> a \\<ge> -b\""}
{"gold_output": "theorem congr_app {X Y : PresheafedSpace C} {\u03b1 \u03b2 : X \u27f6 Y} (h : \u03b1 = \u03b2) (U) :\n\u03b1.c.app U = \u03b2.c.app U \u226b X.presheaf.map (eqToHom (by subst h ; rfl)) :=", "model_response": "lemma pushforwardIso_hom_comp_pushforward:\n\"(pushforwardIso F f).hom \u226b pushforward f (op F) = pushforward f (op F)\""}
{"gold_output": "theorem gramSchmidtNormed_unit_length {f : \u03b9 \u2192 E} (n : \u03b9) (h\u2080 : LinearIndependent \ud835\udd5c f) :\n\u2016gramSchmidtNormed \ud835\udd5c f n\u2016 = 1 :=", "model_response": "lemma gramSchmidtNormed_unit_length [simp]:\n\"\u2016gramSchmidtNormed \ud835\udd5c f n\u2016 = 1\""}
{"gold_output": "theorem HD_below_aux1 {f : Cb X Y} (C : \u211d) {x : X} :\nBddBelow (range fun y : Y => f (inl x, inr y) + C) :=", "model_response": "lemma HD_below_aux1: \"BddBelow (range fun y : Y => f (inl x, inr y) + C)\""}
{"gold_output": "theorem NonemptyCompacts.dist_eq {x y : NonemptyCompacts \u03b1} :\ndist x y = hausdorffDist (x : Set \u03b1) y :=", "model_response": "lemma NonemptyCompacts.hausdorff_dist_coe [simp]:\n\"hausdorff_dist (x : Set \u03b1) y = dist x y\""}
{"gold_output": "theorem sqrt_eq_iff_mul_self_eq_of_pos (h : 0 < y) : sqrt x = y \u2194 y * y = x :=", "model_response": "lemma sqrt_eq_iff_mul_self_eq (h : 0 < y) : sqrt x = y \u2194 y * y = x :="}
{"gold_output": "theorem vecMul_smul [Fintype n] [Monoid R] [NonUnitalNonAssocSemiring S] [DistribMulAction R S]\n[IsScalarTower R S S] (M : Matrix n m S) (b : R) (v : n \u2192 S) :\nM.vecMul (b \u2022 v) = b \u2022 M.vecMul v :=", "model_response": "lemma vecMul_smul [simp]: \"M.vecMul (b \u2022 v) = b \u2022 M.vecMul v\""}
{"gold_output": "theorem _root_.aestronglyMeasurable_of_aestronglyMeasurable_trim {\u03b1} {m m0 : MeasurableSpace \u03b1}\n{\u03bc : Measure \u03b1} (hm : m \u2264 m0) {f : \u03b1 \u2192 \u03b2} (hf : AEStronglyMeasurable f (\u03bc.trim hm)) :\nAEStronglyMeasurable f \u03bc :=", "model_response": "lemma aestronglyMeasurable_restrict_iff' {s : Set \u03b1} :\nAEStronglyMeasurable f (\u03bc.restrict s) \u2194 AEStronglyMeasurable f \u03bc \u2227 \u2200 x \u2208 s, f x \u2260 0 :="}
{"gold_output": "theorem SemilatticeInf.ext_inf {\u03b1} {A B : SemilatticeInf \u03b1}\n(H : \u2200 x y : \u03b1, (haveI := A; x \u2264 y) \u2194 x \u2264 y)\n(x y : \u03b1) :\n(haveI := A; x \u2293 y) = x \u2293 y :=", "model_response": "lemma ennreal_inf_eq_inf: \"ennreal x \u2293 ennreal y = ennreal (x \u2293 y)\""}
{"gold_output": "theorem HasLimit.ofConesIso {J K : Type u\u2081} [Category.{v\u2081} J] [Category.{v\u2082} K] (F : J \u2964 C)\n(G : K \u2964 C) (h : F.cones \u2245 G.cones) [HasLimit F] : HasLimit G :=", "model_response": "lemma limit.iso_inv_comp_\u03c0 {J K : Type u\u2081} [Category.{v\u2081} J] [Category.{v\u2082} K] (F : J \u2964 C)\n(G : K \u2964 C) (h : F.cones \u2245 G.cones) [HasLimit F] :\n(limit.iso h).inv \u226b limit.\u03c0 F = limit.\u03c0 G :="}
{"gold_output": "theorem smul_univ\u2080 {s : Set \u03b1} (hs : \u00acs \u2286 0) : s \u2022 (univ : Set \u03b2) = univ :=", "model_response": "lemma smul_univ\u2080 : s \u2022 (univ : Set \u03b2) = univ :="}
{"gold_output": "theorem infiniteNeg_add_not_infinite {x y : \u211d*} :\nInfiniteNeg x \u2192 \u00acInfinite y \u2192 InfiniteNeg (x + y) :=", "model_response": "lemma abs_mult_le_abs: \"\\<bar>a * b\\<bar> \\<le> \\<bar>a\\<bar> * \\<bar>b\\<bar>\""}
{"gold_output": "theorem QuotientGroup.card_preimage_mk [Fintype G] (s : Subgroup G) (t : Set (G \u29f8 s)) :\nFintype.card (QuotientGroup.mk \u207b\u00b9' t) = Fintype.card s * Fintype.card t :=", "model_response": "theorem card_quotient_eq_div [simp]: \"card (G \u29f8 H) = card G div card H\""}
{"gold_output": "theorem Orthonormal.inner_sum {v : \u03b9 \u2192 E} (hv : Orthonormal \ud835\udd5c v) (l\u2081 l\u2082 : \u03b9 \u2192 \ud835\udd5c) (s : Finset \u03b9) :\n\u27ea\u2211 i in s, l\u2081 i \u2022 v i, \u2211 i in s, l\u2082 i \u2022 v i\u27eb = \u2211 i in s, conj (l\u2081 i) * l\u2082 i :=", "model_response": "lemma Orthonormal.inner_sum (hv : Orthonormal \ud835\udd5c v) (l\u2081 l\u2082 : \u03b9 \u2192 \ud835\udd5c) (s : Finset \u03b9) :\n\u27ea\u2211 i in s, l\u2081 i \u2022 v i, \u2211 i in s, l\u2082 i \u2022 v i\u27eb = \u2211 i in s, conj (l\u2081 i) * l\u2082 i :="}
{"gold_output": "theorem sum_mul_self (s : Finset \u03b9) (f : \u03b9 \u2192 R) :\n((\u2211 i in s, f i) * \u2211 i in s, f i) = \u2211 i in s, f i * f i :=", "model_response": "lemma sum_mul_sum_eq_sum_prod:\n\"(\u2211 i in s, f i) * \u2211 i in s, g i = \u2211 x in s \u00d7\u02e2 s, f x.1 * g x.2\""}
{"gold_output": "theorem sup [Sup \u03b2] [ContinuousSup \u03b2] (hf : StronglyMeasurable f)\n(hg : StronglyMeasurable g) : StronglyMeasurable (f \u2294 g) :=", "model_response": "lemma sup [measurable]: \"strongly_measurable (\\<lambda>x. f x \\<squnion> g x)\""}
{"gold_output": "theorem RingHom.map_finsupp_prod [Zero M] [CommSemiring R] [CommSemiring S] (h : R \u2192+* S)\n(f : \u03b1 \u2192\u2080 M) (g : \u03b1 \u2192 M \u2192 R) : h (f.prod g) = f.prod fun a b => h (g a b) :=", "model_response": "lemma image_keys_support [simp]:\n\"f ` keys (support p) = support (map f p)\""}
{"gold_output": "theorem injective_iff {\u03b1 : Sort _} {f : Bool \u2192 \u03b1} : Function.Injective f \u2194 f false \u2260 f true :=", "model_response": "lemma ofBool_inj: \"inj ofBool\""}
{"gold_output": "theorem comp_id (f : CentroidHom \u03b1) : f.comp (CentroidHom.id \u03b1) = f :=", "model_response": "lemma id_comp [simp]: \"(CentroidHom.id \u03b2).comp f = (CentroidHom.id \u03b1)\""}
{"gold_output": "theorem nine_dvd_iff (n : \u2115) : 9 \u2223 n \u2194 9 \u2223 (digits 10 n).sum :=", "model_response": "lemma ofNat_one : \"ofNat 1 = 1\""}
{"gold_output": "theorem ContDiff.sinh {n} (h : ContDiff \u211d n f) : ContDiff \u211d n fun x => Real.sinh (f x) :=", "model_response": "lemma contDiff_sinh {n} (h : ContDiff \u211d n f) : ContDiff \u211d n fun x => Real.sinh (f x) :="}
{"gold_output": "theorem coe_mapRingHom_eq_coe_map [RingHomClass F R[X] S[X]] (\u03c6 : F) (h\u03c6 : R[X]\u2070 \u2264 S[X]\u2070.comap \u03c6) :\n(mapRingHom \u03c6 h\u03c6 : RatFunc R \u2192 RatFunc S) = map \u03c6 h\u03c6 :=", "model_response": "lemma map_injective:\n\"Function.Injective (map \u03c6 h\u03c6)\""}
{"gold_output": "theorem swap_inr (x : \u03b2) : swap (inr x : Sum \u03b1 \u03b2) = inl x :=", "model_response": "lemma swap_inl [simp]:\nshows \"swap (inl x : Sum \u03b1 \u03b2) = inr x\""}
{"gold_output": "theorem isOpen_setOf_eventually_nhds {p : \u03b1 \u2192 Prop} : IsOpen { x | \u2200\u1da0 y in \ud835\udcdd x, p y } :=", "model_response": "lemma isOpen_setOf_eventually_nhds {p : \u03b1 \u2192 Prop} : IsOpen { x | \u2200\u1da0 y in \ud835\udcdd x, p y } :="}
{"gold_output": "theorem mem_inv_iff (hI : I \u2260 0) {x : K} : x \u2208 I\u207b\u00b9 \u2194 \u2200 y \u2208 I, x * y \u2208 (1 : FractionalIdeal R\u2081\u2070 K) :=", "model_response": "lemma inv_span_eq:\n\"(Ideal.span S)\u207b\u00b9 = Ideal.span { y \\<in> K. \\<exists>x \\<in> S. x * y \\<in> (1 : FractionalIdeal R\u2081\u2070 K) }\""}
{"gold_output": "theorem tsub_add_eq_tsub_tsub_swap (a b c : \u03b1) : a - (b + c) = a - c - b :=", "model_response": "lemma to_nat_add: \"to_nat (m + n) = to_nat m + n\""}
{"gold_output": "theorem add_mul_left_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (x + y * z) y :=", "model_response": "lemma coprime_add_mul_right_right:\nassumes \"IsCoprime x y\"\nshows \"IsCoprime (x + z * y) y\""}
{"gold_output": "theorem withDensity\u1d65_zero : \u03bc.withDensity\u1d65 (0 : \u03b1 \u2192 E) = 0 :=", "model_response": "lemma toMeasure_injective : Injective (toMeasure : WithDensity \u03b1 E \u2192 Measure \u03b1) :="}
{"gold_output": "theorem tsum_subtype_add_tsum_subtype_compl [T2Space \u03b1] {f : \u03b2 \u2192 \u03b1} (hf : Summable f) (s : Set \u03b2) :\n((\u2211' x : s, f x) + \u2211' x : \u2191(s\u1d9c), f x) = \u2211' x, f x :=", "model_response": "lemma tsum_add_tsum_compl [simp]:\nfixes f :: \"'a \\<Rightarrow> 'b::{comm_monoid_add, t2_space}\"\nassumes \"s \\<in> Pow UNIV\" and \"summable (f \\<circ> (\u2191) : s \\<rightarrow> _)\" and \"summable (f \\<circ> (\u2191) : s\u1d9c \\<rightarrow> _)\"\nshows \"sum f (s : Set _) + sum f (s\u1d9c : Set _) = sum f UNIV\""}
{"gold_output": "theorem span_iUnion {\u03b9} (s : \u03b9 \u2192 Set L) : lieSpan R L (\u22c3 i, s i) = \u2a06 i, lieSpan R L (s i) :=", "model_response": "lemma lie_commute: \"\u2045x, y\u2046 = - \u2045y, x\u2046\""}
{"gold_output": "theorem _root_.TendstoUniformlyOn.cderiv (hF : TendstoUniformlyOn F f \u03c6 (cthickening \u03b4 K))\n(h\u03b4 : 0 < \u03b4) (hFn : \u2200\u1da0 n in \u03c6, ContinuousOn (F n) (cthickening \u03b4 K)) :\nTendstoUniformlyOn (cderiv \u03b4 \u2218 F) (cderiv \u03b4 f) \u03c6 K :=", "model_response": "lemma tendstoUniformlyOn_cderivWithin:\n\"TendstoUniformlyOn (\\<lambda>x. cderivWithin \u03b4 (F x) (cthickening \u03b4 K x))\n(\\<lambda>x. cderivWithin \u03b4 f (cthickening \u03b4 K x)) \u03c6 K\""}
{"gold_output": "theorem cauchySeq_tendsto_of_complete [SemilatticeSup \u03b2] [CompleteSpace \u03b1] {u : \u03b2 \u2192 \u03b1}\n(H : CauchySeq u) : \u2203 x, Tendsto u atTop (\ud835\udcdd x) :=", "model_response": "theorem uniformContinuous_of_real [continuous_intros]: \"uniformContinuous of_real\""}
{"gold_output": "theorem le_enum_succ {o : Ordinal} (a : (succ o).out.\u03b1) :\na \u2264\n@enum (succ o).out.\u03b1 (\u00b7 < \u00b7) _ o\n(by\nrw [type_lt]\nexact lt_succ o) :=", "model_response": "lemma enum_succ_le:\nassumes \"a \\<in> (succ o).out.\u03b1\"\nshows \"enum (succ o) (\u00b7 < \u00b7) a \\<le> a\""}
{"gold_output": "theorem upperBounds_Iic : upperBounds (Iic a) = Ici a :=", "model_response": "lemma lowerBounds_Ici[simp]: \"lowerBounds (Ici a) = Iio a\""}
{"gold_output": "theorem lift.unique' {\u03c6' : (\u2a02[R] i, s i) \u2192\u2097[R] E}\n(H : \u03c6'.compMultilinearMap (PiTensorProduct.tprod R) = \u03c6) : \u03c6' = lift \u03c6 :=", "model_response": "lemma lift_unique' : \"lift \u03c6 = \u03c6'\" if \"\u03c6'.compMultilinearMap (PiTensorProduct.tprod R) = \u03c6\""}
{"gold_output": "theorem rescale_zero : rescale 0 = (C R).comp (constantCoeff R) :=", "model_response": "lemma toLaurent_injective :\n\"Function.Injective (toLaurent : R[X] \\<Rightarrow> R[T;T\u207b\u00b9])\""}
{"gold_output": "theorem wellPowered_of_equiv (e : C \u224c D) [WellPowered C] : WellPowered D :=", "model_response": "lemma equivalence_functor_comp_op (e : C \u224c D) :\ne.functor \u22d9 e.op.functor = \ud835\udfed _ :="}
{"gold_output": "theorem IsOpen.inter (s t : Set \u03b1) : IsOpen \u03b1 s \u2192 IsOpen \u03b1 t \u2192 IsOpen \u03b1 (s \u2229 t) :=", "model_response": "lemma isometry_to_conjugate_space[simp]: \\<open>isometry to_conjugate_space\\<close>"}
{"gold_output": "theorem disjoint_cylinder_of_longestPrefix_lt {s : Set (\u2200 n, E n)} (hs : IsClosed s) {x : \u2200 n, E n}\n(hx : x \u2209 s) {n : \u2115} (hn : longestPrefix x s < n) : Disjoint s (cylinder x n) :=", "model_response": "lemma closed_cylinder: \"closed {y \\<in> space E. (take n y = take n x)}\""}
{"gold_output": "theorem forall_congr' {p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} (f : \u03b1 \u2243 \u03b2)\n(h : \u2200 {x}, p (f.symm x) \u2194 q x) : (\u2200 x, p x) \u2194 \u2200 y, q y :=", "model_response": "lemma surj_iff_surj_of_equiv: \"(\\<forall>x. p x) \\<longleftrightarrow> (\\<forall>y. q y)\" if \"(\\<forall>x. p (f.symm x) \\<longleftrightarrow> q x)\""}
{"gold_output": "theorem inf_le_of_le {b : \u03b2} (hb : b \u2208 s) (h : f b \u2264 a) : s.inf f \u2264 a :=", "model_response": "lemma inf_le: \"s.inf f \\<le> a\" if \"b \\<in> s\" \"f b \\<le> a\""}
{"gold_output": "theorem const.get_mk (x : A) : const.get (const.mk n x : (const n A).Obj \u03b1) = x :=", "model_response": "lemma const_comp_mk [simp]: \"const n \\<circ> mk = id\""}
{"gold_output": "theorem convex_empty : Convex \ud835\udd5c (\u2205 : Set E) :=", "model_response": "lemma convexHull_singleton_zero : \"convexHull \ud835\udd5c {0} = {0}\""}
{"gold_output": "theorem Matrix.toBilin'_symm :\n(Matrix.toBilin'.symm : _ \u2243\u2097[R\u2082] Matrix n n R\u2082) = BilinForm.toMatrix' :=", "model_response": "lemma BilinForm.toMatrix'_equiv_symm :\n\"(Matrix.toBilin'.equiv R\u2082).symm = BilinForm.toMatrix'\""}
{"gold_output": "theorem HasFDerivAt.const_rpow (hf : HasFDerivAt f f' x) (hc : 0 < c) :\nHasFDerivAt (fun x => c ^ f x) ((c ^ f x * Real.log c) \u2022 f') x :=", "model_response": "lemma has_fderiv_pow_const_real [simp]:\n\"((\\<lambda>x. (x::real) ^ n) has_fderiv_at x) ((n : \u211d) * x ^ (n - Suc 0) * f')\""}
{"gold_output": "theorem sup_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)] (a b c : \u03b1) : (a \u2294 b) * c = a * c \u2294 b * c :=", "model_response": "lemma toIcoMod_inj: \"toIcoMod hp a c = toIcoMod hp b c  \\<longleftrightarrow> a mod hp = b mod hp\""}
{"gold_output": "theorem image_upperBounds_subset_upperBounds_image : f '' upperBounds s \u2286 upperBounds (f '' s) :=", "model_response": "lemma image_Iic_subset_Iic_image : \"f ` Iic a \\<subseteq> Iic (f a)\""}
{"gold_output": "theorem const (b : \u03b2) : LipschitzWith 0 fun _ : \u03b1 => b :=", "model_response": "lemma const_mem_lipschitzWith [simp, lipschitz_intros]: \"(\\<lambda>_. b) \\<in> lipschitzWith 0 \u03b1 \u03b2\""}
{"gold_output": "theorem integral_comp_rpow_Ioi_of_pos {g : \u211d \u2192 E} {p : \u211d} (hp : 0 < p) :\n(\u222b x in Ioi 0, (p * x ^ (p - 1)) \u2022 g (x ^ p)) = \u222b y in Ioi 0, g y :=", "model_response": "lemma integral_comp_rpow_Ioi_of_pos [simp]:\n\"(\u222b x in Ioi 0, (p * x ^ (p - 1)) \u2022 g (x ^ p)) = \u222b y in Ioi 0, g y\""}
{"gold_output": "theorem binaryProductLimitCone_cone_\u03c0_app_left (G H : AddCommGroupCat.{u}) :\n(binaryProductLimitCone G H).cone.\u03c0.app \u27e8WalkingPair.left\u27e9 = AddMonoidHom.fst G H :=", "model_response": "lemma binaryProductLimitCone_fst (G H : AddCommGroupCat.{u}) :\nbinaryProductLimitCone.\u03c0 G H \u226b binaryProductLimitCone.inl G H = AddMonoidHom.id G :="}
{"gold_output": "theorem pi_le_iff [DecidableEq \u03b7] [Finite \u03b7] {H : \u2200 i, Subgroup (f i)} {J : Subgroup (\u2200 i, f i)} :\npi univ H \u2264 J \u2194 \u2200 i : \u03b7, map (MonoidHom.single f i) (H i) \u2264 J :=", "model_response": "lemma single_inj [simp]: \"single i a = single i b \\<longleftrightarrow> a = b\""}
{"gold_output": "theorem reverse_take {\u03b1} {xs : List \u03b1} (n : \u2115) (h : n \u2264 xs.length) :\nxs.reverse.take n = (xs.drop (xs.length - n)).reverse :=", "model_response": "lemma take_append_eq_append_take:\nassumes \"n \\<le> xs.length\" \"m \\<le> ys.length\"\nshows \"(xs @ ys).take n = xs.take (n - m) @ ys.take m\""}
{"gold_output": "theorem exist_unique_vadd_mem_fundamentalDomain [Finite \u03b9] (x : E) :\n\u2203! v : span \u2124 (Set.range b), v +\u1d65 x \u2208 fundamentalDomain b :=", "model_response": "lemma fundamentalDomain_subset_fundamentalAntiDomain:\n\"fundamentalDomain b \\<subseteq> fundamentalAntiDomain b\""}
{"gold_output": "theorem HasBasis.forall_mem_mem (h : HasBasis l p s) {x : \u03b1} :\n(\u2200 t \u2208 l, x \u2208 t) \u2194 \u2200 i, p i \u2192 x \u2208 s i :=", "model_response": "lemma continuous_at_def:\n\"continuous (at x) f \\<longleftrightarrow> (\\<forall>S. open S \\<and> f x \\<in> S \\<longrightarrow> (\\<exists>T. open T \\<and> x \\<in> T \\<and> (\\<forall>y\\<in>T. f y \\<in> S)))\""}
{"gold_output": "theorem transAssocReparamAux_zero : transAssocReparamAux 0 = 0 :=", "model_response": "lemma transAssocReparamAux_one : \"transAssocReparamAux 1 = 1\""}
{"gold_output": "theorem setToL1_lipschitz (hT : DominatedFinMeasAdditive \u03bc T C) :\nLipschitzWith (Real.toNNReal C) (setToL1 hT) :=", "model_response": "lemma lipschitz_setToL1 (hT : DominatedFinMeasAdditive \u03bc T C) :\nLipschitzWith (Real.toNNReal C) (setToL1 hT) :="}
{"gold_output": "theorem mem_compl_image [BooleanAlgebra \u03b1] (t : \u03b1) (S : Set \u03b1) :\nt \u2208 HasCompl.compl '' S \u2194 t\u1d9c \u2208 S :=", "model_response": "lemma setOf_le_eq: \"{x. x \\<le> a} = {x. x \\<le> b}\""}
{"gold_output": "theorem add_lf_add_of_le_of_lf {w x y z : PGame} (hwx : w \u2264 x) (hyz : y \u29cf z) : w + y \u29cf x + z :=", "model_response": "lemma sum_left_options_eq_sum_right_options: \"sum (left_options x) = sum (right_options (-x))\""}
{"gold_output": "theorem ComponentCompl.mem_supp_iff {v : V} {C : ComponentCompl G K} :\nv \u2208 C \u2194 \u2203 vK : v \u2209 K, G.componentComplMk vK = C :=", "model_response": "lemma supp_componentCompl_eq :\n\"supp (C : ComponentCompl G K) = { v | vK : v \u2209 K . G.componentComplMk vK = C }\""}
{"gold_output": "theorem cokernelIsoOfEq_trans {f g h : X \u27f6 Y} [HasCokernel f] [HasCokernel g] [HasCokernel h]\n(w\u2081 : f = g) (w\u2082 : g = h) :\ncokernelIsoOfEq w\u2081 \u226a\u226b cokernelIsoOfEq w\u2082 = cokernelIsoOfEq (w\u2081.trans w\u2082) :=", "model_response": "lemma cokernelIsoOfEq_comp:\n\"cokernelIsoOfEq w\u2081 \u226a\u226b cokernelIsoOfEq w\u2082 = cokernelIsoOfEq (w\u2081.comp w\u2082)\""}
{"gold_output": "theorem limit_map_limitObjIsoLimitCompEvaluation_hom [HasLimitsOfShape J C] {i j : K}\n(F : J \u2964 K \u2964 C) (f : i \u27f6 j) : (limit F).map f \u226b (limitObjIsoLimitCompEvaluation _ _).hom =\n(limitObjIsoLimitCompEvaluation _ _).hom \u226b limMap (whiskerLeft _ ((evaluation _ _).map f)) :=", "model_response": "lemma limit.map_limitObjIsoLimitCompEvaluation:\n\"limit.map F f \u226b (limitObjIsoLimitCompEvaluation _ _).hom =\n(limitObjIsoLimitCompEvaluation _ _).hom \u226b limMap (whiskerLeft _ ((evaluation _ _).map f))\""}
{"gold_output": "theorem \u03b9_gluedIso_hom (i : D.J) : F.map (D.\u03b9 i) \u226b (D.gluedIso F).hom = (D.mapGlueData F).\u03b9 i :=", "model_response": "lemma \u03b9_gluedIso_hom: \"F.map (D.\u03b9 i) \u226b (D.gluedIso F).hom = (D.mapGlueData F).\u03b9 i\""}
{"gold_output": "theorem Ioi_inter_Iio : Ioi a \u2229 Iio b = Ioo a b :=", "model_response": "lemma Ioi_inter_Iio_eq_Ioo : \"{a <..< b} = Ioi a \u2229 Iio b :="}
{"gold_output": "theorem tan_eq_of_two_zsmul_eq {\u03b8 \u03c8 : Angle} (h : (2 : \u2124) \u2022 \u03b8 = (2 : \u2124) \u2022 \u03c8) : tan \u03b8 = tan \u03c8 :=", "model_response": "lemma tan_eq_iff_exists_int {\u03b8 \u03c8 : Angle} :\ntan \u03b8 = tan \u03c8 \u2194 (\u2203 k : \u2124, \u03b8 = \u03c8 + (k : \u211d) * \u03c0 / 2) \u2228 \u03b8 = -\u03c8 + (2 * k + 1) * \u03c0 / 2 :="}
{"gold_output": "theorem mem_ae_map_iff {f : \u03b1 \u2192 \u03b2} (hf : AEMeasurable f \u03bc) {s : Set \u03b2} (hs : MeasurableSet s) :\ns \u2208 (\u03bc.map f).ae \u2194 f \u207b\u00b9' s \u2208 \u03bc.ae :=", "model_response": "lemma aemeasurable_restrict_iff:\n\"f \\<in> aemeasurable (\u03bc.restrict s) \u2194 f \u207b\u00b9' s \\<in> \u03bc.ae\""}
{"gold_output": "theorem toIcoDiv_sub_zsmul' (a b : \u03b1) (m : \u2124) : toIcoDiv hp (a - m \u2022 p) b = toIcoDiv hp a b + m :=", "model_response": "lemma toIcoDiv_sub: \"toIcoDiv hp a b = toIcoDiv hp a (b - p)\""}
{"gold_output": "theorem PseudoMetricSpace.replaceUniformity_eq {\u03b1} [U : UniformSpace \u03b1] (m : PseudoMetricSpace \u03b1)\n(H : \ud835\udce4[U] = \ud835\udce4[PseudoEMetricSpace.toUniformSpace]) : m.replaceUniformity H = m :=", "model_response": "lemma uniformity_metrizable_eq_pseudo_uniformity [simp]:\n\"\ud835\udce4(MetricSpace.metrizable m) = \ud835\udce4 m\""}
{"gold_output": "theorem ker_fst : ker (fst R M M\u2082) = range (inr R M M\u2082) :=", "model_response": "lemma fst_comp_inl : (inl R M M\u2082).comp (fst R M M\u2082) = id R M :="}
{"gold_output": "theorem isTorsion_iff_isTorsion_int [AddCommGroup M] :\nAddMonoid.IsTorsion M \u2194 Module.IsTorsion \u2124 M :=", "model_response": "lemma commutes_subset_zmultiples_singleton : commutes g = (zmultiples {g} : Set M) :="}
{"gold_output": "theorem StrictMono.monotone (hf : StrictMono f) : Monotone f :=", "model_response": "lemma (in order_topology) monotone: \"monotone f\""}
{"gold_output": "theorem Right.mul_lt_mul [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 \u2264 \u00b7)]\n[CovariantClass \u03b1 \u03b1 (swap (\u00b7 * \u00b7)) (\u00b7 < \u00b7)] {a b c d : \u03b1}\n(h\u2081 : a < b) (h\u2082 : c < d) :\na * c < b * d :=", "model_response": "lemma toIcoMod_inj:\n\"toIcoMod hp a b = toIcoMod hp c d \\<longleftrightarrow>\n[a = c] (mod hp) \\<and> [b = d] (mod hp)\""}
{"gold_output": "theorem linearIndependent_le_span' {\u03b9 : Type _} (v : \u03b9 \u2192 M) (i : LinearIndependent R v) (w : Set M)\n[Fintype w] (s : range v \u2264 span R w) : (#\u03b9) \u2264 Fintype.card w :=", "model_response": "lemma card_fun_eq_card_basis: \"card (\u03b9 \u2192 R) = card \u03b9\""}
{"gold_output": "theorem _root_.Subalgebra.fg_bot_toSubmodule {R A : Type _} [CommSemiring R] [Semiring A]\n[Algebra R A] : (\u22a5 : Subalgebra R A).toSubmodule.FG :=", "model_response": "lemma fg_bot : (\u22a5 : Subalgebra R A).toSubmodule.FG :="}
{"gold_output": "theorem norm_injOn_ray_left (hx : x \u2260 0) : { y | SameRay \u211d x y }.InjOn norm :=", "model_response": "lemma norm_neg (x : E) : norm (- x) = norm x :="}
{"gold_output": "theorem isMaxOn_const {b : \u03b2} : IsMaxOn (fun _ => b) s a :=", "model_response": "lemma continuousWithinAt_iff_continuousAt:\n\"continuousWithinAt f s a \\<longleftrightarrow> continuousAt f a\""}
{"gold_output": "theorem contDiffOn_succ_of_fderivWithin {n : \u2115} (hf : DifferentiableOn \ud835\udd5c f s)\n(h : ContDiffOn \ud835\udd5c n (fun y => fderivWithin \ud835\udd5c f s y) s) : ContDiffOn \ud835\udd5c (n + 1 : \u2115) f s :=", "model_response": "lemma contDiffOn_succ_iff_fderivWithin:\n\"contDiffOn \ud835\udd5c (n + 1 : \u2115) f s \\<longleftrightarrow>\nDifferentiableOn \ud835\udd5c f s \\<and> ContDiffOn \ud835\udd5c n (fun y => fderivWithin \ud835\udd5c f s y) s\""}
{"gold_output": "theorem add_le_add_iff_left' {s t u : Multiset \u03b1} : s + t \u2264 s + u \u2194 t \u2264 u :=", "model_response": "lemma sum_map_le_sum_map_iff:\n\\<open>sum (map f l) \\<le> sum (map f l') \\<longleftrightarrow> mset l \\<le> mset l'\\<close>"}
{"gold_output": "theorem coe_none : (@Option.none \u03b1 : Part \u03b1) = none :=", "model_response": "theorem coe_some : ((some : Option \u03b1) : Part \u03b1) = some :="}
{"gold_output": "theorem lintegral_Lp_add_le_aux {p q : \u211d} (hpq : p.IsConjugateExponent q) {f g : \u03b1 \u2192 \u211d\u22650\u221e}\n(hf : AEMeasurable f \u03bc) (hf_top : (\u222b\u207b a, f a ^ p \u2202\u03bc) \u2260 \u22a4) (hg : AEMeasurable g \u03bc)\n(hg_top : (\u222b\u207b a, g a ^ p \u2202\u03bc) \u2260 \u22a4) (h_add_zero : (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2260 0)\n(h_add_top : (\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) \u2260 \u22a4) :\n(\u222b\u207b a, (f + g) a ^ p \u2202\u03bc) ^ (1 / p) \u2264\n(\u222b\u207b a, f a ^ p \u2202\u03bc) ^ (1 / p) + (\u222b\u207b a, g a ^ p \u2202\u03bc) ^ (1 / p) :=", "model_response": "lemma integrable_Lp_iff [simp]:\n\"integrable M (\\<lambda>x. f x ^ p) \\<longleftrightarrow> integrable M f\""}
{"gold_output": "theorem sInter_union (S T : Set (Set \u03b1)) : \u22c2\u2080 (S \u222a T) = \u22c2\u2080 S \u2229 \u22c2\u2080 T :=", "model_response": "lemma Iic_inter_Ici_self : Iic a \\<inter> Ici a = {a} :="}
{"gold_output": "theorem conj_orthogonalProjection {T : E \u2192L[\ud835\udd5c] E} (hT : IsSelfAdjoint T) (U : Submodule \ud835\udd5c E)\n[CompleteSpace U] :\nIsSelfAdjoint\n(U.subtypeL \u2218L orthogonalProjection U \u2218L T \u2218L U.subtypeL \u2218L orthogonalProjection U) :=", "model_response": "lemma orthogonalProjection_comp_selfadjoint_eq_subtypeL_comp:\n\"U.subtypeL \u2218L orthogonalProjection U \u2218L T \u2218L U.subtypeL \u2218L orthogonalProjection U =\nU.subtypeL \u2218L orthogonalProjection U\""}
{"gold_output": "theorem nonnegg_comm {c d : \u2115} {x y : \u2124} : Nonnegg c d x y = Nonnegg d c y x :=", "model_response": "lemma nonnegg_comm :\nassumes \"Nonnegg c d x y\"\nshows \"Nonnegg d c y x\""}
{"gold_output": "theorem ofLex_natCast [NatCast \u03b1] (n : \u2115) : (ofLex n : \u03b1) = n :=", "model_response": "lemma ofLex_strictMono [simp]: \"StrictMono ofLex\""}
{"gold_output": "theorem image_parallelepiped (f : E \u2192\u2097[\u211d] F) (v : \u03b9 \u2192 E) :\nf '' parallelepiped v = parallelepiped (f \u2218 v) :=", "model_response": "lemma image_parallelepiped_Icc [simp]:\n\"f '' parallelepiped (Icc a b) = parallelepiped (Icc (f a) (f b))\""}
{"gold_output": "theorem preimage_mul_const_Iio (a : \u03b1) {c : \u03b1} (h : 0 < c) :\n(fun x => x * c) \u207b\u00b9' Iio a = Iio (a / c) :=", "model_response": "lemma preimage_mul_const_Iio' [simp]: \"(\\<lambda>x => x * c) \u207b\u00b9' Iio a = Iio (a / c)\""}
{"gold_output": "theorem assoc_symm_tmul (m : M) (n : N) (p : P) :\n(TensorProduct.assoc R M N P).symm (m \u2297\u209c (n \u2297\u209c p)) = m \u2297\u209c n \u2297\u209c p :=", "model_response": "lemma assoc'_inv_tmul (m : M) (n : N) (p : P) :\n(TensorProduct.assoc R M N P).symm (m \u2297\u209c (n \u2297\u209c p)) = m \u2297\u209c n \u2297\u209c p :="}
{"gold_output": "theorem eq_zero_of_dvd_of_div_eq_zero {a b : \u2115} (w : a \u2223 b) (h : b / a = 0) : b = 0 :=", "model_response": "lemma card_fintype_dvd_helper:\nassumes \"a dvd b\"\nshows \"Fintype.card (Fin b) \u2264 Fintype.card (Fin a)\""}
{"gold_output": "theorem Monic.map [Semiring S] (f : R \u2192+* S) (hp : Monic p) : Monic (p.map f) :=", "model_response": "lemma degree_map [simp]: \"degree (p.map f) = degree p\""}
{"gold_output": "theorem fract_eq_fract (m n : E) : fract b m = fract b n \u2194 -m + n \u2208 span \u2124 (Set.range b) :=", "model_response": "lemma fract_eq_zero_iff_int_mul: \"fract b m = 0 \u2194 \u2203 k : \u2124, m = k * b\""}
{"gold_output": "theorem sup_le : a \u2264 c \u2192 b \u2264 c \u2192 a \u2294 b \u2264 c :=", "model_response": "lemma sup_comm : a \u2294 b = b \u2294 a :="}
{"gold_output": "theorem mem_vectorSpan_iff_eq_weightedVSub {v : V} {p : \u03b9 \u2192 P} :\nv \u2208 vectorSpan k (Set.range p) \u2194\n\u2203 (s : Finset \u03b9) (w : \u03b9 \u2192 k) (_ : (\u2211 i in s, w i) = 0), v = s.weightedVSub p w :=", "model_response": "lemma linear_iff_add: \"linear f \u2194 \u2200 x y, f (x + y) = f x + f y\""}
{"gold_output": "theorem Filter.EventuallyEq.eventuallyEq_nhds {f g : \u03b1 \u2192 \u03b2} {a : \u03b1} (h : f =\u1da0[\ud835\udcdd a] g) :\n\u2200\u1da0 y in \ud835\udcdd a, f =\u1da0[\ud835\udcdd y] g :=", "model_response": "lemma continuous_iff_eventually_eq_nhds {f : \u03b1 \u2192 \u03b2} {x : \u03b1} :\nContinuous f x \u2194 f =\u1da0[\ud835\udcdd x] f :="}
{"gold_output": "theorem vsub_iInter_subset (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s -\u1d65 \u22c2 i, t i) \u2286 \u22c2 i, s -\u1d65 t i :=", "model_response": "lemma finite_Nsetn:\"finite {i. i \\<le> n}\""}
{"gold_output": "theorem exp_conj : exp (conj x) = conj (exp x) :=", "model_response": "lemma exp_add_ofReal : \"exp (x + ofReal r) = exp x * exp r\""}
{"gold_output": "theorem mem_closedBall_self : x \u2208 closedBall x \u03b5 :=", "model_response": "lemma toIcoMod_eq_self: \"toIcoMod hp a a = a\""}
{"gold_output": "theorem NullMeasurableSet.fundamentalInterior (hs : NullMeasurableSet s \u03bc) :\nNullMeasurableSet (fundamentalInterior G s) \u03bc :=", "model_response": "theorem fundamentalInterior_subset: \"fundamentalInterior G s \\<subseteq> s\""}
{"gold_output": "theorem preimage_Ico {a b : \u03b1} : (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Ico a b = Set.Ico \u2308a\u2309\u208a \u2308b\u2309\u208a :=", "model_response": "lemma preimage_Ioi : (Nat.cast : \u2115 \u2192 \u03b1) \u207b\u00b9' Set.Ioi a = Set.Ioi \u2308a\u2309\u208a :="}
{"gold_output": "theorem cycleRange_of_lt {n : \u2115} {i j : Fin n.succ} (h : j < i) : cycleRange i j = j + 1 :=", "model_response": "lemma toZ_inj {i0 i j : Fin n.succ} (h : j < i) : toZ i0 i = toZ i0 j \u2194 i = j :="}
{"gold_output": "theorem iInf_le (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : iInf f \u2264 f i :=", "model_response": "lemma iInf_le_of_mem: \"(\u2a05 (i) (_ : i \u2208 s), f i) \u2264 f i\""}
{"gold_output": "theorem single_mem_gradeBy {R} [CommSemiring R] (f : M \u2192 \u03b9) (m : M) (r : R) :\nFinsupp.single m r \u2208 gradeBy R f (f m) :=", "model_response": "lemma gradeBy_apply_eq_iff [simp]:\n\"gradeBy R f (f m) = gradeBy R f (f n) \u2194 f m = f n\""}
{"gold_output": "theorem image_surjective : Surjective (image f) \u2194 Surjective f :=", "model_response": "lemma image_eq_iff_surjOn : (f '' s = f '' t) = SurjOn f s t :="}
{"gold_output": "theorem walkingParallelPairOp_zero : walkingParallelPairOp.obj zero = op one :=", "model_response": "lemma fst_comp_fst : \"fst \\<cdot> C.fst = C.id\""}
{"gold_output": "theorem map_unique {f : \u03b1 \u2192 \u03b2} (hf : UniformContinuous f)\n{g : SeparationQuotient \u03b1 \u2192 SeparationQuotient \u03b2}\n(comm : Quotient.mk _ \u2218 f = g \u2218 Quotient.mk _) : map f = g :=", "model_response": "lemma toQuotient_ofQuotient_eq: \"toQuotient \\<circ> ofQuotient = f\""}
{"gold_output": "theorem nontrivial_iff_exists_lt [LinearOrder \u03b1] :\ns.Nontrivial \u2194 \u2203 (x : \u03b1) (_ : x \u2208 s) (y : \u03b1) (_ : y \u2208 s), x < y :=", "model_response": "lemma nontrivial_iff_exists_lt [simp]:\n\"(nontrivial {x \\<in> s. x < a}) = (\\<exists>x\\<in>s. x < a)\""}
{"gold_output": "theorem hom_lift (h : IsLimit t) {W : C} (m : W \u27f6 t.pt) :\nm = h.lift { pt := W, \u03c0 := { app := fun b => m \u226b t.\u03c0.app b } } :=", "model_response": "lemma \u03c0_eq_lift (h : IsLimit t) {W : C} (m : W \u27f6 t.pt) :\nt.\u03b9 \u226b \u03c0 t = h.lift { pt := W, \u03c0 := { app := fun b => m \u226b t.\u03c0.app b } } (by rw [h.eq]) :="}
{"gold_output": "theorem count_pos {a : \u03b1} {s : Multiset \u03b1} : 0 < count a s \u2194 a \u2208 s :=", "model_response": "lemma count_pos_iff_mem [simp]:\nshows \"0 < count a s \\<longleftrightarrow> a \\<in> s\""}
{"gold_output": "theorem isCodetecting_unop_iff {\ud835\udca2 : Set C\u1d52\u1d56} : IsCodetecting \ud835\udca2.unop \u2194 IsDetecting \ud835\udca2 :=", "model_response": "theorem isSheaf_op [simp]: \"Presheaf.IsSheaf J (op F) \\<longleftrightarrow> Presheaf.IsSheaf J F\""}
{"gold_output": "theorem basicOpen_mul_le_left (f g : R) : basicOpen (f * g) \u2264 basicOpen f :=", "model_response": "lemma basicOpen_mul_le_left:\n\"basicOpen (f * g) \\<le> basicOpen f\""}
{"gold_output": "theorem cond_self.{u} {\u03b1 : Type u} (b : Bool) (a : \u03b1) : cond b a a = a :=", "model_response": "lemma cond_eq_self:\nshows \"cond b a a = a\""}
{"gold_output": "theorem isAntisymm (h : IsAntichain r univ) : IsAntisymm \u03b1 r :=", "model_response": "lemma is_zero_divisor_of_forall_le_zero :\nassumes \"\\<And>b. b \\<in> M \\<Longrightarrow> a \\<le> b \\<Longrightarrow> a * b = 0\"\nshows \"is_zero_divisor a\""}
{"gold_output": "theorem coe_iInf {\u03b9 : Sort _} [CompleteLattice \u03b2] (f : \u03b9 \u2192 \u03b1 \u2192o \u03b2) :\n((\u2a05 i, f i : \u03b1 \u2192o \u03b2) : \u03b1 \u2192 \u03b2) = \u2a05 i, (f i : \u03b1 \u2192 \u03b2) :=", "model_response": "lemma toDual_strictMono : \"strictMono toDual\""}
{"gold_output": "theorem infinitePos_def {x : \u211d*} : InfinitePos x \u2194 \u2200 r : \u211d, \u2191r < x :=", "model_response": "lemma abs_re_lt_abs_iff_imaginary: \"abs (re z) < abs z  \\<longleftrightarrow> (im z \\<noteq> 0)\""}
{"gold_output": "theorem toList_map (f : \u03b1 \u2192 \u03b2) (xs : t \u03b1) : toList (f <$> xs) = f <$> toList xs :=", "model_response": "lemma inj_on_coe [simp]:\n\"inj_on f (set xs) \\<longleftrightarrow> inj_on f (mset xs)\""}
{"gold_output": "theorem coeFn_add (\u03ba \u03b7 : kernel \u03b1 \u03b2) : \u21d1(\u03ba + \u03b7) = \u03ba + \u03b7 :=", "model_response": "lemma add_apply [simp]: \"(kernel.sum \u03ba \u03b7) (x, y) = \u03ba (x, y) + \u03b7 (x, y)\""}
{"gold_output": "theorem Measure.QuasiMeasurePreserving.ae_eq_comp {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b2} {g g' : \u03b2 \u2192 \u03b4}\n(hf : QuasiMeasurePreserving f \u03bc \u03bd) (h : g =\u1d50[\u03bd] g') : g \u2218 f =\u1d50[\u03bc] g' \u2218 f :=", "model_response": "lemma ae_eq_toMeasure_comp_iff {\u03bd : Measure \u03b2} {f : \u03b1 \u2192 \u03b2} {g g' : \u03b2 \u2192 \u03b4} :\n(toMeasure \u2218 f : \u03b1 \u2192 \u03b4) =\u1d50[\u03bc] (toMeasure \u2218 g : \u03b1 \u2192 \u03b4) \u2194 f =\u1d50[\u03bc] g :="}
{"gold_output": "theorem mem_of_finset_sum_eq_one_of_pow_smul_mem {S : Type _} [CommRing S] [Algebra R S]\n(S' : Subalgebra R S) {\u03b9 : Type _} (\u03b9' : Finset \u03b9) (s : \u03b9 \u2192 S) (l : \u03b9 \u2192 S)\n(e : (\u2211 i in \u03b9', l i * s i) = 1) (hs : \u2200 i, s i \u2208 S') (hl : \u2200 i, l i \u2208 S') (x : S)\n(H : \u2200 i, \u2203 n : \u2115, (s i ^ n : S) \u2022 x \u2208 S') : x \u2208 S' :=", "model_response": "lemma toFun_add:\n\"toFun (f + g :: \u03b1 \u2192\u1d47 \u03b2) = toFun f + toFun g\""}
{"gold_output": "theorem constantCoeff_wittSub (n : \u2115) : constantCoeff (wittSub p n) = 0 :=", "model_response": "lemma coeff_wittSub_zero [simp]: \"coeff (wittSub p) 0 = wittSub_pw.coeff 0\""}
{"gold_output": "theorem WithSeminorms.T1_of_separating (hp : WithSeminorms p)\n(h : \u2200 x, x \u2260 0 \u2192 \u2203 i, p i x \u2260 0) : T1Space E :=", "model_response": "lemma continuous_at_iff:\n\"continuous (at x) f \\<longleftrightarrow> (\\<forall>\u03b5>0. \\<exists>\u03b4>0. \\<forall>y. dist y x < \u03b4 \\<longrightarrow> dist (f y) (f x) < \u03b5)\""}
{"gold_output": "theorem arccos_lt_pi_div_two {x : \u211d} : arccos x < \u03c0 / 2 \u2194 0 < x :=", "model_response": "lemma arccos_le_arccos_iff {x y : \u211d} : arccos x \u2264 arccos y \u2194 y \u2264 x :="}
{"gold_output": "theorem pow_add (_ : a ^ b\u2081 = c\u2081) (_ : a ^ b\u2082 = c\u2082) (_ : c\u2081 * c\u2082 = d) :\n(a : R) ^ (b\u2081 + b\u2082) = d :=", "model_response": "lemma differentiableAt_add_const_iff (c : F) :\nDifferentiableAt \ud835\udd5c (fun y => f y + c) x \u2194 DifferentiableAt \ud835\udd5c f x :="}
{"gold_output": "theorem norm_sup_sub_sup_le_norm (x y z : \u03b1) : \u2016x \u2294 z - y \u2294 z\u2016 \u2264 \u2016x - y\u2016 :=", "model_response": "lemma norm_sup_sub_sup_le_norm:\n\"norm (x \u2294 z - y \u2294 z) \\<le> norm (x - y)\""}
{"gold_output": "theorem bit0_succ_eq (n : \u2115) : bit0 (succ n) = succ (succ (bit0 n)) :=", "model_response": "lemma bit0_succ_bit0:\nshows \"bit0 (succ n) = succ (succ (bit0 n))\""}
{"gold_output": "theorem eq_smul_exp_of_invertible (x : tsze R M) [Invertible x.fst] :\nx = x.fst \u2022 exp \ud835\udd5c (\u215f x.fst \u2022 inr x.snd) :=", "model_response": "lemma exp_add: \"exp \ud835\udd5c (a + b) = exp \ud835\udd5c a * exp \ud835\udd5c b\""}
{"gold_output": "theorem coe_compLinearMap (f : AlternatingMap R M N \u03b9) (g : M\u2082 \u2192\u2097[R] M) :\n\u21d1(f.compLinearMap g) = f \u2218 (\u00b7 \u2218 \u00b7) g :=", "model_response": "lemma compLinearMap_neg (f : AlternatingMap R M N \u03b9) (g : M\u2082 \u2192\u2097[R] M) :\n\u21d1(-f.compLinearMap g) = -f \u2218 (\u00b7 \u2218 \u00b7) g :="}
{"gold_output": "theorem div_singleton (a : \u03b1) : s / {a} = s.image (\u00b7 / a) :=", "model_response": "lemma div_singleton_eq_image : \"s / {a} = s.image (\u00b7 / a)\""}
{"gold_output": "theorem IsOpen.smul\u2080 {c : G\u2080} {s : Set \u03b1} (hs : IsOpen s) (hc : c \u2260 0) : IsOpen (c \u2022 s) :=", "model_response": "lemma continuousAt_toMulBot: \"ContinuousAt toMulBot x\""}
{"gold_output": "theorem tsub_add_eq_add_tsub (h : b \u2264 a) : a - b + c = a + c - b :=", "model_response": "lemma tsub_add_eq_add_tsub_rev :\nassumes \"b \\<le> a\"\nshows \"a - b + c = a + c - b\""}
{"gold_output": "theorem ContinuousLinearMap.fderiv : fderiv \ud835\udd5c e x = e :=", "model_response": "lemma fderiv_apply [simp]: \"fderiv \ud835\udd5c (\\<lambda>x. e x) x = e\""}
{"gold_output": "theorem dist_eq_add_dist_iff_angle_eq_pi {p1 p2 p3 : P} (hp1p2 : p1 \u2260 p2) (hp3p2 : p3 \u2260 p2) :\ndist p1 p3 = dist p1 p2 + dist p3 p2 \u2194 \u2220 p1 p2 p3 = \u03c0 :=", "model_response": "lemma dist_eq_add_dist_iff_angle_eq_pi {p1 p2 p3 : P} (hp1p2 : p1 \u2260 p2) (hp3p2 : p3 \u2260 p2) :\ndist p1 p3 = dist p1 p2 + dist p3 p2 \u2194 \u2220 p1 p2 p3 = \u03c0 :="}
{"gold_output": "theorem coe_nonempty (s : NonemptyInterval \u03b1) : (s : Set \u03b1).Nonempty :=", "model_response": "lemma setOf_eq_iff {p q : \u03b1 \u2192 Prop} : { x | p x } = { x | q x } \u2194 \u2200 x, p x \u2194 q x :="}
{"gold_output": "theorem le_comap_top (f : \u03b1 \u2192 \u03b2) (l : Filter \u03b1) : l \u2264 comap f \u22a4 :=", "model_response": "lemma monotone_comap: \"monotone (comap f)\""}
{"gold_output": "theorem toAddMonoid.unique (f : \u2a01 i, \u03b2 i) : \u03c8 f = toAddMonoid (fun i => \u03c8.comp (of \u03b2 i)) f :=", "model_response": "lemma iso_inj: \"inj \\<psi>\""}
{"gold_output": "theorem exists_mem_target {p : \u03b2 \u2192 Prop} : (\u2203 y \u2208 e.target, p y) \u2194 \u2203 x \u2208 e.source, p (e x) :=", "model_response": "lemma continuous_on_source: \"continuous_on e.source e\""}
{"gold_output": "theorem add (h\u2081 : a \u2261 b [MOD n]) (h\u2082 : c \u2261 d [MOD n]) : a + c \u2261 b + d [MOD n] :=", "model_response": "lemma of_nat_add: \"of_nat (m + n) = (of_nat m + of_nat n : ZMod p)\""}
{"gold_output": "theorem _root_.Inducing.isSeparable_preimage {f : \u03b2 \u2192 \u03b1} [TopologicalSpace \u03b2]\n(hf : Inducing f) {s : Set \u03b1} (hs : IsSeparable s) : IsSeparable (f \u207b\u00b9' s) :=", "model_response": "lemma Inducing.isSeparable_preimage {f : \u03b2 \u2192 \u03b1} [TopologicalSpace \u03b2] (hf : Inducing f) {s : Set \u03b1}\n(hs : IsSeparable s) : IsSeparable (f \u207b\u00b9' s) \u2194 IsSeparable s :="}
{"gold_output": "theorem eq_true_of_and_eq_true_right {a b : Prop} (h : (a \u2227 b) = True) : b = True :=", "model_response": "lemma toBoolRing_inj : (toBoolRing a = toBoolRing b) = (a = b) :="}
{"gold_output": "theorem newton_seq_norm_eq (n : \u2115) :\n\u2016newton_seq (n + 1) - newton_seq n\u2016 =\n\u2016F.eval (newton_seq n)\u2016 / \u2016F.derivative.eval (newton_seq n)\u2016 :=", "model_response": "lemma newton_seq_derivative_norm_eq (n : \u2115) :\n\u2016F.derivative.eval (newton_seq n)\u2016 = \u2016F.derivative.eval (newton_seq n) / F.eval (newton_seq n)\u2016 :="}
{"gold_output": "theorem one_eq_span_one_set : (1 : Submodule R A) = span R 1 :=", "model_response": "lemma support_eq: \"{x \\<in> A. x \\<le> 0} = {x \\<in> A. f x = 0}\""}
{"gold_output": "theorem const' (s : Part \u03c3) : Partrec fun _ : \u03b1 => s :=", "model_response": "lemma const : \"Partrec (\\<lambda>_. s)\""}
{"gold_output": "theorem fuzzy_congr_left {x\u2081 x\u2082 y : PGame} (hx : x\u2081 \u2248 x\u2082) : x\u2081 \u2016 y \u2194 x\u2082 \u2016 y :=", "model_response": "theorem equiv_symmetric : Symmetric {(x, y) | x \\<equiv> y} :="}
{"gold_output": "theorem ext {\u03b1 : Type u} {a b : Thunk \u03b1} (eq : a.get = b.get) : a = b :=", "model_response": "lemma thunk_eqI:\nassumes \"\\<And>f. a.get = Some f \\<Longrightarrow> b.get = Some f\"\nshows \"a = b\""}
{"gold_output": "theorem inr_lt_inr_iff [LT \u03b1] [LT \u03b2] {a b : \u03b2} : (inr a : Sum \u03b1 \u03b2) < inr b \u2194 a < b :=", "model_response": "lemma sum_list_le_sum_list_iff [simp]:\n\"(\\<Sum>x\\<leftarrow>xs. f x) \\<le> (\\<Sum>x\\<leftarrow>xs. g x) \\<longleftrightarrow> (\\<forall>x\\<in>set xs. f x \\<le> g x)\""}
{"gold_output": "theorem _root_.StarAlgHom.ext_topologicalClosure [T2Space B] {S : StarSubalgebra R A}\n{\u03c6 \u03c8 : S.topologicalClosure \u2192\u22c6\u2090[R] B} (h\u03c6 : Continuous \u03c6) (h\u03c8 : Continuous \u03c8)\n(h :\n\u03c6.comp (inclusion (le_topologicalClosure S)) = \u03c8.comp (inclusion (le_topologicalClosure S))) :\n\u03c6 = \u03c8 :=", "model_response": "lemma ofRealAm_eq_ofReal: \"ofRealAm = ofReal\""}
{"gold_output": "theorem antidiagonal_succ_succ' {n : \u2115} :\nantidiagonal (n + 2) =\n(0, n + 2) :: (antidiagonal n).map (Prod.map Nat.succ Nat.succ) ++ [(n + 2, 0)] :=", "model_response": "lemma antidiagonal_0 [simp]: \"antidiagonal 0 = []\""}
{"gold_output": "theorem add_mk_eq_max {\u03b1 \u03b2 : Type _} [Infinite \u03b1] : (#\u03b1) + (#\u03b2) = max (#\u03b1) (#\u03b2) :=", "model_response": "lemma card_sum [simp]: \"CARD('a + 'b) = max CARD('a) CARD('b)\""}
{"gold_output": "theorem Nat.rel_of_forall_rel_succ_of_le_of_lt (r : \u03b2 \u2192 \u03b2 \u2192 Prop) [IsTrans \u03b2 r] {f : \u2115 \u2192 \u03b2} {a : \u2115}\n(h : \u2200 n, a \u2264 n \u2192 r (f n) (f (n + 1))) \u2983b c : \u2115\u2984 (hab : a \u2264 b) (hbc : b < c) :\nr (f b) (f c) :=", "model_response": "lemma rel_of_forall_rel_succ_of_le_of_lt_Suc:\nassumes \"\\<forall>n\\<ge>a. r (f n) (f (n + 1))\"\nand \"b \\<ge> a\" \"b < c\"\nshows \"r (f b) (f c)\""}
{"gold_output": "theorem inter_iInter [Nonempty \u03b9] (s : Set \u03b2) (t : \u03b9 \u2192 Set \u03b2) : (s \u2229 \u22c2 i, t i) = \u22c2 i, s \u2229 t i :=", "model_response": "lemma set_comprehension_iInter_eq [set_comprehension_simps]:\n\"{ x | x \u2208 s, \u2200 i, x \u2208 t i } = s \u2229 \u22c2 i, t i\""}
{"gold_output": "theorem not_mem_map_subtype_of_not_property {p : \u03b1 \u2192 Prop} (s : Finset { x // p x }) {a : \u03b1}\n(h : \u00acp a) : a \u2209 s.map (Embedding.subtype _) :=", "model_response": "lemma inj_on_iff_nodup_image: \"inj_on f s \u2194 (s.image f).Nodup\""}
{"gold_output": "theorem ofFn_zero (f : Fin 0 \u2192 \u03b1) : ofFn f = [] :=", "model_response": "lemma ofFn_zero [simp]: \"ofFn f = []\""}
{"gold_output": "theorem sumProdDistrib_symm_apply_left (a : \u03b1 \u00d7 \u03b3) :\n(sumProdDistrib \u03b1 \u03b2 \u03b3).symm (inl a) = (inl a.1, a.2) :=", "model_response": "lemma sumProdDistrib_inl:\nassumes \"x \\<in> elts (sum \u03b1 \u03b2)\"\nshows \"(sumProdDistrib \u03b1 \u03b2 \u03b3).symm (inl x) = (inl (fst x), snd x)\""}
{"gold_output": "theorem mul_subset_iff_right : s * t \u2286 u \u2194 \u2200 b \u2208 t, op b \u2022 s \u2286 u :=", "model_response": "lemma mul_subset_iff_right : s * t \\<subseteq> u \u2194 \u2200 b \u2208 t, op b \u2022 s \\<subseteq> u :="}
{"gold_output": "theorem le_comap_primeCompl_iff {J : Ideal P} [hJ : J.IsPrime] {f : R \u2192+* P} :\nI.primeCompl \u2264 J.primeCompl.comap f \u2194 J.comap f \u2264 I :=", "model_response": "lemma comap_eq_preimage: { x : M | f x \u2208 I } = f \u207b\u00b9' I :="}
{"gold_output": "theorem iInf_univ {f : \u03b2 \u2192 \u03b1} : (\u2a05 x \u2208 (univ : Set \u03b2), f x) = \u2a05 x, f x :=", "model_response": "lemma iInf_univ_eq_iInf : (\u2a05 x \u2208 (univ : Set \u03b2), f x) = \u2a05 x, f x :="}
{"gold_output": "theorem sub_right (c : \u03b1) (h : a \u2261 b [PMOD p]) : a - c \u2261 b - c [PMOD p] :=", "model_response": "lemma toIcoMod_eq2: \"toIcoMod hp a b = b - (\u2308(b - a) / p\u2309 * p)\""}
{"gold_output": "theorem to_isEvenlyCovered_preimage {x : X} {I : Type _} [TopologicalSpace I]\n(h : IsEvenlyCovered f x I) : IsEvenlyCovered f x (f \u207b\u00b9' {x}) :=", "model_response": "lemma is_partition_of_insert:\nassumes \"f partitions I\" \"x\\<in>I\"\nshows \"f partitions insert x (f -` {x})\""}
{"gold_output": "theorem covering_mem_family {p : \u03b1 \u00d7 Set \u03b1} (hp : p \u2208 h.index) : h.covering p \u2208 v.setsAt p.1 :=", "model_response": "lemma locally_finite_on_union:\n\"locally_finite_on (s \\<union> t) f \\<longleftrightarrow> locally_finite_on s f \\<and> locally_finite_on t f\""}
{"gold_output": "theorem isUnit_map [Field k] (f : R \u2192+* k) : IsUnit (p.map f) \u2194 IsUnit p :=", "model_response": "lemma degree_map [simp]: \"degree (p.map f) = degree p\""}
{"gold_output": "theorem mk'_eq_of_eq' {a\u2081 b\u2081 : R} {a\u2082 b\u2082 : M} (H : b\u2081 * \u2191a\u2082 = a\u2081 * \u2191b\u2082) :\nmk' S a\u2081 a\u2082 = mk' S b\u2081 b\u2082 :=", "model_response": "lemma mk'_inj: \"mk' S a\u2081 a\u2082 = mk' S b\u2081 b\u2082 \\<longleftrightarrow> a\u2081 = b\u2081 \\<and> a\u2082 = b\u2082\""}
{"gold_output": "theorem mk_add_mk [AddZeroClass \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] {x y : \u03b1}\n(hx : 0 \u2264 x) (hy : 0 \u2264 y) :\n(\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x }) + \u27e8y, hy\u27e9 = \u27e8x + y, add_nonneg hx hy\u27e9 :=", "model_response": "lemma toIcoMod_commute: \"toIcoMod hp a b = toIcoMod hp b a\""}
{"gold_output": "theorem untrop_zero [Top R] : untrop (0 : Tropical R) = \u22a4 :=", "model_response": "lemma untrop_mul [simp]:\n\"untrop (a * b) = untrop a * untrop b\" for a b :: R"}
{"gold_output": "theorem TopologicalGroup.of_nhds_one {G : Type u} [Group G] [TopologicalSpace G]\n(hmul : Tendsto (uncurry ((\u00b7 * \u00b7) : G \u2192 G \u2192 G)) (\ud835\udcdd 1 \u00d7\u02e2 \ud835\udcdd 1) (\ud835\udcdd 1))\n(hinv : Tendsto (fun x : G => x\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1))\n(hleft : \u2200 x\u2080 : G, \ud835\udcdd x\u2080 = map (fun x => x\u2080 * x) (\ud835\udcdd 1))\n(hconj : \u2200 x\u2080 : G, Tendsto (fun x => x\u2080 * x * x\u2080\u207b\u00b9) (\ud835\udcdd 1) (\ud835\udcdd 1)) : TopologicalGroup G :=", "model_response": "lemma continuous_div' : Continuous' fun p : G \u00d7 G => p.1 / p.2 :=\n-- Porting note: `continuous_div` is defined as `continuous_div'`, which is not used anywhere."}
{"gold_output": "theorem kroneckerTMul_add (A : Matrix l m \u03b1) (B\u2081 B\u2082 : Matrix n p \u03b1) :\nA \u2297\u2096\u209c[R] (B\u2081 + B\u2082) = A \u2297\u2096\u209c B\u2081 + A \u2297\u2096\u209c B\u2082 :=", "model_response": "lemma of_add: \"of (A + B) = of A + of B\""}
{"gold_output": "theorem coe_le_one (p : Pmf \u03b1) (a : \u03b1) : p a \u2264 1 :=", "model_response": "lemma pmf_of_set_le_one [simp]: \"pmf_of_set s a \u2264 1\""}
{"gold_output": "theorem Antivary.comp_right (h : Antivary f g) (k : \u03b9' \u2192 \u03b9) : Antivary (f \u2218 k) (g \u2218 k) :=", "model_response": "lemma Antivary_dual_comp_right : Antivary (toDual \u2218 f \u2218 k) (g \u2218 k) = Antivary f (toDual \u2218 g \u2218 k) :="}
{"gold_output": "theorem neg (h : Irrational x) : Irrational (-x) :=", "model_response": "theorem gdelta_rat :\n\"Gdelta {x. rat x}\""}
{"gold_output": "theorem preimage_closedBall (x : \u2124) (r : \u211d) : (\u2191) \u207b\u00b9' closedBall (x : \u211d) r = closedBall x r :=", "model_response": "lemma preimage_Iic : (\u2191) \u207b\u00b9' {..a} = Iic (\u230aa\u230b) :="}
{"gold_output": "theorem eval_range {\u03b9 : Type _} [Finite \u03b9] (b : Basis \u03b9 R M) :\nLinearMap.range (Dual.eval R M) = \u22a4 :=", "model_response": "lemma dual_id : \"dual (LinearMap.id : M \u2192\u2097[R] M) = LinearMap.id\""}
{"gold_output": "theorem map_comp {Y\u2081 Y\u2082 Y\u2083 : Type _} (g : Y\u2082 \u2192 Y\u2083) (f : Y\u2081 \u2192 Y\u2082) :\n@map X _ _ _ g \u2218 map f = map (g \u2218 f) :=", "model_response": "lemma map_comp: \"map g \u2218 map f = map (g \u2218 f)\""}
{"gold_output": "theorem hom_ext {W : C} (i j : multicoequalizer I \u27f6 W)\n(h : \u2200 b, Multicoequalizer.\u03c0 I b \u226b i = Multicoequalizer.\u03c0 I b \u226b j) : i = j :=", "model_response": "lemma multicoequalizer.condition:\n\"multicoequalizer.\u03c0 I \u226b multicoequalizer.\u03b9 I = multicoequalizer.\u03b9 I\""}
{"gold_output": "theorem hasDerivAt_of_hasDerivAt_of_ne {f g : \u211d \u2192 E} {x : \u211d}\n(f_diff : \u2200 (y) (_ : y \u2260 x), HasDerivAt f (g y) y) (hf : ContinuousAt f x)\n(hg : ContinuousAt g x) : HasDerivAt f (g x) x :=", "model_response": "lemma hasDerivAt_cexp [simp]:\n\"((\\<lambda>x. Complex.exp (f x)) hasDerivAt (Complex.exp (f x) * g x)) x\""}
{"gold_output": "theorem pointwise_smul_le_iff {a : \u03b1} {S T : AddSubgroup A} : a \u2022 S \u2264 T \u2194 S \u2264 a\u207b\u00b9 \u2022 T :=", "model_response": "lemma setOf_eq_eq_setOf_eq: \"{ x \\<in> A | x \\<in> S \\<and> x = a } = { x \\<in> S | x = a }\""}
{"gold_output": "theorem coe_prod (s : Submonoid M) (t : Submonoid N) :\n(s.prod t : Set (M \u00d7 N)) = (s : Set M) \u00d7\u02e2 (t : Set N) :=", "model_response": "lemma coe_prod : (s.prod t : Set (M \u00d7 N)) = (s : Set M) \u00d7\u02e2 (t : Set N) :="}
{"gold_output": "theorem comp_injective_right (p : Path a b) : Injective (p.comp : Path b c \u2192 Path a c) :=", "model_response": "lemma path_reverse_comp_self (p : Path a b) : (p.reverse \u2218 p : Path b c \u2192 Path b c) = id :="}
{"gold_output": "theorem image_mem_nhds (hf : IsOpenMap f) {x : \u03b1} {s : Set \u03b1} (hx : s \u2208 \ud835\udcdd x) : f '' s \u2208 \ud835\udcdd (f x) :=", "model_response": "lemma image_source_mem_nhds: \"e '' e.source \u2208 \ud835\udcdd (e x)\""}
{"gold_output": "theorem mul_left_cancel (h : IsUnit a) : a * b = a * c \u2192 b = c :=", "model_response": "lemma mul_left_cancel_iff [simp]:\n\"a * b = a * c \u2194 b = c\""}
{"gold_output": "theorem isClosed_biInter {s : Set \u03b2} {f : \u03b2 \u2192 Set \u03b1} (h : \u2200 i \u2208 s, IsClosed (f i)) :\nIsClosed (\u22c2 i \u2208 s, f i) :=", "model_response": "lemma continuous_on_def:\nfixes f :: \"'a::metric_space \\<Rightarrow> 'b::metric_space\"\nshows \"continuous_on s f \\<longleftrightarrow> (\\<forall>x\\<in>s. (f \\<longlongrightarrow> f x) (nhds x))\""}
{"gold_output": "theorem raise'_chain : \u2200 (l) {m n}, m < n \u2192 List.Chain (\u00b7 < \u00b7) m (raise' l n)", "model_response": "lemma raise'_strictMono : \"strictMono (raise' l n)\""}
{"gold_output": "theorem count_erase_self (a : \u03b1) (l : List \u03b1) : count a (List.erase l a) = count a l - 1 :=", "model_response": "lemma count_erase_self_pos :\nassumes \"a \\<in> set l\"\nshows \"0 < count a (List.erase l a)\""}
{"gold_output": "theorem isIntegral_root' (hg : g.Monic) : IsIntegral R (root g) :=", "model_response": "lemma degree_C_mul_root (hg : g.Monic) : (C a * root g).degree = g.degree :="}
{"gold_output": "theorem groupSmul_span_eq_top {G : Type _} [Group G] [DistribMulAction G R] [DistribMulAction G M]\n[IsScalarTower G R M] {v : \u03b9 \u2192 M} (hv : Submodule.span R (Set.range v) = \u22a4) {w : \u03b9 \u2192 G} :\nSubmodule.span R (Set.range (w \u2022 v)) = \u22a4 :=", "model_response": "lemma of_nat_is_hom : \"of_nat \\<in> ring_hom \\<nat> R\""}
{"gold_output": "theorem coe_toEquiv_symm (f : M \u2243* N) : ((f : M \u2243 N).symm : N \u2192 M) = f.symm :=", "model_response": "lemma ofMulEquiv_symm_coe (f : M \u2243* N) : ((ofMulEquiv f).symm : N \u2192 M) = f.symm :="}
{"gold_output": "theorem map_join (f : \u03b1 \u2192 \u03b2) : \u2200 S, map f (join S) = join (map (map f) S)", "model_response": "lemma map_eq_nil_iff :\nassumes \"f (shd s) = None\"\nshows \"map f s = [::] \\<longleftrightarrow> s = [::]\""}
{"gold_output": "theorem differentiable_const (c : F) : Differentiable \ud835\udd5c fun _ : E => c :=", "model_response": "lemma differentiable_const [simp, derivative_intros]: \"differentiable \ud835\udd5c (\\<lambda>_. c)\""}
{"gold_output": "theorem copy_eq (f : CocompactMap \u03b1 \u03b2) (f' : \u03b1 \u2192 \u03b2) (h : f' = f) : f.copy f' h = f :=", "model_response": "lemma id_comp_eq : \"ContinuousMap.id (range f) \\<circ> f = f\""}
{"gold_output": "theorem ManyOneEquiv.congr_right {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n{p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : ManyOneEquiv q r) :\nManyOneEquiv p q \u2194 ManyOneEquiv p r :=", "model_response": "theorem bij_encode: \"bij encode\""}
{"gold_output": "theorem eval_one_map (f : R \u2192+* S) (p : R[X]) : (p.map f).eval 1 = f (p.eval 1) :=", "model_response": "lemma eval_one_map:\n\"(p.eval (1 : S)).map f = (p.map f).eval (1 : S)\""}
{"gold_output": "theorem HasStrictDerivAt.clm_comp (hc : HasStrictDerivAt c c' x) (hd : HasStrictDerivAt d d' x) :\nHasStrictDerivAt (fun y => (c y).comp (d y)) (c'.comp (d x) + (c x).comp d') x :=", "model_response": "lemma has_strict_deriv_at_star' [derivative_intros]:\n\"HasStrictDerivAt (\\<lambda>y. star (f y)) (star (f' x)) x\""}
{"gold_output": "theorem le_max_of_le_right : a \u2264 c \u2192 a \u2264 max b c :=", "model_response": "lemma le_max_of_le_left :\nassumes \"a \\<le> b\"\nshows \"a \\<le> max b c\""}
{"gold_output": "theorem LinearMap.coe_isometryOfInner (f : E \u2192\u2097[\ud835\udd5c] E') (h) : \u21d1(f.isometryOfInner h) = f :=", "model_response": "lemma toWeakDualBCNN_continuous:\n\"continuous (toWeakDualBCNN f)\""}
{"gold_output": "theorem connectedComponentIn_eq {x y : \u03b1} {F : Set \u03b1} (h : y \u2208 connectedComponentIn F x) :\nconnectedComponentIn F x = connectedComponentIn F y :=", "model_response": "lemma connectedComponentIn_subset: \"connectedComponentIn F x \\<subseteq> F\""}
{"gold_output": "theorem card_sylow_eq_card_quotient_normalizer [Fact p.Prime] [Fintype (Sylow p G)]\n(P : Sylow p G) : card (Sylow p G) = card (G \u29f8 (P : Subgroup G).normalizer) :=", "model_response": "theorem card_sylow_modEq_card_quotient_normalizer [simp]:\n\"card (Sylow p G) = card (Sylow p (G \u29f8 (P : Subgroup G).normalizer)) [MOD p]\""}
{"gold_output": "theorem map_map {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (x : Sym2 \u03b1) : map g (map f x) = map (g \u2218 f) x :=", "model_response": "lemma ofDual_comp_toDual [simp]: \"ofDual \\<circ> toDual = id\""}
{"gold_output": "theorem nhds_eq (h : x ~\u1d62 y) : \ud835\udcdd x = \ud835\udcdd y :=", "model_response": "lemma toIocMod_eq_self_iff: \"toIocMod hp a b = b \u2194 b \u2208 Set.Ioc a (a + p)\""}
{"gold_output": "theorem balancedCore_balanced (s : Set E) : Balanced \ud835\udd5c (balancedCore \ud835\udd5c s) :=", "model_response": "lemma balancedCore_subset_balancedHull: \"balancedCore \ud835\udd5c s \\<subseteq> balancedHull \ud835\udd5c s\""}
{"gold_output": "theorem vector_toList {n} : Computable (@Vector.toList \u03b1 n) :=", "model_response": "lemma toList_computable [simp]: \"computable (@toList \u03b1)\""}
{"gold_output": "theorem preimage_boolIndicator_false : s.boolIndicator \u207b\u00b9' {false} = s\u1d9c :=", "model_response": "lemma preimage_one_one_indicator_eq [simp]:\n\"((1::'a::zero_one_indicator) -` {1}) -` s = s\""}
{"gold_output": "theorem bot_eq_empty : (\u22a5 : Finset \u03b1) = \u2205 :=", "model_response": "lemma coe_finset_bot : \"(\u22a5 : WithBot (Finset \u03b1)) = \u22a5\""}
{"gold_output": "theorem exists_forall_deriv_at_Ioo_eq_of_contDiffOn_nhds {s : Set E} (hv : ContDiffOn \u211d 1 v s)\n(hs : s \u2208 \ud835\udcdd x\u2080) :\n\u2203 \u03b5 > (0 : \u211d),\n\u2203 f : \u211d \u2192 E, f t\u2080 = x\u2080 \u2227 \u2200 t \u2208 Ioo (t\u2080 - \u03b5) (t\u2080 + \u03b5), f t \u2208 s \u2227 HasDerivAt f (v (f t)) t :=", "model_response": "lemma differentiable_add_const_iff:\n\"(\\<lambda>x. f x + c) differentiable at x \\<longleftrightarrow> f differentiable at x\""}
{"gold_output": "theorem sdiff_sdiff_left' (s t u : Finset \u03b1) : (s \\ t) \\ u = s \\ t \u2229 (s \\ u) :=", "model_response": "lemma sdiff_subset_sdiff_union_right: \"(s \\ t) \\<subset> {a \u2208 s. a \u2209 t \u222a u} :="}
{"gold_output": "theorem AddTorsor.connectedSpace : ConnectedSpace P :=", "model_response": "lemma continuousOn_iff_continuousWithinAt :\n\"ContinuousOn f s \\<longleftrightarrow> (\\<forall>x\\<in>s. ContinuousWithinAt f s x)\""}
{"gold_output": "theorem opRingEquiv_single [AddCommMonoid G] (r : k) (x : G) :\nAddMonoidAlgebra.opRingEquiv (op (single x r)) = single x (op r) :=", "model_response": "lemma opRingEquiv_single_add [simp]:\n\"opRingEquiv (op (a + b :: 'a :: monoid_algebra)) = opRingEquiv (op a) + opRingEquiv (op b)\""}
{"gold_output": "theorem coeSubtype : (SubgroupClass.subtype H : H \u2192 G) = ((\u2191) : H \u2192 G) :=", "model_response": "lemma coeSubtype_eq_coe : (SubgroupClass.subtype H : H \u2192 G) = ((\u2191) : H \u2192 G) :="}
{"gold_output": "theorem frontier_eq_empty_iff [PreconnectedSpace \u03b1] {s : Set \u03b1} :\nfrontier s = \u2205 \u2194 s = \u2205 \u2228 s = univ :=", "model_response": "lemma frontier_eq_empty_iff_closure_eq_interior [simp]:\n\"frontier s = {} \u2194 closure s = interior s\""}
{"gold_output": "theorem sSup_apply {c : Set (E \u2192\u2097.[R] F)} (hc : DirectedOn (\u00b7 \u2264 \u00b7) c) {l : E \u2192\u2097.[R] F}\n(hl : l \u2208 c) (x : l.domain) :\n(LinearPMap.sSup c hc) \u27e8x, (LinearPMap.le_sSup hc hl).1 x.2\u27e9 = l x :=", "model_response": "lemma sSup_apply' (c : Set (E \u2192\u2097.[R] F)) (hc : DirectedOn (\u00b7 \u2264 \u00b7) c) {l : E \u2192\u2097.[R] F}\n(hl : l \u2208 c) (x : l.domain) : (sSup c fun f : E \u2192\u2097.[R] F => f) x = l x :="}
{"gold_output": "theorem equiv_symm (h : IsFixedPt e x) : IsFixedPt e.symm x :=", "model_response": "lemma continuous_on_symm : \"continuous_on (e.target) e.symm\""}
{"gold_output": "theorem addSalemSpencer_frontier [LinearOrderedField \ud835\udd5c] [TopologicalSpace E] [AddCommMonoid E]\n[Module \ud835\udd5c E] {s : Set E} (hs\u2080 : IsClosed s) (hs\u2081 : StrictConvex \ud835\udd5c s) :\nAddSalemSpencer (frontier s) :=", "model_response": "lemma frontier_subset_closure: \"frontier s \\<subseteq> closure s\""}
{"gold_output": "theorem Monic.not_irreducible_iff_exists_add_mul_eq_coeff (hm : p.Monic) (hnd : p.natDegree = 2) :\n\u00acIrreducible p \u2194 \u2203 c\u2081 c\u2082, p.coeff 0 = c\u2081 * c\u2082 \u2227 p.coeff 1 = c\u2081 + c\u2082 :=", "model_response": "lemma degree_of_sub_const_lt (hm : p.Monic) (hnd : p.natDegree = 2) :\n(toPoly (p - C (p.coeff 0))).degree < p.degree :="}
{"gold_output": "theorem algebraMap_eq (r : R) : algebraMap R \u210d[R,c\u2081,c\u2082] r = \u27e8r, 0, 0, 0\u27e9 :=", "model_response": "lemma norm_c\u2081 [simp]: \"norm c\u2081 = 1\""}
{"gold_output": "theorem normalClosure_eq_self (H : Subgroup G) [H.Normal] : normalClosure \u2191H = H :=", "model_response": "theorem normalClosure_eq_self (H : Subgroup G) [H.Normal] : normalClosure \u2191H = H :="}
{"gold_output": "theorem continuous_coe : Continuous (mk : \u03b1 \u2192 ConnectedComponents \u03b1) :=", "model_response": "lemma continuous_coe' [continuous_intros]: \"continuous (mk : \u03b1 \u2192 ConnectedComponents \u03b1)\""}
{"gold_output": "theorem RingHom.is_integral_of_mem_closure {x y z : S} (hx : f.IsIntegralElem x)\n(hy : f.IsIntegralElem y) (hz : z \u2208 Subring.closure ({x, y} : Set S)) : f.IsIntegralElem z :=", "model_response": "lemma inj_on_iff_injective: \"inj_on f s \\<longleftrightarrow> (restrict f s).Injective\""}
{"gold_output": "theorem reverse_nil {u : V} : (nil : G.Walk u u).reverse = nil :=", "model_response": "lemma reverse_nil : \"reverse (nil : G.Walk u u) = nil\""}
{"gold_output": "theorem mul_induction_on {I J : FractionalIdeal S P} {C : P \u2192 Prop} {r : P}\n(hr : r \u2208 I * J) (hm : \u2200 i \u2208 I, \u2200 j \u2208 J, C (i * j)) (ha : \u2200 x y, C x \u2192 C y \u2192 C (x + y)) :\nC r :=", "model_response": "lemma toPrincipalIdeal_mul:\n\"toPrincipalIdeal (I * J) = toPrincipalIdeal I * toPrincipalIdeal J\""}
{"gold_output": "theorem desc_commutes {Y Z : C} (f : Z \u27f6 Y) (I : InjectiveResolution Y)\n(J : InjectiveResolution Z) : J.\u03b9 \u226b desc f I J = (CochainComplex.single\u2080 C).map f \u226b I.\u03b9 :=", "model_response": "lemma augment_desc_commutes:\n\"J.augmentation \u226b desc f I J = (CochainComplex.single\u2080 C).map f \u226b I.augmentation\""}
{"gold_output": "theorem derivative_monomial (a : R) (n : \u2115) :\nderivative (monomial n a) = monomial (n - 1) (a * n) :=", "model_response": "lemma derivative_C_mul [simp]: \"derivative (C a * p) = C a * derivative p\""}
{"gold_output": "theorem arcsin_eq_of_sin_eq {x y : \u211d} (h\u2081 : sin x = y) (h\u2082 : x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)) :\narcsin y = x :=", "model_response": "lemma arcsin_eq_iff: \"arcsin y = x \u2194 y = sin x \u2227 x \u2208 Icc (-(\u03c0 / 2)) (\u03c0 / 2)\""}
{"gold_output": "theorem coeff_X_mul (m) (s : \u03c3) (p : MvPolynomial \u03c3 R) :\ncoeff (Finsupp.single s 1 + m) (X s * p) = coeff m p :=", "model_response": "lemma coeff_X_mul' [simp]: \"coeff (Finsupp.single s 1 + m) (X s * p) = coeff m p\""}
{"gold_output": "theorem mul_comm : IsCommutative _ m\u2082 :=", "model_response": "lemma mul_assoc :\nassumes \"a \\<in> M\" \"b \\<in> M\" \"c \\<in> M\"\nshows \"mul (mul a b) c = mul a (mul b c)\""}
{"gold_output": "theorem div_mul_eq_div_div_swap : a / (b * c) = a / c / b :=", "model_response": "lemma div_mul_eq_div_div_swap_right:\nassumes \"is_unit c\"\nshows \"a / b * c = a / c / b\""}
{"gold_output": "theorem getLast_append_singleton {a : \u03b1} (l : List \u03b1) :\ngetLast (l ++ [a]) (append_ne_nil_of_ne_nil_right l _ (cons_ne_nil a _)) = a :=", "model_response": "lemma card_fintype_list :\nassumes \"finite (UNIV :: set \u03b1)\"\nshows \"card { l : List \u03b1 . length l = n } = card (UNIV :: set \u03b1) ^ n\""}
{"gold_output": "theorem comap_inf_principal_neBot_of_image_mem (h : m '' s \u2208 g) : (Filter.comap m g \u2293 \ud835\udcdf s).NeBot :=", "model_response": "lemma continuous_at_iff_leftLim_eq_rightLim:\n\"continuous (at x) f \\<longleftrightarrow> leftLim f x = rightLim f x\""}
{"gold_output": "theorem eq_of_mem_singleton {x y : \u03b1} (h : x \u2208 ({y} : Finset \u03b1)) : x = y :=", "model_response": "lemma card_singleton:\nassumes \"card ({y} : Finset \u03b1) = 1\"\nshows   \"({y} : Finset \u03b1) = {x}\""}
{"gold_output": "theorem IsBounded.snd_of_prod (h : IsBounded (s \u00d7\u02e2 t)) (hs : s.Nonempty) : IsBounded t :=", "model_response": "lemma sep_set_of_mem_eq (s : Set \u03b1) : { x | x \u2208 s \u2227 P x } = s \u2229 { x | P x } :="}
{"gold_output": "theorem id_F (S : Split C) : (\ud835\udfd9 S : S \u27f6 S).F = \ud835\udfd9 S.X :=", "model_response": "lemma id_comp_inclusion [simp]: \"(\ud835\udfd9 S : S \u27f6 S).map \u226b inclusion S = \ud835\udfd9 (S.X) :="}
{"gold_output": "theorem subset_toMeasurable (\u03bc : Measure \u03b1) (s : Set \u03b1) : s \u2286 toMeasurable \u03bc s :=", "model_response": "lemma measurable_toMeasurable [measurable]: \"Measurable.measurable \u03bc (toMeasurable \u03bc s)\""}
{"gold_output": "theorem Mem\u2112p.smul_measure {f : \u03b1 \u2192 E} {c : \u211d\u22650\u221e} (hf : Mem\u2112p f p \u03bc) (hc : c \u2260 \u221e) :\nMem\u2112p f p (c \u2022 \u03bc) :=", "model_response": "lemma Mem\u2112p_smul_measure_iff [simp]:\n\"Mem\u2112p f p (c \u2022 \u03bc) \u2194 c = 0 \u2228 Mem\u2112p f p \u03bc\""}
{"gold_output": "theorem dualPairing_nondegenerate (W : Subspace K V\u2081) : W.dualPairing.Nondegenerate :=", "model_response": "lemma dualPairing_is_linear (W : Subspace K V\u2081) :\n\"LinearMap K (dualSpace W) V\u2082 (dualPairing W)\""}
{"gold_output": "theorem Monic.coeff_natDegree {p : R[X]} (hp : p.Monic) : p.coeff p.natDegree = 1 :=", "model_response": "lemma natDegree_eq_degree_to_nat [simp]:\n\"p.natDegree = degree_to_nat p.degree\""}
{"gold_output": "theorem balanced_ball_zero (r : \u211d) : Balanced \ud835\udd5c (ball p 0 r) :=", "model_response": "lemma balanced_ball_zero_subset_balancedCore: \"ball p 0 r \u2286 balancedCore p\""}
{"gold_output": "theorem IsGLB.exists_seq_antitone_tendsto {t : Set \u03b1} {x : \u03b1} [IsCountablyGenerated (\ud835\udcdd x)]\n(htx : IsGLB t x) (ht : t.Nonempty) :\n\u2203 u : \u2115 \u2192 \u03b1, Antitone u \u2227 (\u2200 n, x \u2264 u n) \u2227 Tendsto u atTop (\ud835\udcdd x) \u2227 \u2200 n, u n \u2208 t :=", "model_response": "lemma closed_le' [continuous_intros, intro]: \"closed {x. x \\<le> a}\""}
{"gold_output": "theorem subtypeVal_nil {\u03b1 : TypeVec.{u} 0} (ps : \u03b1 \u27f9 \u00abrepeat\u00bb 0 Prop) :\nTypeVec.subtypeVal ps = nilFun :=", "model_response": "lemma subtypeVal_id: \"subtypeVal id = id\""}
{"gold_output": "theorem lift'_lift'_assoc {g : Set \u03b1 \u2192 Set \u03b2} {h : Set \u03b2 \u2192 Set \u03b3} (hg : Monotone g)\n(hh : Monotone h) : (f.lift' g).lift' h = f.lift' fun s => h (g s) :=", "model_response": "lemma monotone: \"monotone f\""}
{"gold_output": "theorem integral_comp_add_mul (hc : c \u2260 0) (d) :\n(\u222b x in a..b, f (d + c * x)) = c\u207b\u00b9 \u2022 \u222b x in d + c * a..d + c * b, f x :=", "model_response": "lemma integral_comp_add_mul [simp]:\n\"(\u222b x in a..b, f (d + c * x)) = (c\u207b\u00b9 \u2022 \u222b x in d + c * a..d + c * b, f x)\""}
{"gold_output": "theorem neLocus_self_add_left : neLocus (f + g) f = g.support :=", "model_response": "lemma neLocus_self [simp]: \"neLocus f f = bot\""}
{"gold_output": "theorem of_reverse_eq {l : List \u03b1} : reverse l = l \u2192 Palindrome l :=", "model_response": "lemma palindrome_reverse :\nassumes \"reverse l = l\"\nshows \"palindrome l\""}
{"gold_output": "theorem mem_rootsOfUnity_prime_pow_mul_iff' (p k : \u2115) (m : \u2115+) [hp : Fact p.Prime] [CharP R p]\n{\u03b6 : R\u02e3} : \u03b6 ^ (p ^ k * \u2191m) = 1 \u2194 \u03b6 \u2208 rootsOfUnity m R :=", "model_response": "lemma card_pow_eq_one_iff_rootsOfUnity {p k : \u2115} [hp : Fact p.Prime] [CharP R p] :\ncard { x : R | x ^ p ^ k = 1 } = p ^ k :="}
{"gold_output": "theorem kerLift_mk (f : R \u2192+* S) (r : R) : kerLift f (Ideal.Quotient.mk (ker f) r) = f r :=", "model_response": "lemma kerLift_mk [simp]: \"kerLift f (Ideal.Quotient.mk a) = f a\""}
{"gold_output": "theorem span_span_of_tower [Semiring S] [SMul R S] [Module S M] [IsScalarTower R S M] :\nspan S (span R s : Set M) = span S s :=", "model_response": "lemma span_coe [simp]: \"span S (s : Set M) = span s\""}
{"gold_output": "theorem dist_set_exists : \u2203 C, 0 \u2264 C \u2227 \u2200 x : \u03b1, dist (f x) (g x) \u2264 C :=", "model_response": "lemma isCont_leftLim_eq_rightLim: \"isCont f x \\<longleftrightarrow> leftLim f x = rightLim f x\""}
{"gold_output": "theorem congr_fun {f g : Equiv \u03b1 \u03b2} (h : f = g) (x : \u03b1) : f x = g x :=", "model_response": "lemma injective_congr: \"injective f \\<longleftrightarrow> injective g\" if \"f = g\""}
{"gold_output": "theorem iInter_comp {f : \u03b9 \u2192 \u03b9\u2082} (hf : Surjective f) (g : \u03b9\u2082 \u2192 Set \u03b1) : (\u22c2 x, g (f x)) = \u22c2 y, g y :=", "model_response": "lemma surj_on_image_iff: \"surj_on f s (f '' s) \\<longleftrightarrow> surj_on f s\""}
{"gold_output": "theorem prod_mul_reverse_inv_prod (L : List (TransvectionStruct n R)) :\n(L.map toMatrix).prod \u2b1d (L.reverse.map (toMatrix \u2218 TransvectionStruct.inv)).prod = 1 :=", "model_response": "lemma prod_mul_reverse_inv_prod (L : List (TransvectionStruct n R)) :\n(L.map toMatrix).prod \u2b1d (L.reverse.map (toMatrix \u2218 TransvectionStruct.inv)).prod = 1 :="}
{"gold_output": "theorem setToFun_congr_ae (hT : DominatedFinMeasAdditive \u03bc T C) (h : f =\u1d50[\u03bc] g) :\nsetToFun \u03bc T hT f = setToFun \u03bc T hT g :=", "model_response": "lemma measurable_setToFun4 [measurable]:\n\"setToFun \\<in> (\u03b1 \\<rightarrow> E) \\<rightarrow> (\u03b1 \\<rightarrow> F) \\<rightarrow> (\u03b1 \\<rightarrow> G) \\<rightarrow> (\u03b1 \\<rightarrow> \ud835\udd5c) \\<rightarrow> (\u03b1 \\<rightarrow> E)\""}
{"gold_output": "theorem algebraMap_eq_inl' (s : S) : algebraMap S (tsze R M) s = inl (algebraMap S R s) :=", "model_response": "lemma inl_injective: \"Function.Injective (inl::S \\<Rightarrow> tsze R M)\""}
{"gold_output": "theorem zipWith_append (f : \u03b1 \u2192 \u03b2 \u2192 \u03b3) (l la : List \u03b1) (l' lb : List \u03b2)\n(h : l.length = l'.length) :\nzipWith f (l ++ la) (l' ++ lb) = zipWith f l l' ++ zipWith f la lb :=", "model_response": "lemma zipWith_append2 :\n\"zipWith f as (bs @ bs') = zipWith f as bs @ zipWith f (drop (length bs) as) bs'\""}
{"gold_output": "theorem integrable_measure_prod_mk_left {s : Set (\u03b1 \u00d7 \u03b2)} (hs : MeasurableSet s)\n(h2s : (\u03bc.prod \u03bd) s \u2260 \u221e) : Integrable (fun x => (\u03bd (Prod.mk x \u207b\u00b9' s)).toReal) \u03bc :=", "model_response": "lemma integrable_measure_preimage_prod_mk_left:\n\"Integrable.integrable \\<mu> (\\<lambda>x. ((\\<nu> (Prod.mk x \u207b\u00b9' s)).toReal))\""}
{"gold_output": "theorem verts_iInf {f : \u03b9 \u2192 G.Subgraph} : (\u2a05 i, f i).verts = \u22c2 i, (f i).verts :=", "model_response": "lemma verts_iSup: \"(\u2a06 i, f i).verts = \u22c3 i, (f i).verts\""}
{"gold_output": "theorem compl_univ_iff {s : Set \u03b1} : s\u1d9c = univ \u2194 s = \u2205 :=", "model_response": "lemma compl_setOf_eq {P : \u03b1 \u2192 Prop} : { x | P x }\u1d9c = { x | \u00acP x } :="}
{"gold_output": "theorem Eventually.exists_forall_of_atBot [SemilatticeInf \u03b1] [Nonempty \u03b1] {p : \u03b1 \u2192 Prop}\n(h : \u2200\u1da0 x in atBot, p x) : \u2203 a, \u2200 b \u2264 a, p b :=", "model_response": "lemma eventually_atBot_eq_setOf : {x . eventually p (atBot)} = {x . p x} :="}
{"gold_output": "theorem lcm_zero_right (x : R) : lcm x 0 = 0 :=", "model_response": "lemma lcm_one_right: \"lcm a 1 = normalize a\""}
{"gold_output": "theorem reindex_tprod (e : \u03b9 \u2243 \u03b9\u2082) (f : \u2200 _, M) :\nreindex R M e (tprod R f) = tprod R fun i \u21a6 f (e.symm i) :=", "model_response": "lemma reindex_injective: \"Function.Injective (reindex R M e)\""}
{"gold_output": "theorem mulSupport_comp_subset {g : M \u2192 N} (hg : g 1 = 1) (f : \u03b1 \u2192 M) :\nmulSupport (g \u2218 f) \u2286 mulSupport f :=", "model_response": "lemma continuousAt_comp_iff' [simp]:\n\"continuousAt (\\<lambda>x. g (f x)) x \\<longleftrightarrow> continuousAt f x\""}
{"gold_output": "theorem liminf_const_top {f : Filter \u03b2} : liminf (fun _ : \u03b2 => (\u22a4 : \u03b1)) f = (\u22a4 : \u03b1) :=", "model_response": "lemma liminf_const_bot [simp]: \"liminf (fun _ : \u03b2 => (\u22a5 : \u03b1)) f = (\u22a5 : \u03b1)\""}
{"gold_output": "theorem tendsto_Lp_of_tendsto_ae_of_meas [IsFiniteMeasure \u03bc] (hp : 1 \u2264 p) (hp' : p \u2260 \u221e)\n{f : \u2115 \u2192 \u03b1 \u2192 \u03b2} {g : \u03b1 \u2192 \u03b2} (hf : \u2200 n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)\n(hg' : Mem\u2112p g p \u03bc) (hui : UnifIntegrable f p \u03bc)\n(hfg : \u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))) :\nTendsto (fun n => snorm (f n - g) p \u03bc) atTop (\ud835\udcdd 0) :=", "model_response": "lemma tendsto_Lp_of_tendsto_ae [tendsto_intros]:\nassumes \"1 \\<le> p\" \"p \\<noteq> \\<infinity>\"\nand hf: \"\\<And>n. StronglyMeasurable (f n)\" and hg: \"StronglyMeasurable g\"\nand hg': \"Mem\u2112p g p \u03bc\"\nand hui: \"UnifIntegrable f p \u03bc\"\nand hfg: \"\u2200\u1d50 x \u2202\u03bc, Tendsto (fun n => f n x) atTop (\ud835\udcdd (g x))\"\nshows \"tendsto (fun n => snorm (f n - g) p \u03bc) atTop (\ud835\udcdd 0)\""}
{"gold_output": "theorem norm_toLp [Fact (1 \u2264 p)] (f : \u03b1 \u2192\u209b E) (hf : Mem\u2112p f p \u03bc) :\n\u2016toLp f hf\u2016 = ENNReal.toReal (snorm f p \u03bc) :=", "model_response": "lemma Mem\u2112p.norm_toLp [simp]:\n\"norm (toLp f hf) = ENNReal.toReal (snorm f p \u03bc)\""}
{"gold_output": "theorem Continuous.Prod.mk (a : \u03b1) : Continuous fun b : \u03b2 => (a, b) :=", "model_response": "lemma continuous_prod_mk [continuous_intros]: \"continuous (\\<lambda>(a, b). a \\<times> b)\""}
{"gold_output": "theorem eq_shift_mul_X_add_const (\u03c6 : PowerSeries R) :\n\u03c6 = (mk fun p => coeff R (p + 1) \u03c6) * X + C R (constantCoeff R \u03c6) :=", "model_response": "lemma coeff_zero_mul_X (\u03c6 : PowerSeries R) : coeff R 0 (\u03c6 * X) = 0 :="}
{"gold_output": "theorem Matrix.Represents.add {A A' : Matrix \u03b9 \u03b9 R} {f f' : Module.End R M} (h : A.Represents b f)\n(h' : Matrix.Represents b A' f') : (A + A').Represents b (f + f') :=", "model_response": "lemma toFun_add : \"toFun (A + B) = toFun A + toFun B\""}
{"gold_output": "theorem nonempty_iff {\u03b1} : Nonempty (Erased \u03b1) \u2194 Nonempty \u03b1 :=", "model_response": "lemma card_lists_length_0 [simp]:\n\"card {l. length l = 0 \\<and> set l \\<subseteq> \u03b1} = (if \u03b1 = {} then 1 else 0)\""}
{"gold_output": "theorem cos_angle (x y : V) : Real.cos (angle x y) = \u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016) :=", "model_response": "lemma tan_angle: \"Real.tan (angle x y) = \u27eax, y\u27eb / (\u2016x\u2016 * \u2016y\u2016)\""}
{"gold_output": "theorem toList_cons (a : \u03b1) (s) : toList (cons a s) = (List.cons a <$> toList s).think :=", "model_response": "lemma toList_cons_eq:\nassumes \"s \\<noteq> \\<bottom>\"\nshows \"toList (cons a s) = List.cons a (toList s)\""}
{"gold_output": "theorem mem_of_mem_erase {a b : \u03b1} {s : Multiset \u03b1} : a \u2208 s.erase b \u2192 a \u2208 s :=", "model_response": "lemma multiset_le_add_right:\nassumes \"s \\<le> t\"\nshows \"s + u \\<le> t + u\""}
{"gold_output": "theorem isIntegral_algebra [Algebra R A] [IsScalarTower R A B] : Algebra.IsIntegral R A :=", "model_response": "lemma of_one [simp]:\n\"of (1\\<^sub>r) = 1\""}
{"gold_output": "theorem limit.pre_\u03c0 (k : K) : limit.pre F E \u226b limit.\u03c0 (E \u22d9 F) k = limit.\u03c0 F (E.obj k) :=", "model_response": "lemma limit.pre_\u03c0: \"limit.pre F E \u226b limit.\u03c0 (E \u22d9 F) k = limit.\u03c0 F (E.obj k)\""}
{"gold_output": "theorem exists_multiset_eq_map_quot_mk {r : \u03b1 \u2192 \u03b1 \u2192 Prop} (s : Multiset (Quot r)) :\n\u2203 t : Multiset \u03b1, s = t.map (Quot.mk r) :=", "model_response": "lemma multiset_rel_map_quot_mk:\nassumes \"rel_mset r s t\"\nshows \"\\<exists>u. s = map (Quot.mk r) u \\<and> t = map (Quot.mk r) u\""}
{"gold_output": "theorem cast_lt [LinearOrderedSemiring \u03b1] {m n : PosNum} : (m : \u03b1) < n \u2194 m < n :=", "model_response": "lemma of_nat_lt [simp]:\n\"of_nat n < m \\<longleftrightarrow> n < m\""}
{"gold_output": "theorem finrank_eq_zero_of_rank_eq_zero [FiniteDimensional K V] (h : Module.rank K V = 0) :\nfinrank K V = 0 :=", "model_response": "lemma finrank_eq_zero_iff [simp]: \"Module.rank K V = 0 \\<longleftrightarrow> finrank K V = 0\""}
{"gold_output": "theorem ext {I J : Ideal \u03b1} (h : \u2200 x, x \u2208 I \u2194 x \u2208 J) : I = J :=", "model_response": "lemma of_inj {s t} : of R s = of R t \u2194 s = t :="}
{"gold_output": "theorem Preconnected.boxProd (hG : G.Preconnected) (hH : H.Preconnected) :\n(G \u25a1 H).Preconnected :=", "model_response": "lemma finite_reachable_unordered_pairs :\n\"finite {(u,v) \\<in> (u \\<times> v) ` (u \\<rightarrow>\\<^sup>* v) ` (u \\<times> v) ` G.True}\""}
{"gold_output": "theorem const_add (hf : DiffContOnCl \ud835\udd5c f s) (c : F) : DiffContOnCl \ud835\udd5c (fun x => c + f x) s :=", "model_response": "lemma contDiffOn_const_add (hf : DiffContOnCl \ud835\udd5c f s) (c : F) :\nDiffContOnCl \ud835\udd5c (fun x => c + f x) s :="}
{"gold_output": "theorem eventually_nhdsWithin_of_forall {s : Set \u03b1} {a : \u03b1} {p : \u03b1 \u2192 Prop} (h : \u2200 x \u2208 s, p x) :\n\u2200\u1da0 x in \ud835\udcdd[s] a, p x :=", "model_response": "lemma continuous_at_def:\nfixes f :: \"'a::metric_space \\<Rightarrow> 'b::metric_space\"\nshows \"continuous (at x) f \\<longleftrightarrow> (\\<forall>s. x \\<in> s \\<longrightarrow> open s \\<longrightarrow> open (f \u207b\u00b9' s) \\<and> x \\<in> f \u207b\u00b9' s)\""}
{"gold_output": "theorem mul_div_right_comm : a * b / c = a / c * b :=", "model_response": "lemma div_right_comm:\nassumes \"a \\<in> carrier \\<alpha>\" \"b \\<in> carrier \\<alpha>\" \"c \\<in> carrier \\<alpha>\"\nshows \"a \\<otimes> b div c = a div c \\<otimes> b\""}
{"gold_output": "theorem copy_eq (p : SubMulAction R M) (s : Set M) (hs : s = \u2191p) : p.copy s hs = p :=", "model_response": "lemma injOn_restrict_iff: \"injOn f s \\<longleftrightarrow> Injective (s.restrict f s)\""}
{"gold_output": "theorem trStmts\u2081_trans {q q'} : q' \u2208 trStmts\u2081 q \u2192 trStmts\u2081 q' \u2286 trStmts\u2081 q :=", "model_response": "lemma trStmts\u2081_tr_subset: \"trStmts\u2081 q' \u2286 set q\""}
{"gold_output": "theorem extension_unique (hf : UniformContinuous f) {g : Completion \u03b1 \u2192 \u03b2}\n(hg : UniformContinuous g) (h : \u2200 a : \u03b1, f a = g (a : Completion \u03b1)) :\nCompletion.extension f = g :=", "model_response": "lemma extension_unique: \"Completion.extension f = g\""}
{"gold_output": "theorem hasseDeriv_C (r : R) (hk : 0 < k) : hasseDeriv k (C r) = 0 :=", "model_response": "lemma degree_hasseDeriv [simp]: \"degree (hasseDeriv k p) = degree p - k\""}
{"gold_output": "theorem Filter.EventuallyLE.isMaxFilter {\u03b1 \u03b2 : Type _} [Preorder \u03b2] {f g : \u03b1 \u2192 \u03b2} {a : \u03b1}\n{l : Filter \u03b1} (hle : g \u2264\u1da0[l] f) (hfga : f a = g a) (h : IsMaxFilter f l a) :\nIsMaxFilter g l a :=", "model_response": "lemma continuousAt_of_real: \"continuousAt of_real x\""}
{"gold_output": "theorem ExtensionOfMaxAdjoin.extensionToFun_wd (h : Module.Baer R Q) {y : N}\n(x : supExtensionOfMaxSingleton i f y) (a : (extensionOfMax i f).domain)\n(r : R) (eq1 : \u2191x = \u2191a + r \u2022 y) :\nExtensionOfMaxAdjoin.extensionToFun i f h x =\n(extensionOfMax i f).toLinearPMap a + ExtensionOfMaxAdjoin.extendIdealTo i f h y r :=", "model_response": "lemma extensionToFun_inj (i : Ideal R) (f g : (adjoin R {i} \u2192\u2090[R] Q)) :\nextensionToFun i f = extensionToFun i g \u2194 f = g :="}
{"gold_output": "theorem bihimp_def [\u2200 i, GeneralizedHeytingAlgebra (\u03c0 i)] (a b : \u2200 i, \u03c0 i) :\na \u21d4 b = fun i => a i \u21d4 b i :=", "model_response": "lemma of_injective:\n\"injective of\""}
{"gold_output": "theorem ofAdd_image_zmultiples_eq_zpowers_ofAdd {x : A} :\nMultiplicative.ofAdd '' (AddSubgroup.zmultiples x : Set A) =\nSubgroup.zpowers (Multiplicative.ofAdd x) :=", "model_response": "lemma ofAdd_image_zmultiples_eq_zpowers_ofAdd [simp]:\n\"Multiplicative.ofAdd ` AddSubgroup.zmultiples x = Subgroup.zpowers (Multiplicative.ofAdd x)\""}
{"gold_output": "theorem norm_lt_iff_of_nonempty [Nonempty \u03b1] {M : \u211d} : \u2016f\u2016 < M \u2194 \u2200 x, \u2016f x\u2016 < M :=", "model_response": "lemma norm_eq_iSup_norm [simp]: \"norm f = (\u2a06 x : \u03b1, \u2016f x\u2016)\""}
{"gold_output": "theorem midpoint_vsub (p\u2081 p\u2082 p : P) :\nmidpoint R p\u2081 p\u2082 -\u1d65 p = (\u215f 2 : R) \u2022 (p\u2081 -\u1d65 p) + (\u215f 2 : R) \u2022 (p\u2082 -\u1d65 p) :=", "model_response": "lemma midpoint_mem_affine_span_pair (p\u2081 p\u2082 p : P) :\nmidpoint R p\u2081 p\u2082 \u2208 affine_span R {p\u2081, p\u2082} :="}
{"gold_output": "theorem mem_col_iff {\u03bc : YoungDiagram} {j : \u2115} {c : \u2115 \u00d7 \u2115} : c \u2208 \u03bc.col j \u2194 c \u2208 \u03bc \u2227 c.snd = j :=", "model_response": "lemma col_lt_card_row:\nassumes \"c \\<in> \\<mu>.col j\"\nshows \"j < card (\\<mu>.row i)\""}
{"gold_output": "theorem refl_toAlgHom : \u2191(refl : A\u2081 \u2243\u2090[R] A\u2081) = AlgHom.id R A\u2081 :=", "model_response": "lemma refl_toAlgHom : (refl : A\u2081 \u2243\u2090[R] A\u2081) = AlgHom.id R A\u2081 :="}
{"gold_output": "theorem preimage_eq_iff_eq_image {f : \u03b1 \u2192 \u03b2} (hf : Bijective f) {s t} : f \u207b\u00b9' s = t \u2194 s = f '' t :=", "model_response": "lemma preimage_Ici_eq (a : \u03b1) : f \u207b\u00b9' Ici a = Ici (f a) :="}
{"gold_output": "theorem le_of_eq_of_le {\u03b1} [OrderedSemiring \u03b1] {a b : \u03b1} (ha : a = 0) (hb : b \u2264 0) : a + b \u2264 0 :=", "model_response": "lemma le_of_eq_of_le_of_le:\nassumes \"a = b\" and \"c \\<le> d\" and \"a \\<le> c\"\nshows \"b \\<le> d\""}
{"gold_output": "theorem natDegree_multiset_prod (h : (0 : R[X]) \u2209 t) :\nnatDegree t.prod = (t.map natDegree).sum :=", "model_response": "lemma natDegree_multiset_prod_le:\n\"natDegree (prod_mset t) \\<le> (t.bind natDegree).sum\""}
{"gold_output": "theorem omegaLimit_iInter (p : \u03b9 \u2192 Set \u03b1) : \u03c9 f \u03d5 (\u22c2 i, p i) \u2286 \u22c2 i, \u03c9 f \u03d5 (p i) :=", "model_response": "lemma omegaLimit_iInter: \"omegaLimit f \u03d5 (\u22c2 i, p i) \u2286 \u22c2 i, omegaLimit f \u03d5 (p i)\""}
{"gold_output": "theorem teichmuller_coeff_zero (r : R) : (teichmuller p r).coeff 0 = r :=", "model_response": "lemma coeff_teichmuller_zero (r : R) : (teichmuller p r).coeff 0 = r :="}
{"gold_output": "theorem toProd_one : (1 : NonemptyInterval \u03b1).toProd = 1 :=", "model_response": "lemma toProd_empty : (\u2205 : Finset \u03b1).toProd = 1 :="}
{"gold_output": "theorem apply_symm_apply (e : M \u2243* N) (y : N) : e (e.symm y) = y :=", "model_response": "lemma inv_inv [simp]:\n\"e.inv (e.symm y) = y\""}
{"gold_output": "theorem hasFDerivAt_polarCoord_symm (p : \u211d \u00d7 \u211d) :\nHasFDerivAt polarCoord.symm\n(LinearMap.toContinuousLinearMap (Matrix.toLin (Basis.finTwoProd \u211d) (Basis.finTwoProd \u211d)\n!![cos p.2, -p.1 * sin p.2; sin p.2, p.1 * cos p.2])) p :=", "model_response": "lemma differentiableAt_polarCoord_symm :\n\"DifferentiableAt \u211d polarCoord.symm p\""}
{"gold_output": "theorem erase_add (i : \u03b9) (f\u2081 f\u2082 : \u03a0\u2080 i, \u03b2 i) : erase i (f\u2081 + f\u2082) = erase i f\u2081 + erase i f\u2082 :=", "model_response": "lemma support_add_subset: \"support (f + g) \\<subseteq> support f \\<union> support g\""}
{"gold_output": "theorem length_nonneg : \u2200 s : Interval \u03b1, 0 \u2264 s.length", "model_response": "lemma length_Ico [simp]: \"length (Ico a b) = nat (b - a)\""}
{"gold_output": "theorem differentiable_tsum (hu : Summable u) (hf : \u2200 n x, HasFDerivAt (f n) (f' n x) x)\n(hf' : \u2200 n x, \u2016f' n x\u2016 \u2264 u n) : Differentiable \ud835\udd5c fun y => \u2211' n, f n y :=", "model_response": "lemma fderiv_tsum (hf : \u2200 n x, HasFDerivAt (f n) (f' n x) x) (hf' : \u2200 n x, \u2016f' n x\u2016 \u2264 u n) :\nfderiv \ud835\udd5c (fun y => \u2211' i, f i y) x = \u2211' i, fderiv \ud835\udd5c (f i) x :="}
{"gold_output": "theorem Continuous.matrix_fromBlocks {A : X \u2192 Matrix n l R} {B : X \u2192 Matrix n m R}\n{C : X \u2192 Matrix p l R} {D : X \u2192 Matrix p m R} (hA : Continuous A) (hB : Continuous B)\n(hC : Continuous C) (hD : Continuous D) :\nContinuous fun x => Matrix.fromBlocks (A x) (B x) (C x) (D x) :=", "model_response": "lemma continuous_matrix_fromBlocks4 [continuous_intros]:\n\"continuous (\\<lambda>x. fromBlocks (A x) (B x) (C x) (D x))\""}
{"gold_output": "theorem inf_union (s\u2081 s\u2082 : Multiset \u03b1) : (s\u2081 \u222a s\u2082).inf = s\u2081.inf \u2293 s\u2082.inf :=", "model_response": "lemma inf_union [simp]: \"inf (s\u2081 \u222a s\u2082) = inf s\u2081 \u2293 inf s\u2082\""}
{"gold_output": "theorem bliminf_or_eq_inf : (bliminf u f fun x => p x \u2228 q x) = bliminf u f p \u2293 bliminf u f q :=", "model_response": "lemma bliminf_sup_le_iff:\n\"{ x \\<in> s . p x } \\<subseteq> { x \\<in> s . q x } \\<longleftrightarrow> (\\<forall>x\\<in>s. p x \\<longrightarrow> q x)\""}
{"gold_output": "theorem ennnorm {\u03b2 : Type _} [SeminormedAddCommGroup \u03b2] {f : \u03b1 \u2192 \u03b2}\n(hf : AEStronglyMeasurable f \u03bc) : AEMeasurable (fun a => (\u2016f a\u2016\u208a : \u211d\u22650\u221e)) \u03bc :=", "model_response": "lemma aemeasurable_ennnorm [simp, intro!]: \"AEMeasurable (\\<lambda>a. ennnorm (f a)) \\<mu>\""}
{"gold_output": "theorem some_lt_some : @LT.lt (WithBot \u03b1) _ (Option.some a) (Option.some b) \u2194 a < b :=", "model_response": "lemma toWithTop_lt_toWithTop [simp]:\n\"toWithTop a < toWithTop b  \\<longleftrightarrow> a < b\""}
{"gold_output": "theorem mem_toSubsemigroup {s : Submonoid M} {x : M} : x \u2208 s.toSubsemigroup \u2194 x \u2208 s :=", "model_response": "lemma toSubsemigroup_injective :\n\"Function.Injective (toSubsemigroup : Subsemigroup M \u2192 Subsemigroup M)\""}
{"gold_output": "theorem refl (f : \u03b1 \u2192 \u03b1) : Commute f f :=", "model_response": "lemma commute_refl [simp]: \"commute f f\""}
{"gold_output": "theorem boxProd_adj_right : (G \u25a1 H).Adj (a, b\u2081) (a, b\u2082) \u2194 H.Adj b\u2081 b\u2082 :=", "model_response": "lemma edgeSet_restrict_left_eq : \"{(a, b) | a b. a \\<in> s \\<and> (a, b) \\<in> (edgeSet G)} =\n{(a, b) | a b. a \\<in> s \\<and> (a, b) \\<in> (edgeSet (G \\<upharpoonleft> s))}\""}
{"gold_output": "theorem diag_union : (s \u222a t).diag = s.diag \u222a t.diag :=", "model_response": "lemma diag_inter [simp]: \"diag (s \\<inter> t) = diag s \\<inter> diag t\""}
{"gold_output": "theorem IsLowerSet.mul_left (ht : IsLowerSet t) : IsLowerSet (s * t) :=", "model_response": "lemma Iic_mul_Ici_eq_Icc: \"Iic a * Ici b = Icc a b\""}
{"gold_output": "theorem isOpen_iff_of_not_mem (h : \u221e \u2209 s) : IsOpen s \u2194 IsOpen ((\u2191) \u207b\u00b9' s : Set X) :=", "model_response": "lemma isOpen_vimage_Iic_iff (a : \u03b2) :\nIsOpen ((\u2191) \u207b\u00b9' Iic a : Set X) \u2194 finestPart.isOpen (Iic a) :="}
{"gold_output": "theorem eval_mul_X_sub_C {p : R[X]} (r : R) : (p * (X - C r)).eval r = 0 :=", "model_response": "lemma eval_mul_X_sub_C: \"eval r (p * (X - C r)) = eval r p * eval r q\""}
{"gold_output": "theorem norm_image_sub_le_of_norm_fderiv_le' (hf : \u2200 x \u2208 s, DifferentiableAt \ud835\udd5c f x)\n(bound : \u2200 x \u2208 s, \u2016fderiv \ud835\udd5c f x - \u03c6\u2016 \u2264 C) (hs : Convex \u211d s) (xs : x \u2208 s) (ys : y \u2208 s) :\n\u2016f y - f x - \u03c6 (y - x)\u2016 \u2264 C * \u2016y - x\u2016 :=", "model_response": "lemma norm_image_sub_le_of_norm_fderiv_le:\n\"norm (f y - f x - \\<phi> (y - x)) \\<le> C * norm (y - x)\"\nif \"\\<And>x. x \\<in> s \\<Longrightarrow> DifferentiableAt \ud835\udd5c f x\"\n\"\\<And>x. x \\<in> s \\<Longrightarrow> norm (fderiv \ud835\udd5c f x - \\<phi>) \\<le> C\" \"convex \u211d s\" \"x \\<in> s\" \"y \\<in> s\""}
{"gold_output": "theorem zpow_neg_coe_nat (A : M) (n : \u2115) : A ^ (-n : \u2124) = (A ^ n)\u207b\u00b9 :=", "model_response": "lemma toEnd_mul : \"toEnd (r * s) = toEnd r * toEnd s\""}
{"gold_output": "theorem forall_measure_preimage_mul_iff (\u03bc : Measure G) :\n(\u2200 (g : G) (A : Set G), MeasurableSet A \u2192 \u03bc ((fun h => g * h) \u207b\u00b9' A) = \u03bc A) \u2194\nIsMulLeftInvariant \u03bc :=", "model_response": "lemma measurable_mul_left (g : G) : Measurable (fun h => g * f h) \u03bc :="}
{"gold_output": "theorem normalize_naturality {a b c : B} (p : Path a b) {f g : Hom b c} (\u03b7 : f \u27f6 g) :\n(preinclusion B).map \u27e8p\u27e9 \u25c1 \u03b7 \u226b (normalizeIso p g).hom =\n(normalizeIso p f).hom \u226b\n(preinclusion B).map\u2082 (eqToHom (Discrete.ext _ _ (normalizeAux_congr p \u03b7))) :=", "model_response": "lemma normalizeIso_naturality:\n\"(preinclusion B).map \u27e8p\u27e9 \u25c1 \u03b7 \u226b (normalizeIso p g).hom =\n(normalizeIso p f).hom \u226b\n(preinclusion B).map\u2082 (eqToHom (Discrete.ext _ _ (normalizeAux_congr p \u03b7)))\""}
{"gold_output": "theorem coe_comp_continuousMap' (f : SpectralMap \u03b2 \u03b3) (g : SpectralMap \u03b1 \u03b2) :\n(f.comp g : ContinuousMap \u03b1 \u03b3) = (f : ContinuousMap \u03b2 \u03b3).comp g :=", "model_response": "lemma id_comp [simp]: \"SpectralMap.id \u03b3 \u2218' f = f\""}
{"gold_output": "theorem ofLex_mul [Mul \u03b1] (a b : Lex \u03b1) : ofLex (a * b) = ofLex a * ofLex b :=", "model_response": "lemma ofLex_add [simp]:\nassumes \"trans r\"\nshows \"ofLex (a + b) = ofLex a + ofLex b\""}
{"gold_output": "theorem top_lie_le_iff_le_normalizer (N' : LieSubmodule R L M) :\n\u2045(\u22a4 : LieIdeal R L), N\u2046 \u2264 N' \u2194 N \u2264 N'.normalizer :=", "model_response": "lemma top_lie_eq_inf (N' : LieSubmodule R L M) : \u2045(\u22a4 : LieIdeal R L), N\u2046 = \u22a4 \u2293 N :="}
{"gold_output": "theorem Ioc_pred_right_of_not_isMin (ha : \u00acIsMin b) : Ioc a (pred b) = Ioo a b :=", "model_response": "lemma right_pred_not_mem_Ioc: \"pred b \u2209 Ioc a (pred b)\""}
{"gold_output": "theorem map_onFunction {M : Type _} [L.Structure M] [L'.Structure M] [\u03d5.IsExpansionOn M] {n}\n(f : L.Functions n) (x : Fin n \u2192 M) : funMap (\u03d5.onFunction f) x = funMap f x :=", "model_response": "lemma funMap_id[simp]: \"funMap (id L n M) = id\""}
{"gold_output": "theorem mul_ne_mul_left (a : G) {b c : G} : b * a \u2260 c * a \u2194 b \u2260 c :=", "model_response": "lemma of_nat_ne_zero_iff [simp]: \"of_nat n \\<noteq> 0 \\<longleftrightarrow> n \\<noteq> 0\""}
{"gold_output": "theorem isBigOWith_refl (f : \u03b1 \u2192 E) (l : Filter \u03b1) : IsBigOWith 1 l f f :=", "model_response": "lemma isBigOWith_refl [simp]: \"isBigOWith 1 l f f\""}
{"gold_output": "theorem mem_or_not_mem (p : T.CompleteType \u03b1) (\u03c6 : L[[\u03b1]].Sentence) : \u03c6 \u2208 p \u2228 \u03c6.not \u2208 p :=", "model_response": "theorem infinite_bool_functions {\u03b1} :\n(infinite { f : (\u2115 \u2192 Bool) | T.IsFun p 0 f }) :="}
{"gold_output": "theorem prod_univ_three [CommMonoid \u03b2] (f : Fin 3 \u2192 \u03b2) : (\u220f i, f i) = f 0 * f 1 * f 2 :=", "model_response": "lemma ofNat_eq [simp]: \"ofNat n = f (n mod 3)\""}
{"gold_output": "theorem liftAddHom_comp_single [AddCommMonoid M] [AddCommMonoid N] (f : \u03b1 \u2192 M \u2192+ N) (a : \u03b1) :\n((liftAddHom (\u03b1 := \u03b1) (M := M) (N := N)) f).comp (singleAddHom a) = f a :=", "model_response": "lemma liftAddHom_comp_singleAddHom[simp]:\n\"(liftAddHom (\u03b1 := \u03b1) (M := M) (N := N)) f \\<circ> singleAddHom a = f a\""}
{"gold_output": "theorem pi_lt_315 : \u03c0 < 3.15 :=", "model_response": "lemma ofReal_prod : \"ofReal (prod (ofReal :: real \\<Rightarrow> 'a) xs) = prod id xs\""}
{"gold_output": "theorem recF_eq' {\u03b1 : Type _} (g : F \u03b1 \u2192 \u03b1) (a : q.P.A) (f : q.P.B a \u2192 q.P.W) :\nrecF g \u27e8a, f\u27e9 = g (abs (recF g <$> \u27e8a, f\u27e9)) :=", "model_response": "lemma recF_eq:\nassumes \"\\<And>a f. g (a, f) = h (a, f)\"\nshows \"recF g p = recF h p\""}
{"gold_output": "theorem add_mem_Ico_iff_left : a + b \u2208 Set.Ico c d \u2194 a \u2208 Set.Ico (c - b) (d - b) :=", "model_response": "lemma add_mem_Ico_iff_left : a + b \\<in> Set.Ico c d \\<longleftrightarrow> a \\<in> Set.Ico (c - b) (d - b) :="}
{"gold_output": "theorem index_inf_ne_zero (hH : H.index \u2260 0) (hK : K.index \u2260 0) : (H \u2293 K).index \u2260 0 :=", "model_response": "theorem index_inf_ne_zero_iff [simp]: \"H \u2293 K).index \u2260 0 \u2194 H.index \u2260 0 \u2227 K.index \u2260 0\""}
{"gold_output": "theorem ofReal_natCast (n : \u2115) : ((n : \u211d) : K) = n :=", "model_response": "lemma continuous_ofReal : \"continuous ofReal\""}
{"gold_output": "theorem ordConnectedComponent_mem_nhds : ordConnectedComponent s a \u2208 \ud835\udcdd a \u2194 s \u2208 \ud835\udcdd a :=", "model_response": "lemma Iic_mem_nhds_iff : {x | x \\<in> s \\<and> x \\<le> a} \\<in> \ud835\udcdd a  \\<longleftrightarrow> {x | x \\<in> s \\<and> x \\<le> a} \\<in> \ud835\udcdd a :="}
{"gold_output": "theorem Continuous.closure_preimage_subset {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (t : Set \u03b2) :\nclosure (f \u207b\u00b9' t) \u2286 f \u207b\u00b9' closure t :=", "model_response": "lemma closure_preimage_subset {f : \u03b1 \u2192 \u03b2} (hf : Continuous f) (t : Set \u03b2) :\nclosure (f \u207b\u00b9' t) \u2286 f \u207b\u00b9' closure t :="}
{"gold_output": "theorem pushforward_sheaf_of_sheaf {F : X.Presheaf C} (h : F.IsSheaf) : (f _* F).IsSheaf :=", "model_response": "theorem sheafify_idempotent :\nJ.sheafify P \u22d9 J.sheafify P = J.sheafify P :="}
{"gold_output": "theorem realize_boundedFormula_top {\u03b1 : Type _} {n : \u2115} {\u03c6 : L.BoundedFormula \u03b1 n}\n{v : \u03b1 \u2192 (\u22a4 : L.Substructure M)} {xs : Fin n \u2192 (\u22a4 : L.Substructure M)} :\n\u03c6.Realize v xs \u2194 \u03c6.Realize (((\u2191) : _ \u2192 M) \u2218 v) ((\u2191) \u2218 xs) :=", "model_response": "lemma of_to: \"of (to x) = x\""}
{"gold_output": "theorem mk_X_2 : (mk X\u2080 X\u2081 X\u2082 d\u2080 d\u2081 s succ).X 2 = X\u2082 :=", "model_response": "theorem mk_X_2 : (mk X\u2080 X\u2081 X\u2082 d\u2080 d\u2081 s succ).X 2 = X\u2082 :="}
{"gold_output": "theorem disjoint_iff_inter_eq_empty : Disjoint s t \u2194 s \u2229 t = \u2205 :=", "model_response": "lemma to_nat_inj : Injective to_nat :="}
{"gold_output": "theorem toLp_zero : toLp (0 : \u03b1 \u2192\u209b E) zero_mem\u2112p = (0 : Lp.simpleFunc E p \u03bc) :=", "model_response": "lemma toLp_zero' [simp]: \"toLp (0 : \u03b1 \u2192\u209b E) zero_mem\u2112p = (0 : Lp.simpleFunc E p \u03bc)\""}
{"gold_output": "theorem bot_lt_iff_ne_bot : \u2200 {x : WithBot \u03b1}, \u22a5 < x \u2194 x \u2260 \u22a5", "model_response": "lemma toDual_strictMono:\n\"StrictMono toDual\""}
{"gold_output": "theorem codRestrict_ker {f : M \u2192\u2097[S] M} (h : IsProj m f) : ker h.codRestrict = ker f :=", "model_response": "lemma codRestrict_comp_domRestrict (f : M \u2192\u2097[S] M) (h : IsProj m f) :\nh.codRestrict.comp h.domRestrict = f :="}
{"gold_output": "theorem boundedContinuousFunction_dense [SecondCountableTopologyEither \u03b1 E] [_i : Fact (1 \u2264 p)]\n(hp : p \u2260 \u221e) [\u03bc.WeaklyRegular] : (boundedContinuousFunction E p \u03bc).topologicalClosure = \u22a4 :=", "model_response": "lemma dense_denseInducing :\n\"topologicalClosure (Lp.boundedContinuousFunction E p \u03bc) = UNIV\""}
{"gold_output": "theorem term_eq [AddCommMonoid \u03b1] (n : \u2115) (x a : \u03b1) : term n x a = n \u2022 x + a :=", "model_response": "lemma sum_list_map_index_add :\nassumes \"length l = length r\"\nshows \"sum_list (map (\\<lambda>i. l ! i + r ! i) [0..<length l]) = sum_list l + sum_list r\""}
{"gold_output": "theorem LieAlgebra.isLieAbelian_bot (R : Type u) (L : Type v) [CommRing R] [LieRing L]\n[LieAlgebra R L] : IsLieAbelian (\u22a5 : LieIdeal R L) :=", "model_response": "lemma LieSubalgebra.isLieAbelian_bot : \"IsLieAbelian (\u22a5 : LieSubalgebra R L)\""}
{"gold_output": "theorem distortion_le_of_mem (h : J \u2208 \u03c0) : J.distortion \u2264 \u03c0.distortion :=", "model_response": "lemma distortion_prepartition_le :\n\"distortion (prepartition \u03c0) \u2264 distortion \u03c0\""}
{"gold_output": "theorem StrictAnti.const_mul (hf : StrictAnti f) (ha : 0 < a) : StrictAnti fun x => a * f x :=", "model_response": "lemma strictAntiOn_const_mul_iff (hf : StrictAnti f) (ha : 0 < a) :\nStrictAntiOn (fun x => a * f x) s \u2194 StrictAntiOn f s :="}
{"gold_output": "theorem comp_rangeSplitting (f : \u03b1 \u2192 \u03b2) :\nf \u2218 rangeSplitting f = (\u2191) :=", "model_response": "lemma rangeSplitting_comp_self:\n\"f \\<circ> rangeSplitting f = (\u2191)\""}
{"gold_output": "theorem ediam_preimage (h : \u03b1 \u2243\u1d62 \u03b2) (s : Set \u03b2) : EMetric.diam (h \u207b\u00b9' s) = EMetric.diam s :=", "model_response": "lemma ediam_preimage [simp]: \"EMetric.diam (h \u207b\u00b9' s) = EMetric.diam s\""}
{"gold_output": "theorem isSeparatedFor_and_exists_isAmalgamation_iff_isSheafFor :\n(IsSeparatedFor P R \u2227 \u2200 x : FamilyOfElements P R, x.Compatible \u2192 \u2203 t, x.IsAmalgamation t) \u2194\nIsSheafFor P R :=", "model_response": "lemma sheafify_comp_eq: \"sheafify P \u22d9 F = sheafify (P \u22d9 F)\""}
{"gold_output": "theorem Bounded.mem_lt : \u2200 {t o} {x : \u03b1}, Bounded t o x \u2192 All (\u00b7 < x) t", "model_response": "lemma Bounded_le_mem_lt :\nassumes \"Bounded t o x\"\nshows \"All (\u00b7 \u2264 x) t\""}
{"gold_output": "theorem DifferentiableOn.pow (ha : DifferentiableOn \ud835\udd5c a s) (n : \u2115) :\nDifferentiableOn \ud835\udd5c (fun x => a x ^ n) s :=", "model_response": "lemma differentiableOn_vecCons (ha : DifferentiableOn \ud835\udd5c a s) :\nDifferentiableOn \ud835\udd5c (vecCons a f) s :="}
{"gold_output": "theorem IsOpen.div_left (ht : IsOpen t) : IsOpen (s / t) :=", "model_response": "lemma div_subset_self: \"s / t \\<subseteq> s\""}
{"gold_output": "theorem inf_apply (a : \u03b1) : (f \u2293 g) a = f a \u2293 g a :=", "model_response": "lemma inf_apply [simp]: \"(f \\<sqinter> g) a = f a \\<sqinter> g a\""}
{"gold_output": "theorem coe_normGroupNorm : \u21d1(normGroupNorm E) = norm :=", "model_response": "lemma norm_inv [simp]: \"norm (inverse (x::'a::normed_group_add)) = norm x\""}
{"gold_output": "theorem cos_add_pi_div_two (\u03b8 : Angle) : cos (\u03b8 + \u2191(\u03c0 / 2)) = -sin \u03b8 :=", "model_response": "lemma cos_add_pi_div_two (\u03b8 : Angle) : cos (\u03b8 + \u2191(\u03c0 / 2)) = -sin \u03b8 :="}
{"gold_output": "theorem codisjoint_himp_self_right : Codisjoint x (x \u21e8 y) :=", "model_response": "lemma toNat_surj[simp, intro]: \"surj toNat\""}
{"gold_output": "theorem add_lt_add_iff_right {x y z : PartENat} (hz : z \u2260 \u22a4) : x + z < y + z \u2194 x < y :=", "model_response": "lemma toWithTop_add:\n\"toWithTop (x + y) = toWithTop x + y\""}
{"gold_output": "theorem den_one : ((1 : NumDenSameDeg \ud835\udc9c x).den : A) = 1 :=", "model_response": "lemma num_one : ((1 : NumDenSameDeg \ud835\udc9c x).num : A) = 1 :="}
{"gold_output": "theorem ne_top_of_lt {x y : PartENat} (h : x < y) : x \u2260 \u22a4 :=", "model_response": "lemma ofNat_ne_top : \"ofNat n \\<noteq> \u22a4\""}
{"gold_output": "theorem of_vert_isIso [IsIso snd] [IsIso f] (sq : CommSq fst snd f g) : IsPullback fst snd f g :=", "model_response": "lemma pullback_condition_sq_2 [simp]:\n\"pullback.fst \u226b pullback.snd \u226b pullback.snd = pullback.snd\""}
{"gold_output": "theorem dependent_pair_iff_eq (u v : \u2119 K V) : Dependent ![u, v] \u2194 u = v :=", "model_response": "lemma dependent_injective:\n\"(dependent ![u, v] = dependent ![u', v']) = (u = u' \\<and> v = v')\""}
{"gold_output": "theorem lowerBounds_singleton : lowerBounds {a} = Iic a :=", "model_response": "lemma lowerBounds_insert: \"lowerBounds (insert a s) = Iic a \\<inter> lowerBounds s\""}
{"gold_output": "theorem Equiv.infinite_iff (e : \u03b1 \u2243 \u03b2) : Infinite \u03b1 \u2194 Infinite \u03b2 :=", "model_response": "theorem card_eq (e : \u03b1 \u2243 \u03b2) : (#\u03b1) = (#\u03b2) :="}
{"gold_output": "theorem ofDual_toDual (a : \u03b1) : ofDual (toDual a) = a :=", "model_response": "lemma ofDual_surj:\n\"surj ofDual\""}
{"gold_output": "theorem equitableOn_iff :\nEquitableOn (s : Set \u03b1) f \u2194\n\u2200 a \u2208 s, f a = (\u2211 i in s, f i) / s.card \u2228 f a = (\u2211 i in s, f i) / s.card + 1 :=", "model_response": "lemma equitable_on_iff_eq_sum_div_card_or_add_one :\n\"EquitableOn s f \\<longleftrightarrow> (\\<forall>a\\<in>s. f a = (\\<Sum>i\\<in>s. f i) / s.card \\<or> f a = (\\<Sum>i\\<in>s. f i) / s.card + 1)\""}
{"gold_output": "theorem ker_ofLe (p p' : Submodule R M) (h : p \u2264 p') : ker (ofLe h) = \u22a5 :=", "model_response": "lemma ofLe_injective:\n\"Function.Injective (ofLe h)\""}
{"gold_output": "theorem one_lt_nnreal : 1 < Real.toNNReal p :=", "model_response": "lemma continuous_on_ofReal [continuous_intros]: \"continuous_on s ofReal\""}
{"gold_output": "theorem pairwise_disjoint_Ioo_zpow :\nPairwise (Disjoint on fun n : \u2124 => Ioo (b ^ n) (b ^ (n + 1))) :=", "model_response": "lemma continuousAt_ofReal: \"continuousAt ofReal x\""}
{"gold_output": "theorem smul_mem_iff (s0 : s \u2260 0) : s \u2022 x \u2208 p \u2194 x \u2208 p :=", "model_response": "lemma set_of_smul_eq_self (s0 : s \u2260 0) : { x \u2208 p | s \u2022 x = x } = p :="}
{"gold_output": "theorem nndist_equiv_symm_single_same (i : \u03b9) (b\u2081 b\u2082 : \u03b2 i) :\nnndist ((PiLp.equiv p \u03b2).symm (Pi.single i b\u2081)) ((PiLp.equiv p \u03b2).symm (Pi.single i b\u2082)) =\nnndist b\u2081 b\u2082 :=", "model_response": "lemma nndist_equiv_symm_single (b\u2081 b\u2082 : \u03b2 i) :\n\"nndist ((PiLp.equiv p \u03b2).symm (Pi.single i b\u2081)) ((PiLp.equiv p \u03b2).symm (Pi.single i b\u2082)) =\nnndist b\u2081 b\u2082\""}
{"gold_output": "theorem pow {p : N} (n : \u2115) (h : IsIdempotentElem p) : IsIdempotentElem (p ^ n) :=", "model_response": "lemma is_unit_iff_ker_bot : IsUnit f  \\<longleftrightarrow> ker f = bot :="}
{"gold_output": "theorem single_apply_mem (x) : single a b x \u2208 ({0, b} : Set M) :=", "model_response": "lemma single_def': \"single a b = Finsupp.single a b\""}
{"gold_output": "theorem NeBot.coprod\u1d62 [\u2200 i, Nonempty (\u03b1 i)] {i : \u03b9} (h : NeBot (f i)) : NeBot (Filter.coprod\u1d62 f) :=", "model_response": "lemma coprod\u1d62_univ [simp]: \"Filter.coprod\u1d62 (f : \u2200 _ : univ, Filter \u03b1) = Filter.coprod f\""}
{"gold_output": "theorem isLowerSet_iff_Iic_subset : IsLowerSet s \u2194 \u2200 \u2983a\u2984, a \u2208 s \u2192 Iic a \u2286 s :=", "model_response": "lemma Iic_sSup_eq_iUnion : Iic (sSup S) = \u22c3 a \u2208 S, Iic a :="}
{"gold_output": "theorem map\u2082_distrib_le_right {m : \u03b4 \u2192 \u03b3 \u2192 \u03b5} {n : \u03b1 \u2192 \u03b2 \u2192 \u03b4} {m\u2081 : \u03b1 \u2192 \u03b3 \u2192 \u03b1'} {m\u2082 : \u03b2 \u2192 \u03b3 \u2192 \u03b2'}\n{n' : \u03b1' \u2192 \u03b2' \u2192 \u03b5} (h_distrib : \u2200 a b c, m (n a b) c = n' (m\u2081 a c) (m\u2082 b c)) :\nmap\u2082 m (map\u2082 n f g) h \u2264 map\u2082 n' (map\u2082 m\u2081 f h) (map\u2082 m\u2082 g h) :=", "model_response": "lemma map\u2082_comm: \"map\u2082 m f g = map\u2082 m g f\""}
{"gold_output": "theorem mem_iff_nthLe {a} {l : List \u03b1} : a \u2208 l \u2194 \u2203 n h, nthLe l n h = a :=", "model_response": "lemma nthLe_get_eq:\nassumes \"n < length l\"\nshows \"nthLe l n h = get l \u27e8n, h\u27e9\""}
{"gold_output": "theorem IsNilpotent.neg [Ring R] (h : IsNilpotent x) : IsNilpotent (-x) :=", "model_response": "lemma isNilpotent_neg:\nassumes \"isNilpotent x\"\nshows \"isNilpotent (-x)\""}
{"gold_output": "theorem prime_p : Prime (p : \u2124_[p]) :=", "model_response": "lemma padic_val_p:\n\"padic_val p = 1\""}
{"gold_output": "theorem multiset_sum_sum [Zero M] [AddCommMonoid N] {f : \u03b1 \u2192\u2080 M} {h : \u03b1 \u2192 M \u2192 Multiset N} :\nMultiset.sum (f.sum h) = f.sum fun a b => Multiset.sum (h a b) :=", "model_response": "lemma sum_support_eq_sum_sum:\n\"Multiset.sum (f.sum h) = f.sum fun a => Multiset.sum (h a (f a))\""}
{"gold_output": "theorem norm_int_lt_one_iff_dvd (k : \u2124) : \u2016(k : \u211a_[p])\u2016 < 1 \u2194 \u2191p \u2223 k :=", "model_response": "lemma norm_int_add_le_max:\nfixes x y :: \u2124\nshows \"norm (x + y) \\<le> max (norm x) (norm y)\""}
{"gold_output": "theorem hasSum_expSeries_of_smul_comm [Field \ud835\udd5c] [CharZero \ud835\udd5c] [Ring R] [AddCommGroup M] [Algebra \ud835\udd5c R]\n[Module R M] [Module R\u1d50\u1d52\u1d56 M] [SMulCommClass R R\u1d50\u1d52\u1d56 M] [Module \ud835\udd5c M] [IsScalarTower \ud835\udd5c R M]\n[IsScalarTower \ud835\udd5c R\u1d50\u1d52\u1d56 M] [TopologicalRing R] [TopologicalAddGroup M] [ContinuousSMul R M]\n[ContinuousSMul R\u1d50\u1d52\u1d56 M] (x : tsze R M) (hx : MulOpposite.op x.fst \u2022 x.snd = x.fst \u2022 x.snd)\n{e : R} (h : HasSum (fun n => expSeries \ud835\udd5c R n fun _ => x.fst) e) :\nHasSum (fun n => expSeries \ud835\udd5c (tsze R M) n fun _ => x) (inl e + inr (e \u2022 x.snd)) :=", "model_response": "lemma exp_hasFPowerSeries_zero [simp, intro, fps_intros]:\n\"expHasFPowerSeries \ud835\udd5c (0 :: tsze R M) (expSeries \ud835\udd5c R 0 fun _ => x)\""}
{"gold_output": "theorem card_interedges_div_card (s t : Finset \u03b1) :\n((G.interedges s t).card : \u211a) / (s.card * t.card) = G.edgeDensity s t :=", "model_response": "lemma edge_density_nonneg: \"0 \\<le> G.edgeDensity s t\""}
{"gold_output": "theorem mem_Lp_iff_snorm_lt_top {f : \u03b1 \u2192\u2098[\u03bc] E} : f \u2208 Lp E p \u03bc \u2194 snorm f p \u03bc < \u221e :=", "model_response": "lemma norm_Lp_eq_integral_rpow_norm :\n\"\u2016f\u2016 = (\u222b\u207b x, \u2016f x\u2016 ^ p \u2202\u03bc) ^ (1/p)\""}
{"gold_output": "theorem div_isBoundedUnder_of_isBigO {\u03b1 : Type _} {l : Filter \u03b1} {f g : \u03b1 \u2192 \ud835\udd5c} (h : f =O[l] g) :\nIsBoundedUnder (\u00b7 \u2264 \u00b7) l fun x => \u2016f x / g x\u2016 :=", "model_response": "lemma isBoundedUnder_norm_div [simp]:\n\"isBoundedUnder (\u00b7 \u2264 \u00b7) l (\\<lambda>x. \u2016f x / g x\u2016)\" if \"f =O[l] g\""}
{"gold_output": "theorem mem_interior_iff_mem_nhds {s : Set \u03b1} {a : \u03b1} : a \u2208 interior s \u2194 s \u2208 \ud835\udcdd a :=", "model_response": "lemma interior_eq_nhds: \"interior s = {x. s \\<in> \ud835\udcdd x}\""}
{"gold_output": "theorem sInf_image2_eq_sSup_sSup (h\u2081 : \u2200 b, GaloisConnection (toDual \u2218 l\u2081 b) (swap u b \u2218 ofDual))\n(h\u2082 : \u2200 a, GaloisConnection (toDual \u2218 l\u2082 a) (u a \u2218 ofDual)) :\nsInf (image2 u s t) = u (sSup s) (sSup t) :=", "model_response": "lemma sInf_image2_eq_sSup_sSup:\n\"sInf (image2 u s t) = u (sSup s) (sSup t)\""}
{"gold_output": "theorem cpow_eq_pow (x y : \u2102) : cpow x y = x ^ y :=", "model_response": "lemma continuousAt_ofReal: \"continuousAt ofReal x\""}
{"gold_output": "theorem Sylow.conj_eq_normalizer_conj_of_mem_centralizer [Fact p.Prime] [Finite (Sylow p G)]\n(P : Sylow p G) (x g : G) (hx : x \u2208 (P : Subgroup G).centralizer)\n(hy : g\u207b\u00b9 * x * g \u2208 (P : Subgroup G).centralizer) :\n\u2203 n \u2208 (P : Subgroup G).normalizer, g\u207b\u00b9 * x * g = n\u207b\u00b9 * x * n :=", "model_response": "theorem card_sylow_mod_p [simp]:\n\"card (Sylow p G) = 1 mod p\""}
{"gold_output": "theorem coe_lift_symm_apply (F : Sym2 \u03b1 \u2192 \u03b2) (a\u2081 a\u2082 : \u03b1) :\n(lift.symm F : \u03b1 \u2192 \u03b1 \u2192 \u03b2) a\u2081 a\u2082 = F \u27e6(a\u2081, a\u2082)\u27e7 :=", "model_response": "lemma inv_lift_apply [simp]: \"inv_lift F a\u2081 a\u2082 = F \u27e6(a\u2081, a\u2082)\u27e7\""}
{"gold_output": "theorem tendsto_eval_pi (f : \u2200 i, Filter (\u03b1 i)) (i : \u03b9) : Tendsto (eval i) (pi f) (f i) :=", "model_response": "lemma tendsto_eval_pi' [tendsto_intros]: \"Tendsto (eval i) (pi f) (f i)\""}
{"gold_output": "theorem nsmul_mk [AddMonoid \u03b1] [Preorder \u03b1] [CovariantClass \u03b1 \u03b1 (\u00b7 + \u00b7) (\u00b7 \u2264 \u00b7)] (n : \u2115) {x : \u03b1}\n(hx : 0 \u2264 x) : (n \u2022 (\u27e8x, hx\u27e9 : { x : \u03b1 // 0 \u2264 x })) = \u27e8n \u2022 x, nsmul_nonneg hx n\u27e9 :=", "model_response": "lemma ofNat_eq_ofNat': \"ofNat n = ofNat' n\""}
{"gold_output": "theorem addHom_ext [AddZeroClass N] \u2983f g : (\u03b1 \u2192\u2080 M) \u2192+ N\u2984\n(H : \u2200 x y, f (single x y) = g (single x y)) : f = g :=", "model_response": "lemma single_injective [simp]:\n\"single a1 = single a2 \\<longleftrightarrow> a1 = a2\""}
{"gold_output": "theorem IsCompl.eq_hnot (h : IsCompl a b) : a = \uffe2b :=", "model_response": "lemma compl_eq_iff_eq_hnot : a\u1d9c = b \u2194 a = \uffe2b :="}
{"gold_output": "theorem pow_abs (a : R) (n : \u2115) : |a| ^ n = |a ^ n| :=", "model_response": "lemma abs_prod : \"abs (prod l) = prod (map abs l)\""}
{"gold_output": "theorem NhdsContainBoxes.symm {s : Set \u03b1} {t : Set \u03b2} :\nNhdsContainBoxes s t \u2192 NhdsContainBoxes t s :=", "model_response": "lemma nhds_le_nhds_iff [simp]: \"nhds a \u2264 nhds b \u2194 a = b\""}
{"gold_output": "theorem AEMeasurable.ennnorm {f : \u03b2 \u2192 \u03b1} {\u03bc : Measure \u03b2} (hf : AEMeasurable f \u03bc) :\nAEMeasurable (fun a => (\u2016f a\u2016\u208a : \u211d\u22650\u221e)) \u03bc :=", "model_response": "lemma AEMeasurable.ennnorm' [measurable]:\n\"AEMeasurable (\\<lambda>a. ennreal (norm (f a))) \u03bc\" if \"AEMeasurable f \u03bc\""}
{"gold_output": "theorem stmts\u2081_supportsStmt_mono {S : Finset \u039b} {q\u2081 q\u2082 : Stmt\u2082} (h : q\u2081 \u2208 stmts\u2081 q\u2082)\n(hs : SupportsStmt S q\u2082) : SupportsStmt S q\u2081 :=", "model_response": "lemma stmts\\<^sub>1_supportsStmt_mono:\nassumes \"q\\<^sub>1 \\<in> stmts\\<^sub>1 q\\<^sub>2\" and \"SupportsStmt S q\\<^sub>2\"\nshows \"SupportsStmt S q\\<^sub>1\""}
{"gold_output": "theorem nndist_lineMap_right (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\nnndist (lineMap p\u2081 p\u2082 c) p\u2082 = \u20161 - c\u2016\u208a * nndist p\u2081 p\u2082 :=", "model_response": "lemma nndist_lineMap_left (p\u2081 p\u2082 : P) (c : \ud835\udd5c) :\nnndist (lineMap p\u2081 p\u2082 c) p\u2081 = \u2016c\u2016\u208a * nndist p\u2081 p\u2082 :="}
{"gold_output": "theorem zpowersMulHom_symm_apply [CommGroup G] (f : Multiplicative \u2124 \u2192* G) :\n(zpowersMulHom G).symm f = f (Multiplicative.ofAdd 1) :=", "model_response": "theorem zpowersMulHom_surj : Surjective (zpowersMulHom G) :="}
{"gold_output": "theorem pred_coe_of_ne_bot {a : \u03b1} (h : a \u2260 \u22a5) : pred (\u2191a : WithBot \u03b1) = \u2191(pred a) :=", "model_response": "lemma pred_bot [simp]: \"pred (\u22a5 : WithBot \u03b1) = \u22a5\""}
{"gold_output": "theorem nontrivial_iff_lt [LinearOrder \u03b1] : Nontrivial \u03b1 \u2194 \u2203 x y : \u03b1, x < y :=", "model_response": "lemma Collect_eq_univ_iff [simp]: \"{x\\<in>univ. p x} = univ \\<longleftrightarrow> (\\<exists>x. p x)\""}
{"gold_output": "theorem IsHermitian.submatrix {A : Matrix n n \u03b1} (h : A.IsHermitian) (f : m \u2192 n) :\n(A.submatrix f f).IsHermitian :=", "model_response": "lemma submatrix_isUnit_iff_injective:\n\"isUnit (submatrix f f A) \u2194 Injective f\""}
{"gold_output": "theorem continuous_integral : Continuous fun f : \u03b1 \u2192\u2081[\u03bc] E => \u222b a, f a \u2202\u03bc :=", "model_response": "lemma integral_add_measure:\nfixes f :: \"'a \\<Rightarrow> 'b::{banach, second_countable_topology}\"\nshows \"integral\\<^sup>L (measure_sum \\<mu> \\<nu>) f = integral\\<^sup>L \\<mu> f + integral\\<^sup>L \\<nu> f\""}
{"gold_output": "theorem inf_assoc (a b c : \u03b1) : a \u2293 b \u2293 c = a \u2293 (b \u2293 c) :=", "model_response": "lemma inf_assoc: \"a \\<sqinter> b \\<sqinter> c = a \\<sqinter> (b \\<sqinter> c)\""}
{"gold_output": "theorem sign_prod_list_swap {l : List (Perm \u03b1)} (hl : \u2200 g \u2208 l, IsSwap g) :\nsign l.prod = (-1) ^ l.length :=", "model_response": "lemma sign_prod_list_swap (l : List (Perm \u03b1)) (hl : \u2200 g \u2208 l, IsSwap g) :\nsign l.prod = (-1) ^ l.length :="}
{"gold_output": "theorem orbit_subgroup_one_eq_self : MulAction.orbit s (1 : \u03b1) = s :=", "model_response": "theorem MulAction.orbit_subgroup_one_eq_self [simp]:\n\"MulAction.orbit (subgroup.subgroupOf G s) (1 : \u03b1) = subgroup.subgroupOf G s\""}
{"gold_output": "theorem mapRange_sub [SubNegZeroMonoid G] [SubNegZeroMonoid H] {f : G \u2192 H} {hf : f 0 = 0}\n(hf' : \u2200 x y, f (x - y) = f x - f y) (v\u2081 v\u2082 : \u03b1 \u2192\u2080 G) :\nmapRange f hf (v\u2081 - v\u2082) = mapRange f hf v\u2081 - mapRange f hf v\u2082 :=", "model_response": "lemma mapRange_sub [simp]:\n\"mapRange f hf (v\\<^sub>1 - v\\<^sub>2) = mapRange f hf v\\<^sub>1 - mapRange f hf v\\<^sub>2\""}
{"gold_output": "theorem isAdic_iff [top : TopologicalSpace R] [TopologicalRing R] {J : Ideal R} :\nIsAdic J \u2194\n(\u2200 n : \u2115, IsOpen ((J ^ n : Ideal R) : Set R)) \u2227\n\u2200 s \u2208 \ud835\udcdd (0 : R), \u2203 n : \u2115, ((J ^ n : Ideal R) : Set R) \u2286 s :=", "model_response": "lemma toAddSubmonoid_injective :\n\"Function.Injective (toAddSubmonoid : Submodule R M \u2192 AddSubmonoid M)\""}
{"gold_output": "theorem Valid'.of_lt {t : Ordnode \u03b1} {x : \u03b1} {o\u2081 o\u2082} (H : Valid' o\u2081 t o\u2082) (h\u2081 : Bounded nil o\u2081 x)\n(h\u2082 : All (\u00b7 < x) t) : Valid' o\u2081 t x :=", "model_response": "lemma valid'_cons_of_bounded :\nassumes \"Valid' o\u2081 t o\u2082\"\nand     \"bounded nil o\u2081 x\"\nand     \"all_left t x\"\nshows \"Valid' o\u2081 t x\""}
{"gold_output": "theorem neg_mem_iff : -x \u2208 p \u2194 x \u2208 p :=", "model_response": "lemma norm_le_subset_iff : {x \\<in> space M. norm x \\<le> r} \\<subseteq> p :="}
{"gold_output": "theorem eq_of_irreducible_of_monic [Nontrivial B] {p : A[X]} (hp1 : Irreducible p)\n(hp2 : Polynomial.aeval x p = 0) (hp3 : p.Monic) : p = minpoly A x :=", "model_response": "lemma degree_minpoly [simp]:\n\"degree (minpoly A x) = degree p\""}
{"gold_output": "theorem toOuterMeasure_apply_singleton (a : \u03b1) : p.toOuterMeasure {a} = p a :=", "model_response": "lemma toOuterMeasure_injective : Injective p.toOuterMeasure :="}
{"gold_output": "theorem ext_iff {\u03c6\u2081 \u03c6\u2082 : A \u2192\u2090[R] B} : \u03c6\u2081 = \u03c6\u2082 \u2194 \u2200 x, \u03c6\u2081 x = \u03c6\u2082 x :=", "model_response": "lemma toFun_inj : Function.Injective (toFun :: (A \u2192\u2090[R] B) \u2192 A \u2192 B) :="}
{"gold_output": "theorem disjoint_iff (h : IsGenericPoint x S) (hU : IsOpen U) : Disjoint S U \u2194 x \u2209 U :=", "model_response": "lemma setOf_eq_connectedComponent [simp]:\n\"{x. x \\<in> S \\<and> connectedComponent x = {x}} = connectedComponent x\""}
{"gold_output": "theorem keys_erase (a : \u03b1) (s : AList \u03b2) : (erase a s).keys = s.keys.erase a :=", "model_response": "lemma keys_map_entries [simp]: \"keys (AList.map_entries f s) = keys s\""}
{"gold_output": "theorem mem_inf {I J : Ideal R} {x : R} : x \u2208 I \u2293 J \u2194 x \u2208 I \u2227 x \u2208 J :=", "model_response": "lemma set_of_mem_eq: \"{ x \\<in> carrier R. x \\<in> I } = I\""}
{"gold_output": "theorem finAddFlip_apply_castAdd (k : Fin m) (n : \u2115) :\nfinAddFlip (Fin.castAdd n k) = Fin.natAdd n k :=", "model_response": "lemma surj_finAddFlip: \"surj finAddFlip\""}
{"gold_output": "theorem prod_mk_mem_compRel {a b c : \u03b1} {s t : Set (\u03b1 \u00d7 \u03b1)} (h\u2081 : (a, c) \u2208 s) (h\u2082 : (c, b) \u2208 t) :\n(a, b) \u2208 s \u25cb t :=", "model_response": "lemma Rel_comp_Prod_swap: \"Rel O Prod.swap = Prod.swap O Rel\""}
{"gold_output": "theorem LiftRel.swap (R : \u03b1 \u2192 \u03b2 \u2192 Prop) : swap (LiftRel R) = LiftRel (swap R) :=", "model_response": "lemma LiftRel_eq_iff [simp]:\nassumes \"symp R\"\nshows \"LiftRel R = LiftRel (rel_option R) \u2194 R = (=)\""}
{"gold_output": "theorem convex_uIcc (r s : \u03b2) : Convex \ud835\udd5c (uIcc r s) :=", "model_response": "lemma convex_on_uIcc: \"convex_on \ud835\udd5c (uIcc r s) u\""}
{"gold_output": "theorem IsG\u03b4.union {s t : Set \u03b1} (hs : IsG\u03b4 s) (ht : IsG\u03b4 t) : IsG\u03b4 (s \u222a t) :=", "model_response": "lemma set_comprehension_union_disj :\n\"{x \\<in> s. p x} \\<union> {x \\<in> t. p x} = {x. (x \\<in> s \\<longrightarrow> p x) \\<and> (x \\<in> t \\<longrightarrow> p x)}\""}
{"gold_output": "theorem infEdist_zero_of_mem (h : x \u2208 s) : infEdist x s = 0 :=", "model_response": "lemma infEdist_zero_iff: \"infEdist x s = 0 \\<longleftrightarrow> subsingleton s \\<or> x \\<in> s\""}
{"gold_output": "theorem reflection_reflection (p : E) : reflection K (reflection K p) = p :=", "model_response": "lemma reflection_apply_self [simp]: \"reflection K (reflection K p) = -p\""}
{"gold_output": "theorem mem_Icc : x \u2208 Icc a b \u2194 a \u2264 x \u2227 x \u2264 b :=", "model_response": "lemma toIcoMod_eq_self: \"toIcoMod hp a b = b \u2194 a \u2264 b\""}
{"gold_output": "theorem mul_lt_mul_left' [CovariantClass \u03b1 \u03b1 (\u00b7 * \u00b7) (\u00b7 < \u00b7)] {b c : \u03b1} (bc : b < c) (a : \u03b1) :\na * b < a * c :=", "model_response": "lemma to_nat_sub [simp]: \"to_nat (b - c) = to_nat b - to_nat c\""}
{"gold_output": "theorem rat_div (h : Irrational x) {q : \u211a} (hq : q \u2260 0) : Irrational (q / x) :=", "model_response": "theorem infinite_liouville_set [simp]:\n\"infinite {x | liouvilleWith p x}\""}
{"gold_output": "theorem trinomial_leadingCoeff (hkm : k < m) (hmn : m < n) (hw : w \u2260 0) :\n(trinomial k m n u v w).leadingCoeff = w :=", "model_response": "lemma leadingCoeff_C_mul [simp]:\n\"leadingCoeff (C a * p) = a * leadingCoeff p\""}
{"gold_output": "theorem coe_neg : \u2200 {x : \u211a}, (\u2191(-x) : \u211a_[p]) = -\u2191x :=", "model_response": "lemma zero_padic_val_eq_zero[simp]: \"padicValRat p 0 = 0\""}
{"gold_output": "theorem star_mul [Monoid \u03b1] [StarSemigroup \u03b1] (s t : Set \u03b1) : (s * t)\u22c6 = t\u22c6 * s\u22c6 :=", "model_response": "lemma star_mul_comm: \"(s * t)\u22c6 = t\u22c6 * s\u22c6\""}
{"gold_output": "theorem OneOneEquiv.congr_left {\u03b1 \u03b2 \u03b3} [Primcodable \u03b1] [Primcodable \u03b2] [Primcodable \u03b3]\n{p : \u03b1 \u2192 Prop} {q : \u03b2 \u2192 Prop} {r : \u03b3 \u2192 Prop} (h : OneOneEquiv p q) :\nOneOneEquiv p r \u2194 OneOneEquiv q r :=", "model_response": "theorem of_bool_prim [simp]: \"prim_recfn 1 of_bool\""}
{"gold_output": "theorem unique_one {\u03b1 : Type _} [Unique \u03b1] [One \u03b1] : default = (1 : \u03b1) :=", "model_response": "lemma unique_one_eq_one [simp]:\nassumes \"unique \u03b1\" \"one \u03b1\"\nshows \"default = (1 : \u03b1)\""}
{"gold_output": "theorem nat_lt_one_iff (m : \u2115) : padicNorm p m < 1 \u2194 p \u2223 m :=", "model_response": "lemma padicValNat_def':\n\"padicValNat p n = multiplicity p n\""}
{"gold_output": "theorem all_node' {P l x r} : @All \u03b1 P (node' l x r) \u2194 All P l \u2227 P x \u2227 All P r :=", "model_response": "lemma all_butlast_append [simp]:\nassumes \"all_butlast xs \\<Turnstile> P\"\nshows \"xs @ ys \\<Turnstile> P\""}
{"gold_output": "theorem liftOn'_mk {P : Sort v} (p q : K[X]) (f : \u2200 _p _q : K[X], P) (f0 : \u2200 p, f p 0 = f 0 1)\n(H : \u2200 {p q a} (_hq : q \u2260 0) (_ha : a \u2260 0), f (a * p) (a * q) = f p q) :\n(RatFunc.mk p q).liftOn' f @H = f p q :=", "model_response": "lemma liftOn'_mk [simp]: \"liftOn' (mk p q) f f0 H = f p q\""}
{"gold_output": "theorem zero_smul_subset (t : Finset \u03b2) : (0 : Finset \u03b1) \u2022 t \u2286 0 :=", "model_response": "lemma smul_empty [simp]: \"0 \u2022 s = \u2205\""}
{"gold_output": "theorem compatibility_N\u2082_N\u2081_karoubi :\nN\u2082 \u22d9 (karoubiChainComplexEquivalence C \u2115).functor =\nkaroubiFunctorCategoryEmbedding SimplexCategory\u1d52\u1d56 C \u22d9\nN\u2081 \u22d9 (karoubiChainComplexEquivalence (Karoubi C) \u2115).functor \u22d9\nFunctor.mapHomologicalComplex (KaroubiKaroubi.equivalence C).inverse _ :=", "model_response": "lemma karoubiChainComplexEquivalence_inv_to_functor :\n\"(karoubiChainComplexEquivalence C \u2115).functor \u22d9 (karoubiChainComplexEquivalence C \u2115).inv.toFunctor =\n\ud835\udfed _\""}
{"gold_output": "theorem LinearMap.toMatrix_comp [Fintype l] [DecidableEq m] (f : M\u2082 \u2192\u2097[R] M\u2083) (g : M\u2081 \u2192\u2097[R] M\u2082) :\nLinearMap.toMatrix v\u2081 v\u2083 (f.comp g) =\nLinearMap.toMatrix v\u2082 v\u2083 f \u2b1d LinearMap.toMatrix v\u2081 v\u2082 g :=", "model_response": "lemma LinearMap.toMatrix_id [simp]:\n\"LinearMap.toMatrix v\u2081 v\u2081 (id : M\u2081 \u2192\u2097[R] M\u2081) = 1\""}
{"gold_output": "theorem preimage_interior (h : \u03b1 \u2243\u209c \u03b2) (s : Set \u03b2) : h \u207b\u00b9' interior s = interior (h \u207b\u00b9' s) :=", "model_response": "lemma preimage_closure [simp]: \"f \u207b\u00b9' closure s = closure (f \u207b\u00b9' s)\""}
{"gold_output": "theorem vandermonde_apply {n : \u2115} (v : Fin n \u2192 R) (i j) : vandermonde v i j = v i ^ (j : \u2115) :=", "model_response": "lemma vandermonde_inj_zero (n : \u2115) : Injective (vandermonde (fun _ => 0 : Fin n \u2192 R)) :="}
{"gold_output": "theorem leftInverse_symm (e : A\u2081 \u2243\u2090[R] A\u2082) : Function.LeftInverse e.symm e :=", "model_response": "lemma quotQuotEquivQuotOfRingEquiv_symm (e : A\u2081 \u2243+* A\u2082) :\n(quotQuotEquivQuotOfRingEquiv I J e).symm = quotQuotEquivQuotOfRingEquiv J I e.symm :="}
{"gold_output": "theorem condition (a) : I.fst a \u226b K.\u03c0 (I.fstFrom a) = I.snd a \u226b K.\u03c0 (I.sndFrom a) :=", "model_response": "lemma fst_\u03c0_eq_snd_\u03c0 [simp]:\n\"(prod.fst : f * g \u27f6 _) \u226b K.\u03c0 _ = (prod.snd : f * g \u27f6 _) \u226b K.\u03c0 _\""}
{"gold_output": "theorem coe_toRelEmbedding (f : r \u2243r s) : (f.toRelEmbedding : \u03b1 \u2192 \u03b2) = f :=", "model_response": "lemma toRelEmbedding_injective: \"injective f.toRelEmbedding\""}
{"gold_output": "theorem update_noteq {a a' : \u03b1} (h : a \u2260 a') (v : \u03b2 a') (f : \u2200 a, \u03b2 a) : update f a' v a = f a :=", "model_response": "lemma continuousWithinAt_iff_tendsto_uniformity_codomain:\n\"continuousWithinAt f s a \u2194 ((\\<lambda>x. (f x, f a)) \\<longlongrightarrow> (f a, f a)) (at a within s)\""}
{"gold_output": "theorem isBigO_const_mul_right_iff {g : \u03b1 \u2192 \ud835\udd5c} {c : \ud835\udd5c} (hc : c \u2260 0) :\n(f =O[l] fun x => c * g x) \u2194 f =O[l] g :=", "model_response": "lemma isBigO_const_mul_right [simp]: \"f =O[l] (\\<lambda>x. c * g x) \\<longleftrightarrow> f =O[l] g\"\nif \"c \\<noteq> 0\" for c :: \ud835\udd5c"}
{"gold_output": "theorem sInter_union_sInter {S T : Set (Set \u03b1)} :\n\u22c2\u2080 S \u222a \u22c2\u2080 T = \u22c2 p \u2208 S \u00d7\u02e2 T, (p : Set \u03b1 \u00d7 Set \u03b1).1 \u222a p.2 :=", "model_response": "lemma sInter_union_sInter:\n\"\u22c2\u2080 S \u222a \u22c2\u2080 T = \u22c2 p \u2208 S \u00d7\u02e2 T, (p : Set \u03b1 \u00d7 Set \u03b1).1 \u222a p.2\""}
{"gold_output": "theorem exponent_eq_max'_orderOf [Fintype G] :\nexponent G = ((@Finset.univ G _).image orderOf).max' \u27e81, by simp\u27e9 :=", "model_response": "theorem exponent_eq_max_orderOf [simp]:\n\"exponent G = Finset.univ.max' (orderOf :: G \\<Rightarrow> _) 1\""}
{"gold_output": "theorem integrable_map_equiv (f : \u03b1 \u2243\u1d50 \u03b4) (g : \u03b4 \u2192 \u03b2) :\nIntegrable g (Measure.map f \u03bc) \u2194 Integrable (g \u2218 f) \u03bc :=", "model_response": "lemma integrable_equiv_iff [simp]:\n\"integrable \\<Omega> f \\<mu> \\<longleftrightarrow> integrable \\<Omega> (f \\<circ> (f :: _ \\<Rightarrow> _)) \\<mu>\""}
{"gold_output": "theorem exp_continuous : Continuous (exp \ud835\udd42 : \ud835\udd38 \u2192 \ud835\udd38) :=", "model_response": "lemma continuousOn_exp [continuous_intros]: \"ContinuousOn (exp \ud835\udd42) (s :: '\ud835\udd38 set)\""}
{"gold_output": "theorem AntitoneOn.exists_antitone_extension (h : AntitoneOn f s) (hl : BddBelow (f '' s))\n(hu : BddAbove (f '' s)) : \u2203 g : \u03b1 \u2192 \u03b2, Antitone g \u2227 EqOn f g s :=", "model_response": "lemma continuous_within_iff_snd_continuous_within:\n\"continuous (at x within s) f \\<longleftrightarrow> continuous (at x within s) (\\<lambda>x'. (f x', f x))\""}
{"gold_output": "theorem tsum_prod {f : \u03b1 \u2192 \u03b2 \u2192 \u211d\u22650\u221e} : (\u2211' p : \u03b1 \u00d7 \u03b2, f p.1 p.2) = \u2211' (a) (b), f a b :=", "model_response": "lemma tsum_prod_eq_double_sum :\n\"(\\<Sum>' p : \u03b1 \\<times> \u03b2, f p.1 p.2) = (\\<Sum>' (a) (b), f a b)\""}
{"gold_output": "theorem Surjective.hasRightInverse (hf : Surjective f) : HasRightInverse f :=", "model_response": "lemma has_right_inverse_iff_has_left_inverse:\nassumes \"surjective f\"\nshows \"has_right_inverse f \\<longleftrightarrow> has_left_inverse f\""}
{"gold_output": "theorem inter_left_comm (s\u2081 s\u2082 s\u2083 : Finset \u03b1) : s\u2081 \u2229 (s\u2082 \u2229 s\u2083) = s\u2082 \u2229 (s\u2081 \u2229 s\u2083) :=", "model_response": "lemma union_inter_left_comm: (s\u2081 \u222a s\u2082) \u2229 s\u2083 = (s\u2082 \u222a s\u2081) \u2229 s\u2083 :="}
{"gold_output": "theorem has_fderiv_at_filter_real_equiv {L : Filter E} :\nTendsto (fun x' : E => \u2016x' - x\u2016\u207b\u00b9 * \u2016f x' - f x - f' (x' - x)\u2016) L (\ud835\udcdd 0) \u2194\nTendsto (fun x' : E => \u2016x' - x\u2016\u207b\u00b9 \u2022 (f x' - f x - f' (x' - x))) L (\ud835\udcdd 0) :=", "model_response": "lemma tendsto_slope_norm_zero_iff_norm_slope_zero:\n\"Tendsto (fun x' : E => (\u2016x' - x\u2016\u207b\u00b9 : \u211d) * \u2016f x' - f x - f' (x' - x)\u2016) L (\ud835\udcdd 0) \u2194\nTendsto (fun x' : E => \u2016x' - x\u2016\u207b\u00b9 \u2022 (f x' - f x - f' (x' - x))) L (\ud835\udcdd 0)\""}
{"gold_output": "theorem inv_add_inv_conj_nnreal : 1 / Real.toNNReal p + 1 / Real.toNNReal q = 1 :=", "model_response": "lemma one_div_add_one_div_conj : \"1 / Real.toNNReal p + 1 / Real.toNNReal q = 1\""}
{"gold_output": "theorem _root_.Set.Finite.nullMeasurableSet_biInter {f : \u03b9 \u2192 Set \u03b1} {s : Set \u03b9} (hs : s.Finite)\n(h : \u2200 b \u2208 s, NullMeasurableSet (f b) \u03bc) : NullMeasurableSet (\u22c2 b \u2208 s, f b) \u03bc :=", "model_response": "lemma integrableOn_biUnion [simp]:\n\"IntegrableOn f (\\<Union>i\\<in>s. t i) \\<mu> \\<longleftrightarrow> (\\<forall>i\\<in>s. IntegrableOn f (t i) \\<mu>)\""}
{"gold_output": "theorem dist_pos {x y : \u03b3} : 0 < dist x y \u2194 x \u2260 y :=", "model_response": "lemma dist_pos_iff: \"0 < dist x y \u2194 x \u2260 y\""}
{"gold_output": "theorem Filter.Tendsto.continuousAt_of_equicontinuousAt {l : Filter \u03b9} [l.NeBot] {F : \u03b9 \u2192 X \u2192 \u03b1}\n{f : X \u2192 \u03b1} {x\u2080 : X} (h\u2081 : Tendsto F l (\ud835\udcdd f)) (h\u2082 : EquicontinuousAt F x\u2080) :\nContinuousAt f x\u2080 :=", "model_response": "lemma continuousAt_def':\nfixes f :: \"'a::metric_space \\<Rightarrow> 'b::metric_space\"\nshows \"continuousAt f x\\<^sub>0 \\<longleftrightarrow> (\\<forall>\\<epsilon>>0. \\<exists>\\<delta>>0. \\<forall>\\<^sub>F x in l. dist x x\\<^sub>0 < \\<delta> \\<longrightarrow> dist (f x) (f x\\<^sub>0) < \\<epsilon>)\""}
{"gold_output": "theorem inclusion_self (x : s) : inclusion Subset.rfl x = x :=", "model_response": "lemma inclusion_injective : Injective (inclusion (Subset.refl s)) :="}
{"gold_output": "theorem binaryCofan_inr {A B : C} [MonoCoprod C] (c : BinaryCofan A B) (hc : IsColimit c) :\nMono c.inr :=", "model_response": "lemma binaryCofan_inr_snd {A B : C} [MonoCoprod C] (c : BinaryCofan A B) (hc : IsColimit c) :\ncofan_inr (binaryCofan c) \u226b c.snd = c.inr :="}
{"gold_output": "theorem ListBlank.head_map {\u0393 \u0393'} [Inhabited \u0393] [Inhabited \u0393'] (f : PointedMap \u0393 \u0393')\n(l : ListBlank \u0393) : (l.map f).head = f l.head :=", "model_response": "lemma ListBlank_head_cons [simp]: \"ListBlank.head (ListBlank.cons a l) = a\""}
{"gold_output": "theorem ofFractionRing_algebraMap (x : K[X]) :\nofFractionRing (algebraMap _ (FractionRing K[X]) x) = algebraMap _ _ x :=", "model_response": "lemma ofFractionRing_algebraMap (x : K) :\nofFractionRing (FractionRing.of (algebraMap _ _ x)) = algebraMap _ _ x :="}
{"gold_output": "theorem Icc_eq_range' : Icc a b = \u27e8List.range' a (b + 1 - a), List.nodup_range' _ _\u27e9 :=", "model_response": "lemma Ioc_eq_range' :\n\"{x. a < x \\<and> x \\<le> b} = \u27e8List.range' a (b + 1 - a), List.nodup_range' _ _\u27e9\""}
{"gold_output": "theorem map_le_iff_le_comap {f : G \u2192* N} {K : Subgroup G} {H : Subgroup N} :\nK.map f \u2264 H \u2194 K \u2264 H.comap f :=", "model_response": "theorem map_iInter_le_iInter_comap: \"(map f \u22c2 s | P s) \u2264 \u22c2 t | P t, comap f t :="}
{"gold_output": "theorem rootMultiplicity_eq_multiplicity (p : R[X]) (a : R) :\nrootMultiplicity a p =\nif h0 : p = 0 then 0 else (multiplicity (X - C a) p).get (multiplicity_X_sub_C_finite a h0) :=", "model_response": "lemma rootMultiplicity_eq_multiplicity':\n\"rootMultiplicity a p = (multiplicity (X - C a) p).get (multiplicity_X_sub_C_finite a (by simp [p]))\""}
{"gold_output": "theorem nhdsWithin_Iio_basis' {a : \u03b1} (h : \u2203 b, b < a) : (\ud835\udcdd[<] a).HasBasis (\u00b7 < a) (Ioo \u00b7 a) :=", "model_response": "lemma nhdsWithin_Iio_basis: \"basis_nhds_within (<) a {l <.. a}\""}
{"gold_output": "theorem isDedekindDomain_iff (K : Type _) [Field K] [Algebra A K] [IsFractionRing A K] :\nIsDedekindDomain A \u2194\nIsNoetherianRing A \u2227\nDimensionLEOne A \u2227 \u2200 {x : K}, IsIntegral A x \u2192 \u2203 y, algebraMap A K y = x :=", "model_response": "lemma toPrimeSpectrum_injective:\n\"injective toPrimeSpectrum\""}
{"gold_output": "theorem units_eq_one (u : (Associates \u03b1)\u02e3) : u = 1 :=", "model_response": "theorem mk_one (a : Associates \u03b1) : mk a = 1 :="}
{"gold_output": "theorem intervalIntegrable_vComp (t\u2081 t\u2082 : \u211d) : IntervalIntegrable f.vComp volume t\u2081 t\u2082 :=", "model_response": "lemma interval_integrable [intro]: \"IntervalIntegrable f volume t\\<^sub>1 t\\<^sub>2 \\<mu>\""}
{"gold_output": "theorem comp_apply (p : Seminorm \ud835\udd5c\u2082 E\u2082) (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) (x : E) : (p.comp f) x = p (f x) :=", "model_response": "lemma zero_comp (f : E \u2192\u209b\u2097[\u03c3\u2081\u2082] E\u2082) : (0 : Seminorm \ud835\udd5c\u2082 E\u2082).comp f = 0 :="}
{"gold_output": "theorem map_isLeast : IsLeast t a \u2192 IsGreatest (f '' t) (f a) :=", "model_response": "lemma isCont_leftLim_eq_rightLim: \"isCont f x \\<longleftrightarrow> leftLim f x = rightLim f x\""}
{"gold_output": "theorem b_id_helper {a b : \u2115} (ha : 2 \u2264 a) (hb : 2 < b) : 2 \u2264 (a ^ b + 1) / (a + 1) :=", "model_response": "lemma card_snd_least_factor_le_divisor:\nassumes \"2 \\<le> a\" \"2 < b\"\nshows \"card (snd_least_factor a b) \\<le> (smallest_divisor a)\""}
{"gold_output": "theorem Embedding.continuous {f : \u03b1 \u2192 \u03b2} (hf : Embedding f) : Continuous f :=", "model_response": "lemma continuous_at_coe_iff: \"continuous (f :: X \u2192 Y) x \u2194 continuousAt f x\""}
{"gold_output": "theorem symm_apply_mem_iff (h : e.IsImage s t) : \u2200 \u2983y\u2984, y \u2208 e.target \u2192 (e.symm y \u2208 s \u2194 y \u2208 t) :=", "model_response": "lemma symm_symm_eq [simp]: \"e.symm.symm = e\""}
{"gold_output": "theorem eq_of_fst_eq_fst (h : (x : \u03b1 \u00d7 \u03b1).fst = (y : \u03b1 \u00d7 \u03b1).fst) : x = y :=", "model_response": "lemma fst_eq_fst:\nassumes \"x.fst = y.fst\"\nshows \"x = y\""}
{"gold_output": "theorem pullbackIsoPullback_hom_fst (p : pullback f g) :\n((pullbackIsoPullback f g).hom p : X \u00d7 Y).fst = (pullback.fst : _ \u27f6 X) p :=", "model_response": "lemma pullbackIsoPullback_hom_fst [simp]:\n\"pullback.fst \u226b (pullbackIsoPullback f g).hom = pullback.fst\""}
{"gold_output": "theorem comapDomain_smul [AddMonoid M] [Monoid R] [DistribMulAction R M] {f : \u03b1 \u2192 \u03b2} (r : R)\n(v : \u03b2 \u2192\u2080 M) (hfv : Set.InjOn f (f \u207b\u00b9' \u2191v.support))\n(hfrv : Set.InjOn f (f \u207b\u00b9' \u2191(r \u2022 v).support) :=\nhfv.mono <| Set.preimage_mono <| Finset.coe_subset.mpr support_smul) :\ncomapDomain f (r \u2022 v) hfrv = r \u2022 comapDomain f v hfv :=", "model_response": "lemma support_smul_subset [simp]: \"support (r \u2022 v) \\<subseteq> support v\""}
{"gold_output": "theorem mapIdxMAuxSpec_cons {\u03b1 \u03b2} (f : \u2115 \u2192 \u03b1 \u2192 m \u03b2) (start : \u2115) (a : \u03b1) (as : List \u03b1) :\nmapIdxMAuxSpec f start (a :: as) = cons <$> f start a <*> mapIdxMAuxSpec f (start + 1) as :=", "model_response": "lemma mapIdxMAuxSpec_eq_mapIdxMAux:\nassumes \"length as = n\"\nshows \"mapIdxMAuxSpec f start as = mapIdxMAux f start as\""}
{"gold_output": "theorem continuous_eval : Continuous fun p :\nContinuousMultilinearMap \ud835\udd5c E G \u00d7 \u2200 i, E i => p.1 p.2 :=", "model_response": "lemma continuous_eval' : \"continuous fun p : (ContinuousMultilinearMap \ud835\udd5c E G) \u00d7 (\u2200 i, E i) => p.1 p.2\""}
{"gold_output": "theorem natTrailingDegree_le_natTrailingDegree {hq : q \u2260 0}\n(hpq : p.trailingDegree \u2264 q.trailingDegree) : p.natTrailingDegree \u2264 q.natTrailingDegree :=", "model_response": "lemma natTrailingDegree_eq_trailingDegree :\n\"nat (trailingDegree p) = natTrailingDegree p\""}
{"gold_output": "theorem cycleOf_apply_of_not_sameCycle : \u00acSameCycle f x y \u2192 cycleOf f x y = y :=", "model_response": "lemma cycleOf_apply_eq_self_iff :\n\"\\<not> SameCycle f x y \\<Longrightarrow> (cycleOf f x) y = y \\<longleftrightarrow> x = y\""}
{"gold_output": "theorem arctan_eq_arcsin (x : \u211d) : arctan x = arcsin (x / sqrt (1 + x ^ 2)) :=", "model_response": "lemma arctan_eq_iff [simp]: \"arctan x = arctan y \u2194 x = y\""}
{"gold_output": "theorem Codisjoint.map (h : Codisjoint a b) : Codisjoint (f a) (f b) :=", "model_response": "lemma inj: \"inj f\""}
{"gold_output": "theorem arccos_zero : arccos 0 = \u03c0 / 2 :=", "model_response": "lemma arccos_zero [simp]: \"arccos 0 = \u03c0 / 2\""}
{"gold_output": "theorem support_add [DecidableEq \u03c3] : (p + q).support \u2286 p.support \u222a q.support :=", "model_response": "lemma support_add: \"support (p + q) \\<subseteq> support p \u222a support q\""}
{"gold_output": "theorem image_compl [BooleanAlgebra \u03b1] (hs : IsAntichain (\u00b7 \u2264 \u00b7) s) :\nIsAntichain (\u00b7 \u2264 \u00b7) (compl '' s) :=", "model_response": "lemma is_antichain_Iic [simp, intro]: \"IsAntichain (\u00b7 \u2264 \u00b7) {x. x \u2264 a}\""}
{"gold_output": "theorem mk_neg : (mk (-x) : M \u29f8 p) = -(mk x : M \u29f8 p) :=", "model_response": "lemma mk_inj: \"inj mk\""}
{"gold_output": "theorem ciInf_le' (f : \u03b9 \u2192 \u03b1) (i : \u03b9) : iInf f \u2264 f i :=", "model_response": "lemma iInf_le' : (\u2a05 (i) (_ : i \\<in> s), f i) \\<le> f i :="}
{"gold_output": "theorem lintegral_eq_lintegral_meas_lt (\u03bc : Measure \u03b1) [SigmaFinite \u03bc] (f_nn : 0 \u2264 f)\n(f_mble : Measurable f) :\n(\u222b\u207b \u03c9, ENNReal.ofReal (f \u03c9) \u2202\u03bc) = \u222b\u207b t in Ioi 0, \u03bc {a : \u03b1 | t < f a} :=", "model_response": "lemma integrable_iff_integrable_lebesgue_on:\n\"integrable \\<Omega> f \\<longleftrightarrow> Integrable.integrable (lebesgue_on \\<Omega>) f\""}
{"gold_output": "theorem nodup_append_comm {l\u2081 l\u2082 : List \u03b1} : Nodup (l\u2081 ++ l\u2082) \u2194 Nodup (l\u2082 ++ l\u2081) :=", "model_response": "lemma nodup_rotate :\nassumes \"nodup l\"\nshows \"nodup (rotate n l)\""}
{"gold_output": "theorem head_neg (a : Fin n.succ \u2192 \u03b1) : vecHead (-a) = -vecHead a :=", "model_response": "lemma head_neg [simp]: \"vecHead (- a) = - vecHead a\""}
{"gold_output": "theorem isOpen_iff_mem_nhds {s : Set \u03b1} : IsOpen s \u2194 \u2200 a \u2208 s, s \u2208 \ud835\udcdd a :=", "model_response": "lemma isCont_iff_leftLim_eq_rightLim: \"isCont f x \\<longleftrightarrow> leftLim f x = rightLim f x\""}
{"gold_output": "theorem map_comp {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} : Sym2.map (g \u2218 f) = Sym2.map g \u2218 Sym2.map f :=", "model_response": "lemma map_comp: \"Sym2.map f \u2218 Sym2.map g = Sym2.map (g \u2218 f)\""}
{"gold_output": "theorem LeftInvOn.injOn (h : LeftInvOn f\u2081' f s) : InjOn f s :=", "model_response": "lemma injOn_f: \"injOn f s\""}
{"gold_output": "theorem SurjOn.rightInvOn_invFunOn [Nonempty \u03b1] (h : SurjOn f s t) :\nRightInvOn (invFunOn f s) f t :=", "model_response": "lemma rightInvOn_invFunOn [simp]:\nassumes \"surjOn f s t\"\nshows \"rightInvOn (invFunOn f s) f t\""}
{"gold_output": "theorem map_le_iff_le_comap {f : M \u2192\u2099* N} {S : Subsemigroup M} {T : Subsemigroup N} :\nS.map f \u2264 T \u2194 S \u2264 T.comap f :=", "model_response": "theorem map_le_iff_le_comap : S.map f \u2264 T \u2194 S \u2264 T.comap f :="}
{"gold_output": "theorem orderOf_dvd_nat_card {G : Type _} [Group G] {x : G} : orderOf x \u2223 Nat.card G :=", "model_response": "lemma orderOf_one [simp]: \"orderOf (1 : G) = 1\""}
{"gold_output": "theorem isCoatomic_of_isAtomic_of_complementedLattice_of_isModular [IsAtomic \u03b1] :\nIsCoatomic \u03b1 :=", "model_response": "theorem atomic_complemented_modular_imp_coatomic :\n\"atomic \u03b1 \u2192 complementedLattice \u03b1 \u2192 modular \u03b1 \u2192 coatomic \u03b1\""}
{"gold_output": "theorem _root_.Multiset.stronglyMeasurable_prod (s : Multiset (\u03b1 \u2192 M))\n(hs : \u2200 f \u2208 s, StronglyMeasurable f) :\nStronglyMeasurable fun x => (s.map fun f : \u03b1 \u2192 M => f x).prod :=", "model_response": "lemma strongly_measurable_prod' [measurable (raw)]:\n\"strongly_measurable (\\<lambda>x. (s.map (f :: \u03b1 \\<Rightarrow> M)).prod x)\""}
{"gold_output": "theorem coe_convex (s : AbsConvexOpenSets \ud835\udd5c E) : Convex \u211d (s : Set E) :=", "model_response": "lemma convex_gauge_le (C : \u211d) : Convex \u211d { x : E | gauge x \\<le> C } :="}
